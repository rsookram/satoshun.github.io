<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Wed, 25 Jul 2018 00:00:00 UTC</updated>
    
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>

&lt;p&gt;ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。
この記事では&lt;a href=&#34;https://developer.android.com/reference/android/widget/Space&#34;&gt;Space&lt;/a&gt;を使ったネガティブマージンの実現について説明します。&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;ネガティブマージンと同等の大きさを持った&lt;code&gt;Space&lt;/code&gt;を定義して、そこにConstraintを設定するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:clipToPadding=&amp;quot;false&amp;quot;
    android:padding=&amp;quot;80dp&amp;quot;&amp;gt;

  &amp;lt;Space
      android:id=&amp;quot;@+id/negative&amp;quot;
      android:layout_width=&amp;quot;15dp&amp;quot;
      android:layout_height=&amp;quot;15dp&amp;quot;
      app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;ImageView
      android:id=&amp;quot;@+id/icon&amp;quot;
      android:layout_width=&amp;quot;30dp&amp;quot;
      android:layout_height=&amp;quot;30dp&amp;quot;
      android:contentDescription=&amp;quot;icon&amp;quot;
      app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot;
      app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot;
      tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/LQrkHsAeTBvqlZWuw1Ccpm_dvrnCsdK7aH2rMB6HYakF_jv3q6Zf_-QBtfOo1eD0EjLBOjxy11nx2TAlZstr354XRiSXt7HUxENJXji8ZxWNxeJUTe8g9jIstSO1PRMsw7f8O5xuCakktrJLSUPLk01CI1N6OJ9MGMvsSbSDO6o4t7oeipkV9f7klqmzdxtoxESyDzoEI5SfeMOxynhmTGLwv6RnaASEOzVyL2xEW8eq63erAiu6ptdwl-_rQkxAnAIhYpSuPZjweCPBzf3GiMJi5gx_Ciz348GmoSaTIhuGM6grHd181fBGkZQkbvgg5ggrk5pLlja1N4eZA54n5rgzKs5gT36fA8K_ZFrAQI0H50cvAbesIeDVb05MZ2pP592Kwb8moTt6xp0TTFYrJf-c-MVljio-JvAKuUC0fPWPpdgMyxkJHW4AzK9l-Yo4f2-dUdfEf06J6ktMOsld0Yzsyu07Hki6MSGeBjU3bJ3R0vDi-W6SBUNmcDzJu5kC-2ItGmq4sN8fq06XJMSwVTmfDAyfHOluWHOTlL5LV3YVvYZxxgGJ6_ldqdD2HZ0ZW8wuNpfrHTxGLYCHR5EN5ouY5ILx-snrNAfQPQ9Z9Ph0U_4UeCMlODslXyRpueecgOSBJUhwc47xrQ04b-xOJz_01EWEA61x=w1452-h720-no&#34; alt=&#34;constraintlayout-image&#34; width=&#34;600px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;簡単に説明すると、&lt;code&gt;Space&lt;/code&gt;に15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。
上記の例だと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginStart=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginTop=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と同等の振る舞いをしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ConstraintLayoutではネイティブでネガティブマージンに対応していないため、&lt;code&gt;Space&lt;/code&gt;を使った、ややテクニカルな方法で実現するのが良いと思われます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>&lt;p&gt;Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-aliases.html&#34;&gt;https://kotlinlang.org/docs/reference/type-aliases.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias MyHandler = (Int, String, Any) -&amp;gt; Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにtypealiasは、アノテーションをつけることも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JvmSuppressWildcards&lt;/code&gt;はDagger(&lt;a href=&#34;https://github.com/google/dagger/issues/668&#34;&gt;参考リンク&lt;/a&gt;)やretrofit(&lt;a href=&#34;https://github.com/square/retrofit/issues/1805&#34;&gt;参考リンク&lt;/a&gt;)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/google/dagger&#34;&gt;Dagger&lt;/a&gt;を使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。
Androidでは、すべてのActivityで共通のインスタンスを使うには &lt;code&gt;Singleton&lt;/code&gt;スコープとAppComponentを組み合わせて使う方法がよく知られています。
しかし、&lt;strong&gt;特定&lt;/strong&gt;のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。Singletonだと&lt;strong&gt;すべて&lt;/strong&gt;のActivity間で共通のインスタンスが使えてしまいます。&lt;/p&gt;

&lt;p&gt;この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。
また、基本的なDaggerの使い方は知っている前提で説明していきます。&lt;/p&gt;

&lt;p&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;になります。
コードを見ると理解がより深まると思うので、ぜひご覧になってください😊&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では説明していきます。今回のサンプルコードの目指すところは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserScopeを定義し、MainActivity、UserScopedActivityで同一の&lt;code&gt;UserManager&lt;/code&gt;インスタンスを使用する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;まず最初にUserScopeを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Scope
@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
annotation class UserScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にUserSubcomponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UserScope
@Subcomponent
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは、UserSubcomponentに&lt;code&gt;UserScope&lt;/code&gt;スコープを持たせています。
このように書くことで、SubcomponentとScopeを結びつけることが出来ます。&lt;/p&gt;

&lt;p&gt;次にAppComponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  // AppComponentとUserSubcomponentを結びつける
  val userComponentBuilder: UserSubcomponent.Builder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは&lt;code&gt;AppComponent&lt;/code&gt;に、&lt;code&gt;val userComponentBuilder: UserSubcomponent.Builder&lt;/code&gt;を定義することです。
こうすることで、&lt;code&gt;AppComponent&lt;/code&gt;に&lt;code&gt;UserSubcomponent&lt;/code&gt;を結び付けることが出来ます。&lt;/p&gt;

&lt;p&gt;これで基本的な部分の定義は完了しました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次に、各ActivityをComponentに結びつけていきます。
サンプルではMainActivity、UserScopedActivityとNoUserScopedActivityの3つのActivityを定義しており、
それぞれのActivityは以下のように振る舞わせたいとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mainactivity-userscopedactivityをusersubcomponentに従わせる&#34;&gt;MainActivity、UserScopedActivityをUserSubcomponentに従わせる&lt;/h2&gt;

&lt;p&gt;MainActivity、UserScopedActivityを&lt;code&gt;UserSubcomponent&lt;/code&gt;に定義することで、MainActivity、UserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従わせることが出来ます。
なぜなら、&lt;code&gt;UserSubcomponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いているためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserSubcomponent.kt
@UserScope
@Subcomponent(modules = [
  MainActivityModule::class,
  UserScopedActivityModule::class
])
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}

// MainActivityModule.kt
@Module
interface MainActivityModule {
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nouserscopedactivityはuserscopeに従わない&#34;&gt;NoUserScopedActivityはUserScopeに従わない&lt;/h2&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;AppComponent&lt;/code&gt;に定義することで、NoUserScopedActivityで&lt;code&gt;UserScope&lt;/code&gt;を使っていたらコンパイルエラーにすることが出来ます。
&lt;code&gt;AppComponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いていないためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// AppComponent.kt
@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class,
      NoUserScopedActivityModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  val userComponentBuilder: UserSubcomponent.Builder
}

// NoUserScopedActivityModule.kt
@Module
interface NoUserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeNoUserScopedActivity(): NoUserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、定義は完了です。実際に正しく動くかを確認してみます。
適当に&lt;code&gt;UserScope&lt;/code&gt;に従う&lt;code&gt;UserManager&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserManager.kt
@UserScope
class UserManager @Inject constructor() {
  var value = 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;UserScope&lt;/code&gt;に従うので、MainActivity、UserScopedActivityには期待通り同一インスタンスが&lt;code&gt;Inject&lt;/code&gt;できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivity.kt
class MainActivity : AppCompatActivity() {

  // ok
  @Inject lateinit var userManager: UserManager

  ...
}
// UserScopedActivity.kt
class UserScopedActivity : AppCompatActivity() {

  // ok: MainActivityと同じインスタンスが注入される
  @Inject lateinit var userManager: UserManager

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、NoUserScopedActivityに&lt;code&gt;Inject&lt;/code&gt;しようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// NoUserScopedActivity.kt
class NoUserScopedActivity : AppCompatActivity() {

  //  下のコメントアウトを取るとコンパイルエラー
  //  @Inject lateinit var userManager: UserManager
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従う形で定義してないためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が達成できました。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;そもそも、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;定義時に、&lt;code&gt;UserScope&lt;/code&gt;スコープを付与してあげればいいんじゃないかと思うかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivityModule.kt
@Module
interface MainActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このやり方だと、今回のケースには不都合です。&lt;/p&gt;

&lt;p&gt;MainActivity、UserScopedActivityは&lt;code&gt;UserScope&lt;/code&gt;に従うのでコンパイルは通ります。
しかし、MainActivity、UserScopedActivityで同一インスタンスを使うことは出来ません。&lt;/p&gt;

&lt;p&gt;何故かと言うと、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;はSubcomponentを作るシンタックスシュガーのようなものですが、
&lt;code&gt;MainActivityModule&lt;/code&gt;と&lt;code&gt;UserScopedActivityModule&lt;/code&gt;はそれぞれ独立したSubcomponentを作るので、独立したComponent間で同一インスタンスを使うことが出来ないためです。&lt;/p&gt;

&lt;p&gt;今回のように、&lt;code&gt;UserSubcomponent&lt;/code&gt;を定義して、そのComponentをベースに所属させる必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;特定のActivityのみで共通のインスタンスを使いたいときは、結構めんどう

&lt;ul&gt;
&lt;li&gt;冗長な気がするので、もっといい方法があったら教えてください😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;がどういう動作をするのかを知っておくと、いざというときに便利&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>

&lt;p&gt;Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。
ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。&lt;/p&gt;

&lt;p&gt;このライブラリの機能に、&lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#Safe-args&#34;&gt;safeargs&lt;/a&gt;というものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。&lt;/p&gt;

&lt;h2 id=&#34;safeargsを使ってみる&#34;&gt;safeargsを使ってみる&lt;/h2&gt;

&lt;p&gt;一般的にFragmentに適当な値を渡すときは&lt;code&gt;Bundle&lt;/code&gt;を通して渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
val bundle = Bundle()
bundle.putInt(&amp;quot;step&amp;quot;, 10)

// 呼び出され側
val step = arguments?.getInt(&amp;quot;step&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&lt;code&gt;&amp;quot;step2&amp;quot;&lt;/code&gt;にしてしまうと、ランタイムエラーになります。&lt;/p&gt;

&lt;p&gt;これを解決にするためにNavigationではsafe argsという機能を提供しています。
これは、DataBindingのように、クラスを生成することでtypesafeを実現します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
            xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
            xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt;
  &amp;lt;fragment
      android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot;
      android:label=&amp;quot;Hoge&amp;quot;&amp;gt;

    &amp;lt;argument
        android:name=&amp;quot;step&amp;quot;
        app:type=&amp;quot;integer&amp;quot;
        android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt;
  &amp;lt;/fragment&amp;gt;
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とnavigationを記述すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HogeFragmentArgs {
  private int step = 1;

  private HogeFragmentArgs() {
  }

  public static HogeFragmentArgs fromBundle(Bundle bundle) {
    HogeFragmentArgs result = new HogeFragmentArgs();
    if (bundle.containsKey(&amp;quot;step&amp;quot;)) {
      result.step = bundle.getInt(&amp;quot;step&amp;quot;);
    }
    return result;
  }

  public int getStep() {
    return step;
  }

  public Bundle toBundle() {
    Bundle __outBundle = new Bundle();
    __outBundle.putInt(&amp;quot;step&amp;quot;, this.step);
    return __outBundle;
  }

  public static class Builder {
    private int step = 1;

    public Builder(HogeFragmentArgs original) {
      this.step = original.step;
    }

    public Builder() {
    }

    public HogeFragmentArgs build() {
      HogeFragmentArgs result = new HogeFragmentArgs();
      result.step = this.step;
      return result;
    }

    public Builder setStep(int step) {
      this.step = step;
      return this;
    }

    public int getStep() {
      return step;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のクラスが生成されます。これを使うことでtypesafeを実現出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
HogeFragmentArgs.Builder()
    .setStep(10)
    .build()
    .toBunble()

// 呼び出され側
val args = HogeFragmentArgs.fromBundle(arguments)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Navigationは大きいライブラリなので、とりあえずの練習でsafe argsの機能だけつまみ食いするのは、
個人的には良さそうだと思っています。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlecodelabs/android-navigation&#34;&gt;https://github.com/googlecodelabs/android-navigation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>

&lt;p&gt;LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。
適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。&lt;/p&gt;

&lt;p&gt;定義は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; {
  // skip用の初期値を入れておく
  return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null }
}

fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) {
  // 最初の値は常にskipすることで、キャッシュを無視する
  val firstIgnore = AtomicBoolean(true)
  this.observe(owner, Observer {
    if (firstIgnore.getAndSet(false)) return@Observer
    observer(it)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使う時はこんな感じで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// TestViewModel.kt
class TestViewModel: ViewModel() {
  val errorEvent = singleLiveData&amp;lt;String&amp;gt;()
}

// TestActivity.kt
testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java)
testViewModel.errorEvent.observeSingle(activity) {
  Log.d(&amp;quot;one&amp;quot;, it.toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メリットはサブクラスを作らずに済むところです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&#34;&gt;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&#34;&gt;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description>

&lt;p&gt;CoroutineBindingライブラリを作ったのでその紹介です。
&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android開発でCoroutineの流れが来ていると思っていて、&lt;a href=&#34;https://github.com/JakeWharton/RxBinding&#34;&gt;RxBinding&lt;/a&gt;のような感じで、
CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;例えばclickのイベントを受け取りたいとします。
CoroutineBindingでは以下のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root)
launch(UI) {
    for (click in root.clicks()) {
       Log.d(&amp;quot;clicked&amp;quot;, click.toString())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RxBindingのように使うことが出来ます!
他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt; 何かあればissueや、PRを貰えると嬉しいです&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>&lt;p&gt;Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。&lt;/p&gt;

&lt;p&gt;まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。
振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。&lt;/p&gt;

&lt;p&gt;型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;to be continued.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description>

&lt;p&gt;ポエムです。&lt;/p&gt;

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;p&gt;基本的にローカルで明示的に型を宣言するのは好ましくない&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userName = dataSource.getUserName()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。&lt;/p&gt;

&lt;p&gt;Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。&lt;/p&gt;

&lt;p&gt;理由としては、Data Bindingの生成が失敗すると、&lt;code&gt;MainActivityBinding&lt;/code&gt;みたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。
デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)&lt;/p&gt;

&lt;h2 id=&#34;解決法&#34;&gt;解決法&lt;/h2&gt;

&lt;p&gt;全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;kapt {
    javacOptions {
        option(&amp;quot;-Xmaxerrs&amp;quot;, 5000)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。&lt;/p&gt;

&lt;p&gt;これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。&lt;/p&gt;

&lt;p&gt;before(一部ログ修正しています)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;...
// 長いエラーログ
...
...
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
e: ActivityMainBinding.java:91: error: cannot find symbol
      @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) {
                                                                ^
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
e: ActivityMainBinding.java:102: error: cannot find symbol
      @Nullable DataBindingComponent component) {
                ^
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
:app:kaptProductDebugKotlin FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;after&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;...
// 長いエラーログ
...
...
e: :96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                ^
e::96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                     ^
e: :96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                           ^
e: .java:96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                                   ^
:app:kaptProductDebugKotlin FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beforeではDataBindingの参照エラーしか出ていないんですが、afterではIntDefでのエラーログが出ていることが分かります。
これが本当に欲しかったエラーログで、これを修正することで無事解決することが出来ました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Data Binding便利だけどやっぱつれぇわ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>

&lt;p&gt;ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。&lt;/p&gt;

&lt;p&gt;例えば以下のようなActivityがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : Activity() {
    ...
    ...

    private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見た時、「なんで &lt;code&gt;loginCount &amp;lt;= 100&lt;/code&gt;にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : Activity() {
    private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {
         // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。&lt;/p&gt;

&lt;p&gt;ただ、自分の考えでは上記のコードは根本的に間違っていると思っていて、そもそもActivityでコメントが必要なほど複雑なことをしているのが問題だと思います。
なんでActivityで複雑なことをしてはいけないかというと、ActivtyはContextにアクセスできたりと、なんでも出来るからです。なんでも出来る層でいろいろやってしまうと、
いわゆるfat activity問題が起こってしまいます。&lt;/p&gt;

&lt;p&gt;なので上記のコードだと、例えばUserモデル(データ)クラスのようなものを作ってそこにロジックを書いて、必要に応じてコメントを付加するのが良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class User(private val loginCount: Int, private val firstAccess: Boolean) {
    private fun isHeavyUser() : Boolean() {
         // 100回以上ログインした場合は超heavy userなので100以上はheavy userではない
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }

    private fun hyperHeavyUser(): Boolean() { /** */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人間に理解し難いビジネスロジックのコメントは、モデルクラス(世の中的にはドメインモデルとか言われているのカナ?)に書くのが良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Activityにコメントを書きたくなったら、クラスを分割したほうが良い&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;とはいえActivityにコメントを書く正しいケースもあると思うので、そこらへんは柔軟にオナシャス&lt;/li&gt;
&lt;li&gt;コメントはコードと違い、コンピュータがコンパイルして正当性を確かめてくれるわけでないので、正しく運用するのがコードより難しいと思う&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: Androidアプリ設計パターン入門</title>
      <link>https://satoshun.github.io/2018/03/android-architecture-started/</link>
      <pubDate>Fri, 02 Mar 2018 00:28:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/03/android-architecture-started/</guid>
      <description>

&lt;p&gt;Androidアプリ設計パターン入門を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://peaks.cc/books/architecture_patterns&#34;&gt;https://peaks.cc/books/architecture_patterns&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MVP

&lt;ul&gt;
&lt;li&gt;PresenterがViewとModelへの仲介役なので、Presenterはどうしてもfatになりそう

&lt;ul&gt;
&lt;li&gt;PresenterでView、Modelが何を出来るかを知らなければならない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Contractみたいなインタフェースを切るのは好き

&lt;ul&gt;
&lt;li&gt;それを見ただけで何をそのページでやっているのかが掴めるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PresenterはContextを知らなく良い、Pure Javaなのでテスタブルだし綺麗になりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MVVM

&lt;ul&gt;
&lt;li&gt;個人的にはMVPより好き

&lt;ul&gt;
&lt;li&gt;ViewModelがViewの参照を持たなくて良いので少しスッキリする

&lt;ul&gt;
&lt;li&gt;ただViewへの参照がないだけで、LiveDataなりObservableFieldに値を書き出すので実質的にはViewがどんなことをしたいか知っているから同等といえば同等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Viewへの参照を持たないので、AACのViewModelへの適合性は高いと思う

&lt;ul&gt;
&lt;li&gt;DataBindingのObservableFieldとかを使わない前提。使うとViewへの参照を持ってメモリリークしちゃう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Flux

&lt;ul&gt;
&lt;li&gt;単一方向データフローは凄い良いと思う

&lt;ul&gt;
&lt;li&gt;単一方向はFluxだけに限らないけど、Fluxを象徴する1つの特徴&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelとかPresenterって処理が集中する傾向にあると感じていて、FluxだとStore、ActionCreatorって形で切り出せるから良い&lt;/li&gt;
&lt;li&gt;FluxもAACとの相性は良いと思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;負債の話

&lt;ul&gt;
&lt;li&gt;負債に対する解決策の1つとしてReact Nativeを出すのは発想として凄いと思ったし、そういう解決方法もあるのかと思った&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;メモ

&lt;ul&gt;
&lt;li&gt;データ層の抽象化に関してはRepository的なものを作るで良さそう&lt;/li&gt;
&lt;li&gt;データ側はRx、UI側に反映する時はLiveDataが良さそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>DroidKaigi2018で「なんとなく動いているProguardから脱出するために」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2018/02/droidkaigi-2018/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/02/droidkaigi-2018/</guid>
      <description>&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://goo.gl/SMQW6M&#34; alt=&#34;DroidKaigi&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;DroidKaigi2018でセッションが採択されたので発表しました。&lt;/p&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/e/2PACX-1vSfnJcFK28DL1nnc2JVlZdGvtzjbv9Jw0A2UYMESKl0jRrk5qD02n9B1F-ss9L-5Ifvra_FnhkKTEgv/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; class=&#34;presentation-slide&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;https://goo.gl/S95MJs&#34;&gt;https://goo.gl/S95MJs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正直、Proguardは目新しいトピックでないのでそんなに聞きに来てくれないだろうなと思っていました。
しかし、Room3という広い部屋が割り当てられて、さらに当日はかなりの人が聞きに来てくれました。本当に聞きに来てくれた人ありがとうございます😊😊😊&lt;/p&gt;

&lt;p&gt;Twitterの反応を見る限りだと、分かりやすいと言っている人が多くいたので嬉しかったです。
Proguardは苦手意識を持っている人が多いと思っていて、なのでstep by stepで順序良く聞けるような発表を心掛けたのでその効果が少しは出たのかなと思っています。&lt;/p&gt;

&lt;p&gt;反省点としては、自分が想定したより時間に余裕があったので何か面白いことを喋ろうとしたら何も思いつかないでフガフガしてしまったところです。
今後はフガフガせずに、アドリブ力みたいなものを身につけていきたいと思います!&lt;/p&gt;

&lt;p&gt;あと、もう一つ反省点としてすべるのが怖くて積極的にネタみたいなものをスライドに入れられなかったことです。一応考えていたものは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「Self-Styled Proguardエバンジェリストです」と自己紹介しようとした。&lt;/li&gt;
&lt;li&gt;僕の発表資料はProguardに失敗してやや冗長になってしまいましたけど、みなさんのAPKサイズはProguardに成功して小さくなることを期待しています。みたいなことを言おうとした。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;みたいなことを言って笑いを取りたかったなと後悔しています(笑いを取れるとは言っていない)。&lt;/p&gt;

&lt;p&gt;来年もDroidKaigiあるとしたらCfP出してまた登壇できるように頑張ります。
そして運営の皆さん本当にありがとうございました。凄い楽しかったです(•ө•)♡&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: ViewがどのFragmentに属しているかをViewから取得する</title>
      <link>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</guid>
      <description>

&lt;p&gt;ViewがどのFragmentに属しているかを取得する方法の紹介になります。
前々からtag、id以外の仕組みで取得出来ないかなと考えていたら、GlideでViewからFragmentを取得するコードがありました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Nullable
private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {
  tempViewToSupportFragment.clear();
  findAllSupportFragmentsWithViews(
      activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);
  Fragment result = null;
  View activityRoot = activity.findViewById(android.R.id.content);
  View current = target;
  while (!current.equals(activityRoot)) {
    result = tempViewToSupportFragment.get(current);
    if (result != null) {
      break;
    }
    if (current.getParent() instanceof View) {
      current = (View) current.getParent();
    } else {
      break;
    }
  }

  tempViewToSupportFragment.clear();
  return result;
}

private static void findAllSupportFragmentsWithViews(
     @Nullable Collection&amp;lt;Fragment&amp;gt; topLevelFragments,
     @NonNull Map&amp;lt;View, Fragment&amp;gt; result) {
   if (topLevelFragments == null) {
     return;
   }
   for (Fragment fragment : topLevelFragments) {
    // getFragment()s in the support FragmentManager may contain null values, see #1991.
    if (fragment == null || fragment.getView() == null) {
      continue;
    }
    result.put(fragment.getView(), fragment);
    findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bumptech/glide/blob/master/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java#L192&#34;&gt;https://github.com/bumptech/glide/blob/master/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java#L192&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;説明すると、ターゲットのViewが所属しているactivity(&lt;code&gt;View#getContext&lt;/code&gt;から取得できる)ので、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;activity.getSupportFragmentManager().getFragments()&lt;/code&gt;と&lt;code&gt;fragment.getChildFragmentManager().getFragments()&lt;/code&gt;から、Activityが保持している全Fragmentを取得する&lt;/li&gt;
&lt;li&gt;それらのFragmentのTopのViewを取得する&lt;/li&gt;
&lt;li&gt;ターゲットのViewのgetParentを辿っていき、2で取得したViewと一致するViewを探す&lt;/li&gt;
&lt;li&gt;一致したViewが所属するFragment == ターゲットのViewが所属するFragment&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;という流れになっています。&lt;/p&gt;

&lt;p&gt;Glideのコードは効率的なコードなのでやや複雑ですが、Kotlinで効率性を考えずにに書くなら以下のようにも書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun View.findAttachFragment(): Fragment? {
  val activity = context as? FragmentActivity ?: return null
  val allFragments = findAllFragments(activity.supportFragmentManager.fragments)

  val root = activity.findViewById&amp;lt;View&amp;gt;(android.R.id.content)
  var result: Fragment? = null
  var current = this
  while (current != root) {
    result = allFragments.firstOrNull { it.view == current }
    if (result != null) break
    current = current.parent as? View ?: break
  }
  return result
}

private fun findAllFragments(
    fragments: List&amp;lt;Fragment?&amp;gt;?
): List&amp;lt;Fragment&amp;gt; {
  if (fragments == null || fragments.isEmpty()) return emptyList()
  val fragments = fragments.filter { it?.view != null }.filterNotNull()
  return fragments + findAllFragments(fragments.map { it.childFragmentManager.fragments }.flatten())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-example/GetViewFragmentSample&#34;&gt;https://github.com/satoshun-example/GetViewFragmentSample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ViewからFragmentを取得できる方法は正攻法では無いと思っていたんですが、それなりに簡潔な方法で取得できる方法がありました&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description>

&lt;p&gt;LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package android.arch.lifecycle;

public abstract class LiveData&amp;lt;T&amp;gt; {
    protected void onActive() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package android.arch.lifecycle

fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() {
  onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package android.arch

fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() {
  onActive() // コンパイルエラー &amp;quot;Cannot access &#39;onActive&#39;: it is protected in &#39;LiveData&#39;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;なぜかこのような挙動になるか&#34;&gt;なぜかこのような挙動になるか?&lt;/h2&gt;

&lt;p&gt;protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a&#34;&gt;https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: MVP, Dagger2, Retrofitなどなどでアプリを作りました</title>
      <link>https://satoshun.github.io/2015/09/android-app-events/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2015/09/android-app-events/</guid>
      <description>

&lt;p&gt;イベントを検索するAndroidアプリを作成したので, 使った技術のまとめです.&lt;/p&gt;

&lt;p&gt;アプリの技術的機能, 特徴は以下になります.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPを介してイベントのデータを取得する

&lt;ul&gt;
&lt;li&gt;検索対象のサーバは複数あるため(今回は3つ), どこかでそれらのレスポンスデータを同期する必要がある&lt;/li&gt;
&lt;li&gt;それら複数のサーバーはJSONを返すが, 微妙にJSONの構造が異なる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Data-Bindingライブラリを使う&lt;/li&gt;
&lt;li&gt;MVP(Model-View-Presenter)パターンを使う

&lt;ul&gt;
&lt;li&gt;Activity(Fragment)に機能が集中しないようにしたい!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記を中心にどのように実装をしたかを説明をしていきます.&lt;/p&gt;

&lt;p&gt;フルソースコードはここにあります. &lt;a href=&#34;https://github.com/satoshun/AndroidEvents&#34;&gt;https://github.com/satoshun/AndroidEvents&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;httpを介してイベントのデータを取得する&#34;&gt;HTTPを介してイベントのデータを取得する&lt;/h2&gt;

&lt;p&gt;connpass, Atnd, Zusaarの3つのAPIを使うことにしました. &lt;a href=&#34;http://square.github.io/retrofit/&#34;&gt;Retrofit&lt;/a&gt;でAPIを定義し,
JSONのパースには&lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt;, データの処理には&lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava&lt;/a&gt;を使いました.&lt;/p&gt;

&lt;p&gt;例えば, connpass APIは以下のように定義しました.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Get data from Conpass  */
public interface Connpass {
    @GET(&amp;quot;/v1/event&amp;quot;)
    Observable&amp;lt;ConnpassResponse&amp;gt; search(
            @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds);

    @GET(&amp;quot;/v1/event&amp;quot;)
    Observable&amp;lt;ConnpassResponse&amp;gt; search(
            @Query(&amp;quot;keyword&amp;quot;) String keyword,
            @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keywordとymdを指定してリクエストを生成します. 「2015/12/31のAndroidのイベント」のように使う想定です.
Retrofitを使うと, このようにinterfaceとして, APIを定義することが出来ます.
(&lt;a href=&#34;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/network/Connpass.java#L10&#34;&gt;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/network/Connpass.java#L10&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;次に, RxJavaの説明をします. RxJava(Observable)を使うと, 非同期にデータが扱いやすくなります. またデータのマージ(merge)や, フィルタリング(filter)などを簡単に行うことが出来ます.
今回は, 3つのAPI(connpass, Atnd, Zusaar)が終わるのを待ってから処理を開始したかったので, 以下のように書きました.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Observable.merge(
  connpass.search(keyword, generateYmd()),
  atnd.search(keyword, generateYmd()),
  zusaar.search(keyword, generateYmd()))
  .subscribe(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Observable.merge&lt;/code&gt;は複数のObservableを1つのObservableにまとめるAPIです. これで, 3つのAPIが終了するまでwaitすることが出来ます.
あとは, これをsubscribeして, データを取得します.(&lt;a href=&#34;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/ui/domain/EventInteractor.java#L41&#34;&gt;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/ui/domain/EventInteractor.java#L41&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;data-bindingライブラリを使う&#34;&gt;Data-Bindingライブラリを使う&lt;/h2&gt;

&lt;p&gt;Data-BindingはXMLレイアウトにbindしたいデータ(インスタンス)を記述することで, よしなにデータを出力してくれる機能です.
AngularJSのデータバインディングをイメージして貰えると良いと思います.
書くコード量が減り, とても便利なライブラリでした. (&lt;a href=&#34;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/res/layout/adapter_event.xml&#34;&gt;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/res/layout/adapter_event.xml&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;また, 推奨された使い方かどうかはわからないですが, ViewHolderパターンとして使うことも出来ます.
ViewHolderパターンは, Adapter#getViewでコストが掛かる処理(View#findViewByIdなど)をcacheするパターンです.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EventAdapter extends BaseAdapter {
    /*
      .. ....
     */

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            AdapterEventBinding binding = AdapterEventBinding.inflate(inflater, parent, false);
            view = binding.getRoot();
            view.setTag(binding);
        }

        AdapterEventBinding binding = (AdapterEventBinding) view.getTag();
        Event event = getItem(position);
        binding.setEvent(event);
        binding.setDateFormat(DATE_FORMAT);

        return view;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AdapterEventBindingをViewHolderの代わりに使っています.
(&lt;a href=&#34;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/ui/adapter/EventAdapter.java#L34&#34;&gt;https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/ui/adapter/EventAdapter.java#L34&lt;/a&gt;)
なかなか良いと思います.&lt;/p&gt;

&lt;h2 id=&#34;mvp-model-view-presenter-パターンを使う&#34;&gt;MVP(Model-View-Presenter)パターンを使う&lt;/h2&gt;

&lt;p&gt;MVPパターンとは, MVCの親戚?のようなパターンで, 責務をModel, View, Presenterにそれぞれ分割するパターンです.&lt;/p&gt;

&lt;p&gt;Android開発は, Activity(Fragment)の責務が大きくなりがちです. 具体的にはActivityは以下のよう責務を持ちます.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ユーザからのイベントハンドリング

&lt;ul&gt;
&lt;li&gt;クリック, ロングクリック, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;システムからのイベントハンドリング

&lt;ul&gt;
&lt;li&gt;画面回転, アプリ終了, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データの取得する際の非同期処理

&lt;ul&gt;
&lt;li&gt;HTTP(network), SQLite, SharedPreferences, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;取得したデータをパースしてViewにパースしたデータを割り当てる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらを全て1つのActivityで処理をすると, どうしてもFat-Activityになってしまいます. (１つのAcitvityが1000行ありますみたいな)&lt;/p&gt;

&lt;p&gt;そこでMVPです.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Presenter

&lt;ul&gt;
&lt;li&gt;Modelから(非同期に)データを取得し, Viewに取得したデータをどのようにに表示するかを指定する(ビューロジック)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Model

&lt;ul&gt;
&lt;li&gt;データを取得してアプリで使いやすい形にデータをパースする. いわゆるビジネスロジック.&lt;/li&gt;
&lt;li&gt;Retrofitを叩く&lt;/li&gt;
&lt;li&gt;SQLiteにQueryを発行する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;View(Activity)

&lt;ul&gt;
&lt;li&gt;ユーザからのクリックイベントなど, イベントのハンドリングをする(onClickとか)&lt;/li&gt;
&lt;li&gt;イベントの処理はPresenterに任せる&lt;/li&gt;
&lt;li&gt;必要なデータをPresenterから受け取り, 画面に表示する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このように責務を分割することで, Activityの責務が薄くなります.
今回のコードも今まで自分が書いたコードと比較すると, 大分良くなった気がします(当人比)&lt;/p&gt;

&lt;h2 id=&#34;その他-メモ&#34;&gt;その他, メモ&lt;/h2&gt;

&lt;h3 id=&#34;dagger2&#34;&gt;Dagger2&lt;/h3&gt;

&lt;p&gt;DI(Dependency Injection)をするためのツールで, 実装をデバッグ時, 本番時, テスト時に切り替えられるライブラリです.
デバッグ時はデータの取得先を変えたい, テスト時にはネットワークアクセスしないで欲しい, などといった時に力を発揮します.&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;MVPパターンの話をしましたが, MVPが絶対良いという話ではないです.
しかし, 何もパターンがないとFat-Activityになってしまったり, 無秩序なコードになってしまいがちなので, そのような場合は, MVPのようなパターンを導入したほうが良いと思います.&lt;/p&gt;

&lt;p&gt;まだアプリ自体はまだ付けたい機能があるため, 公開していません. 近々しようと思います.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;references&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://antonioleiva.com/mvp-android/&#34;&gt;MVP for Android: how to organize the presentation layer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>