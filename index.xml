<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Sun, 23 Dec 2018 09:14:43 UTC</updated>
    
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>

&lt;p&gt;Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、&lt;code&gt;ContinuationInterceptor&lt;/code&gt;を使えば上手くいきそうです。&lt;/p&gt;

&lt;h2 id=&#34;continuationinterceptorとは&#34;&gt;ContinuationInterceptorとは?&lt;/h2&gt;

&lt;p&gt;ContinuationInterceptorは次のようなインターフェースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * Marks coroutine context element that intercepts coroutine continuations.
 * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and
 * intercepts all coroutine continuations with [interceptContinuation] invocations.
 */
@SinceKotlin(&amp;quot;1.3&amp;quot;)
public interface ContinuationInterceptor : CoroutineContext.Element {
  public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;
  public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;)
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;interceptContinuation&lt;/code&gt;からContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class LifecycleContinuationInterceptor(
  private val lifecycle: Lifecycle
) : ContinuationInterceptor {
  override val key: CoroutineContext.Key&amp;lt;*&amp;gt;
    get() = ContinuationInterceptor

  override fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; {
    // ContinuationからJobを取得
    val job = continuation.context[Job]
    if (job != null) {
      lifecycle.addJob(job)
    }
    return continuation
  }
}

fun LifecycleOwner.addJob(job: Job) {
  lifecycle.addJob(job)
}

fun Lifecycle.addJob(job: Job) {
  val state = this.currentState
  val event = when (state) {
      ...
  }
  val observer = LifecycleJobObserver(job, event, this)
  this.addObserver(observer)
  job.invokeOnCompletion(observer)
}

private class LifecycleJobObserver(
  private val job: Job,
  private val event: Lifecycle.Event,
  private val lifecycle: Lifecycle
) : LifecycleObserver, CompletionHandler {
  @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
  fun onEvent(owner: LifecycleOwner, event: Lifecycle.Event) {
    if (event == this.event) {
      owner.lifecycle.removeObserver(this)
      job.cancel()
    }
  }

  override fun invoke(cause: Throwable?) {
    lifecycle.removeObserver(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Android Lifecycleと協調して動くContinuationInterceptorが出来ました。&lt;/p&gt;

&lt;p&gt;フルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample/blob/master/autodispose/src/main/java/com/github/satoshun/coroutine/autodispose/lifecycle/LifecycleContinuationInterceptor.kt&#34;&gt;ここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseActivity : AppCompatActivity(),
  CoroutineScope {

  private val job = Job()
  override val coroutineContext get() = job +
      Dispatchers.Main +
      LifecycleContinuationInterceptor(this) // ここでInterceptorを登録
}

class MainActivity : BaseActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // onCreateでlaunchしているので、onDestroyで自動的にキャンセルされる
    launch {
      ...
    }
  }

  override fun onResume() {
    super.onResume()

    // onResumeでlaunchしているので、onPauseで自動的にキャンセルされる
    launch {
      ...
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;a href=&#34;https://github.com/uber/AutoDispose&#34;&gt;Rx-AutoDispose&lt;/a&gt;のように実行したタイミングに応じて、キャンセルする場所を自動的に登録してくれます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もっと良い書き方が出来るか模索しているので、より適したAPI等を知っている人がいれば教えてくれると嬉しいです😊😊😊&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>

&lt;p&gt;この記事ではFragmentでLiveDataにObserverを登録するときは&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;を使うと良いという話をします。&lt;/p&gt;

&lt;p&gt;まず、Fragmentのおおまかなライフサイクルは次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onAttach&lt;/li&gt;
&lt;li&gt;onCreate

&lt;ul&gt;
&lt;li&gt;onCreateView&lt;/li&gt;
&lt;li&gt;onViewCreated

&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestoryView&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestroy&lt;/li&gt;
&lt;li&gt;onDetach&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここで重要なのは、&lt;code&gt;onDestroy&lt;/code&gt;が呼ばれることなく、複数回&lt;code&gt;onCreateView&lt;/code&gt;が呼ばれる可能性がある点です。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っている可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.data.observe(this, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。
このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。
しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。&lt;/p&gt;

&lt;p&gt;前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。
よって、FragmentにはView用のLifecycleが用意されています。それが、&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;前述のコードは次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // ViewのLifecycleOwnerを渡す
        viewModel.data.observe(viewLifecycleOwner, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！&lt;/p&gt;

&lt;h2 id=&#34;補足1&#34;&gt;補足1&lt;/h2&gt;

&lt;p&gt;Observerが開放されるタイミングはonDestroyがコールされるタイミングとは別にもう1つあります。
それは、Observerへの参照がなくなったタイミングです。内部的にObserverはWeakReferenceで保持されており、参照が無くなったタイミングでGCされます。&lt;/p&gt;

&lt;h2 id=&#34;補足2&#34;&gt;補足2&lt;/h2&gt;

&lt;p&gt;Observerの重複登録問題はattach/detachを繰り返す場合におこります。
サンプルコードは次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;while (true) {
    delay(3000)
    supportFragmentManager.commitNow {
        if (fragment.isDetached) attach(fragment)
        else detach(fragment)
　  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>

&lt;p&gt;この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃&lt;/p&gt;

&lt;h2 id=&#34;基本編&#34;&gt;基本編&lt;/h2&gt;

&lt;p&gt;Dagger + ViewModelを同時に使うのは少しツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel @Inject constructor(...): ViewModel()

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だとMainViewModelのインスタンス生成はViewModelProviderを介して行われません。よって次のように書く必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideMainViewModel(...) : MainViewModel {
        // ViewModelProviderを介して行う
        return ViewModelProviders.of(...).get(MainViewModel::class.java)
    }
}

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してインスタンス生成をすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。
このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()
or
class MainViewModel @Inject constructor(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideViewModelFactory(...) : ViewModelProvider.Factory {
        return object: ViewModelProvider.Factory {
            // ここでMainViewModelを生成する
            ...
        }
    }
}

class MainActivity : AppCompatActivity() {
    // ViewModelではなく、Factoryを注入する
    @Inject lateinit var factory: ViewModelProvider.Factory
    // activity-ktxで定義されている拡張関数を使う
    private val viewModel: MainViewModel by viewModels { factory }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;activity-ktxにある&lt;code&gt;viewModels&lt;/code&gt;拡張関数を使ってViewModelインスタンスを生成します。これでViewModelのライフサイクルを保つことができます！！&lt;/p&gt;

&lt;p&gt;Dagger + ViewModelは、大きくこの2つのアプローチがあるかなと思います。&lt;/p&gt;

&lt;h2 id=&#34;実例編&#34;&gt;実例編&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使うパターンと、Factoryを使うパターンのどっちの書き方がいいの？って話になると思うんですが、一長一短かなと思ってます。&lt;/p&gt;

&lt;p&gt;両方アプローチともに、ソースコード、ノウハウが出ているので参考リンクを張っておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nickbutcher/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/dagger/DribbbleModule.kt#L43&#34;&gt;plaid&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Provides&lt;/code&gt; + ViewModelを直接Injectするパターン&lt;/li&gt;
&lt;li&gt;各ViewModelごとにFactoryクラスを定義する必要があるので記述量は多い&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;コンパイルチェックがうまく動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接Inject出来るので使い側からすると間違った使い方は出来ない（はず）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@marco_cattaneo/android-viewmodel-and-factoryprovider-good-way-to-manage-it-with-dagger-2-d9e20a07084c&#34;&gt;Android ViewModel and FactoryProvider: good way to manage it with Dagger Multibindings&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Daggerのmultibindings + ViewModel FactoryをInjectするパターン&lt;/li&gt;
&lt;li&gt;最初に仕組みを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;multibindingsを使っているのでランタイム時に落ちる可能性がある&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その書き方をするとViewModelProviderを介さないので正しくない。間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ActivityKtxDaggerExample/tree/master/app/src/main/java/com/github/satoshun/example/sample&#34;&gt;Activity-Ktx + Dagger Example&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Factory用のカスタムクラス + ViewModel FactoryをInjectするパターン

&lt;ul&gt;
&lt;li&gt;僕のサンプルコードです😃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最初に汎用クラスを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;コンパイルチェックがうまく動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その書き方をするとViewModelProviderを介さないので正しくない。間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;個人的には一番最後の自分のパターンを押したいところですが、上記のパターンはそれぞれメリット/デメリットがあると思うので、プロジェクトによって使い分けるのがよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一番プロジェクトに適したパターンを適用するのが良いと思います😃&lt;/li&gt;
&lt;li&gt;DaggerでViewModelサポートの&lt;a href=&#34;https://github.com/google/dagger/issues/1271&#34;&gt;ISSUE&lt;/a&gt;が立っており、ViewModel + Daggerの計画があります

&lt;ul&gt;
&lt;li&gt;なので前述のパターンは過去のものとなる可能性が高いです😭&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>

&lt;p&gt;&lt;code&gt;JitPack&lt;/code&gt;からライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。
詳しくは次のリンクを参照してください。&lt;a href=&#34;https://blog.autsoft.hu/a-confusing-dependency/&#34;&gt;A Confusing Dependency&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に &lt;a href=&#34;https://docs.gradle.org/5.1-rc-1/userguide/declaring_repositories.html#sec::matching_repositories_to_dependencies&#34;&gt;Matching repositories to dependencies&lt;/a&gt; が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）&lt;/p&gt;

&lt;p&gt;まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、&lt;code&gt;cloudflare&lt;/code&gt;のSDKを依存関係に入れることを目指します。
また、今回の検証にはGradle 5.1-rc-1を使いました。&lt;a href=&#34;https://github.com/satoshun-android-example/GradleDependencyMatchingExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは従来の書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
        }
    }
}

---

// projectのbuild.gradle
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと全てのライブラリに対して、repositoriesで指定した&lt;code&gt;https://storage.googleapis.com/cloudflare-maven/public/&lt;/code&gt;へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。&lt;/p&gt;

&lt;p&gt;次に新機能を使った書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
            content {
                // group idがcom.cloudflareのライブラリだけこのURLが有効になる
                includeGroup &amp;quot;com.cloudflare&amp;quot;
            }
        }
    }
}

---

// projectのbuild.gradleは一緒
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しくcontentブロックが追加されました。ここで、このURLがどのライブラリで有効になって欲しいかを記述することが出来ます。今回のURLは&lt;code&gt;com.cloudflare:cloudflare-mobile-sdk&lt;/code&gt;でのみ有効になって欲しいので、&lt;code&gt;includeGroup &amp;quot;com.cloudflare&amp;quot;&lt;/code&gt;とgroup id指定することで達成できます。これでcloudflareのライブラリに対してダウンロード制限をかけられます!!&lt;/p&gt;

&lt;p&gt;また今回の事件の場合、JCenterに悪意のあるライブラリがアップロードされたのが問題なので、JCenterからダウンロードしたいライブラリのgroup idを&lt;code&gt;includeGroup&lt;/code&gt;で指定してあげれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {
    ...
    jcenter().mavenContent {
        includeGroup &amp;quot;org.jetbrains.kotlin&amp;quot;
        includeGroup &amp;quot;org.jetbrains.kotlinx&amp;quot;
        includeGroup &amp;quot;com.google.dagger&amp;quot;
        includeGroup &amp;quot;org.jetbrains&amp;quot;
        includeGroup &amp;quot;javax.inject&amp;quot;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、JCenterからダウンロードするライブラリに制限をかけられます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AndroidだとGradle5系を使えるのがAndroid Gradle Plugin3.4からになると思うので、まだ先は長い😂&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://google.github.io/truth/&#34;&gt;Truth&lt;/a&gt;はGoogleが開発をしているテストアサーションライブラリです。&lt;/p&gt;

&lt;p&gt;従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readableにアサーションが書ける&lt;/li&gt;
&lt;li&gt;デフォルトの失敗メッセージがわかりやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;それぞれについて説明していきます。&lt;/p&gt;

&lt;h2 id=&#34;readableにアサーションが書ける&#34;&gt;readableにアサーションが書ける&lt;/h2&gt;

&lt;p&gt;ドキュメントのbenefitにあるサンプルを取り上げ説明します。
&lt;a href=&#34;http://google.github.io/truth/benefits&#34;&gt;http://google.github.io/truth/benefits&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まず従来のJUnitスタイルを使って書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertFalse(middleName.isPresent());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）&lt;/p&gt;

&lt;p&gt;これがTruthを使うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertThat(middleName).isAbsent();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertThatはTruthに定義されているメソッドです。&lt;code&gt;middleName&lt;/code&gt;がabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。&lt;/p&gt;

&lt;p&gt;上記の&lt;code&gt;isAbsent&lt;/code&gt;はOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。
例えばIterableには、&lt;code&gt;containsAnyIn&lt;/code&gt;や&lt;code&gt;isEmpty&lt;/code&gt;などが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;失敗メッセージがわかりやすい&#34;&gt;失敗メッセージがわかりやすい&lt;/h2&gt;

&lt;p&gt;こちらもbenefitにあるサンプルを取り上げます。&lt;/p&gt;

&lt;p&gt;まずは従来にJUnitスタイルから。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertTrue(googleColors.contains(PINK));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。
失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。&lt;/p&gt;

&lt;p&gt;次にTruthスタイルです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertThat(googleColors).contains(PINK);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt;&lt;/code&gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。&lt;/p&gt;

&lt;p&gt;以上がTruthのメリットになります。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;truth-androidライブラリ&#34;&gt;Truth-Androidライブラリ&lt;/h3&gt;

&lt;p&gt;JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。
例えば、Intentには以下のアサーションメソッドを使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hasComponent
hasComponentClass
hasComponentPackage
hasPackage
hasAction
hasNoAction
hasData
hasType
extras
categories
hasFlags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。&lt;/p&gt;

&lt;h3 id=&#34;assertjとの比較&#34;&gt;AssertJとの比較&lt;/h3&gt;

&lt;p&gt;これも公式ドキュメントにまとめてあります。&lt;a href=&#34;http://google.github.io/truth/comparison&#34;&gt;http://google.github.io/truth/comparison&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現状の主だった差分は次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Truhtはまだ1.0.0になっていないのでAPIが変わる可能性がある&lt;/li&gt;
&lt;li&gt;TruthはChainスタイルで書くことを想定していない

&lt;ul&gt;
&lt;li&gt;これは現状のTruth哲学だが、AssertJのようなChainスタイルも普及してきたので、どちらが便利かはわからない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多少の差異はあれど、AssertJとTruthはとても似ているライブラリです。どちらか一方を使っているなら、乗り換えるメリットはおそらくないだろうという旨の内容です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Truthを使うと失敗メッセージがわかりやすくなる、便利!&lt;/li&gt;
&lt;li&gt;AssertJを使っているなら乗り換えるメリットはないかも&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Result&lt;/code&gt;が1.3からstdlibに入ったので紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;Resultは&lt;code&gt;Success T | Failure Throwable&lt;/code&gt;の2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。&lt;/p&gt;

&lt;h2 id=&#34;基本的な使い方&#34;&gt;基本的な使い方&lt;/h2&gt;

&lt;p&gt;使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val i: Result&amp;lt;Int&amp;gt; = Result.success(10)
val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;runCatching&lt;/code&gt;関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a = runCatching { doSomeThing() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resultに対する操作は以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// successに対して操作
val i = Result.success(10)
i.getOrNull() // 10
i.isSuccess // true
i.exceptionOrNull() // null
i.map { 10 * 10 }.getOrNull() // 100
i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
i.recover { 1111 }.getOrNull() // 10

// failureに対して操作
val t = Result.failure(IOException())
t.getOrNull() // null
t.isFailure // true
t.exceptionOrNull() // IOException
t.map { 10 * 10 }.getOrNull() // null
t.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
t.recover { 1111 }.getOrNull() // 1111
t.getOrThrow() // throw IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値successに対しての操作と、failureに対しての操作をそれぞれすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、Resultを使うことで、functionalっぽく書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;try {
    val data = doSomethingSync()
    processData(data)
} catch(e: Throwable) {
    showErrorDialog(e)
}

--&amp;gt;

runCatching { doSomethingSync() }
    .onFailure { showErrorDialog(it) }
    .onSuccess { processData(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クライアント側から見たときは、functionalっぽく書ける点がメリットだと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;resultは戻り値として返せない&#34;&gt;Resultは戻り値として返せない&lt;/h3&gt;

&lt;p&gt;これは、Resultのユースケースから外さないための制約です。なぜなら、Resultはその関数内で処理すべき例外であり、関数の呼び出し側で処理させるべきではないためです。
例えば、ある関数の返り値が&lt;code&gt;Result&amp;lt;User&amp;gt;&lt;/code&gt;となっていたときに、失敗する可能性は呼び出し側に伝わりますが、どのような失敗が起こるか分かりません。どのようにエラーを処理するかはこの関数内で完結すべきなので、返り値としてResultを指定することは出来ません。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にまとめました。より詳細な内容は&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;を見てください😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>

&lt;p&gt;Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングで&lt;code&gt;namespacedRClass&lt;/code&gt;フラグが新しく追加されたので紹介します。
本記事では&lt;code&gt;3.4.0-alpha07&lt;/code&gt;で試しました。&lt;/p&gt;

&lt;p&gt;まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。
それを解決するために&lt;code&gt;namespacedRClass&lt;/code&gt;が追加されました。使い方は簡単で、次の記述を&lt;code&gt;gradle.properties&lt;/code&gt;に追加するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;android.namespacedRClass=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。
例として、appcompatに依存しているライブラリモジュールを用意します。&lt;/p&gt;

&lt;p&gt;まずは、&lt;code&gt;namespacedRClass=false&lt;/code&gt;の時のRクラスです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class anim {
        private anim() {}

        public static final int abc_fade_in = 0x7f010000;
        public static final int abc_fade_out = 0x7f010001;
        public static final int abc_grow_fade_in_from_bottom = 0x7f010002;
        public static final int abc_popup_enter = 0x7f010003;
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。&lt;/p&gt;

&lt;p&gt;では次に、&lt;code&gt;namespacedRClass=true&lt;/code&gt;の時です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class color {
        private color() {}

        public static final int red3 = 0x7f04004b;
    }
    public static final class id {
        private id() {}

        public static final int title = 0x7f0700b1;
    }
    public static final class layout {
        private layout() {}

        public static final int base3 = 0x7f09001d;
    }
    public static final class string {
        private string() {}

        public static final int base_string3 = 0x7f0b002a;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このモジュールで定義したリソースの内容しか含まれていないことが分かります。appcompatのRクラスは含まれていません。
ライブラリモジュールのRクラスのサイズがかなり小さくすることが出来ました!!&lt;/p&gt;

&lt;p&gt;今後、中、大規模なAndroid開発はマルチモジュールに強く依存することになると思うので、このオプションをつけることで、デバッグ時のapkサイズを抑えることが期待できます。（リリース時はR8/Proguardを使うと思うので特に影響はない）&lt;/p&gt;

&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;

&lt;p&gt;ただし、注意点として、依存関係にあるライブラリのRクラスのマージが行われないため、appcompatなどのRクラスにアクセスしたいときは、明示的にRクラスをimportをする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import androidx.appcompat.R as AppCompatR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までだとライブラリモジュールのRクラスからすべてのリソースにアクセスできたのですが、それができなくなります。なので、このオプションをtrueしたときは、ライブラリモジュールでRクラスのimportパスを変更する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;マルチモジュール時代に適した機能だと思う

&lt;ul&gt;
&lt;li&gt;ライブラリサブモジュールのRクラスのサイズ大きくなる問題を解決できる&lt;/li&gt;
&lt;li&gt;デバッグ時のapkサイズをやや小さく出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; この記事はapiとimplementationの説明をする類の記事ではありません。&lt;/p&gt;

&lt;p&gt;Gradleで&lt;code&gt;compile&lt;/code&gt;がDeprecatedになり、implementationまたはapiを使うことが推奨されています。
それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。&lt;/p&gt;

&lt;p&gt;Dagger2でもcompileをimplementationに置き換えるPRが出されました。&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;https://github.com/google/dagger/pull/1130&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内容が興味深かったのでまとめてみようと思います。&lt;/p&gt;

&lt;p&gt;まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Add Dagger dependencies
dependencies {
  - compile &#39;com.google.dagger:dagger:2.x&#39;
  + implementation &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでjakeさんが&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とコメントしました。「Daggerコンパイラの依存はすべてのモジュールで明示的に書くだろうから、多分implementationで問題ないけど、議論の余地はある。」と。&lt;/p&gt;

&lt;p&gt;この議論を生んだ要因として、Daggerライブラリの性質があります。
Daggerをライブラリで使ったときに、そのライブラリ内ではComponentやModuleを使うため、当然DaggerのAPIを使うことになります。
しかし、クライアント側ではComponentとModuleなどのDaggerのAPIを使う必要は必ずしもありません。ただ、DaggerではLazy、ProviderなどのAPIも定義されており、これらのAPIはクライアント側で使うことが予想されます。
なので、結局このライブラリを依存に持つようなモジュールはLazy、Providerを使うことになるので、最終的にDaggerに依存することが確定しているなら、implementationではなく、apiで指定したほうが良いのではという話です。ただし、プロジェクトのモジュール構成によってはimplementationのほうがふさわしい場合もあるので、その場合はimplementationに置き換えることが期待されています。&lt;/p&gt;

&lt;p&gt;最終的なこの議論の着地として、implementationを使うかapiを使うかはプロジェクトに強く依存するのでどちらが正しいかはない。そのため、今回置き換えたいcompileはapiとほぼ同等の意味を持つので、置き換えるならapiのほうがふさわしいんじゃないか、今までと同じ動作をするので安全じゃないかという感じでまとまりました。&lt;/p&gt;

&lt;p&gt;現状の差分は以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;-  compile &#39;com.google.dagger:dagger:2.x&#39;
+  api &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

+ For more information on api vs implementation please see https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?utm_source=android-studio#new_configurations

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dagger-androidがimplementationのままなのは、こちらにはLazyやProviderなどのクライアントライブラリが使うであろうAPIが含まれていないためだと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;READMEを更新するのにかなり熱い議論をしているのがすごい印象的でした

&lt;ul&gt;
&lt;li&gt;手を抜かないって大事なんだなって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;より詳しい議論は、&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;ISSUE&lt;/a&gt;を見て下さい😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>

&lt;p&gt;Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。&lt;/p&gt;

&lt;p&gt;それが&lt;code&gt;3.4.0-alpha07&lt;/code&gt;以降で改善される見込みです🎉&lt;/p&gt;

&lt;p&gt;詳細はここにあります。&lt;a href=&#34;https://issuetracker.google.com/issues/116541301&#34;&gt;https://issuetracker.google.com/issues/116541301&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingApiDeprecateExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります😃&lt;/p&gt;

&lt;h2 id=&#34;エラーログの変化&#34;&gt;エラーログの変化&lt;/h2&gt;

&lt;p&gt;まずどのようなエラーログが出力されるかを見ていきます。
適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。&lt;/p&gt;

&lt;p&gt;まずはData Binding 3.2.1から。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;&amp;gt; Task :app:kaptGenerateStubsDebugKotlin
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol
  protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root,
                             ^
  symbol:   class DataBindingComponent
  location: class MainAct79Binding
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol
      boolean attachToRoot, @Nullable DataBindingComponent component) {
                                      ^
...
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data Binding周りのエラーログが無限に出ます。悲しい😂&lt;/p&gt;

&lt;p&gt;次に3.4.0-alpha07です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Task :app:kaptGenerateStubsDebugKotlin
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation
@error.NonExistentClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃&lt;/p&gt;

&lt;h2 id=&#34;クライアント側の対応&#34;&gt;クライアント側の対応&lt;/h2&gt;

&lt;p&gt;これに伴い、一部APIがdeprecatedになります。例えば、&lt;code&gt;main_act.xml&lt;/code&gt;は次のようにAPIが変更されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class MainActBinding extends ViewDataBinding {
  @NonNull
  public static MainActBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup root,
      boolean attachToRoot
  )

  @NonNull
  @Deprecated
  public static MainActBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup root, boolean attachToRoot, @Nullable Object component
  )

  @NonNull
  public static MainActBinding inflate(@NonNull LayoutInflater inflater)

  @NonNull
  @Deprecated
  public static MainActBinding inflate(@NonNull LayoutInflater inflater, @Nullable Object component)

  public static MainActBinding bind(@NonNull View view)

  @Deprecated
  public static MainActBinding bind(@NonNull View view, @Nullable Object component)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使う側の作業としては、上記のdeprecatedになったAPIを置き換える必要があります。ただ、すぐに消えるわけではないので、急いで置き換える必要はないと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AGPのアップデートは気軽に出来ないので、
Data Bindingのバージョンだけをアップデートしようと思ったんですが、エラーが出てしまい出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt &amp;quot;androidx.databinding:databinding-compiler:3.4.0-alpha07&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;ERROR: Data Binding annotation processor version needs to match the Android Gradle Plugin version. You can remove the kapt dependency androidx.databinding:databinding-compiler:3.4.0-alpha07 and Android Gradle Plugin will inject the right version.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AGPとData Bindingのバージョンは紐付いているため、片方だけをアップデートしようとしても無理なようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;AGPのアップデートをすればData Bindingのツラミの1つであったエラーログから解放される（かも）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingApiDeprecateExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Happy Data Binding Life🎉🎉🎉&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 計測方法は実環境に全く即していないので意味がない可能性が高いです。&lt;/p&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AGP3.4.0-alpha06&lt;/li&gt;
&lt;li&gt;Kotlin 1.3.10&lt;/li&gt;
&lt;li&gt;Kotlinx.coroutine 1.0.1&lt;/li&gt;
&lt;li&gt;Gradle 5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;比較対象&#34;&gt;比較対象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;kotlinx.coroutineを使ったサンプル

&lt;ul&gt;
&lt;li&gt;クラス数 300&lt;/li&gt;
&lt;li&gt;各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている&lt;/li&gt;
&lt;li&gt;300 * 7の2100箇所がCoroutine関連のコードになります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;kotlinx.coroutineを使わないサンプル

&lt;ul&gt;
&lt;li&gt;クラス数 300&lt;/li&gt;
&lt;li&gt;各クラスは7つのメソッドを持ち、その中で適当なメソッド（&lt;code&gt;Handler().post {}&lt;/code&gt;）をコールしている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/CoroutineBuildPerfExample&#34;&gt;サンプルコード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;計測コマンド&#34;&gt;計測コマンド&lt;/h3&gt;

&lt;p&gt;Build Scanを使って計測します。その際。build-cacheはoffにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;./gradlew clean
./gradlew build --no-build-cache --scan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。
また試行回数は10回程度で、最終結果のみを以下に掲載します。&lt;/p&gt;

&lt;h2 id=&#34;kotlinx-coroutineを使う&#34;&gt;kotlinx.coroutineを使う&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Time spent executing tasks 1m 16.034s
    All tasks	207	2m 42.833s
    Tasks avoided	12 (09.7%)	0.062s
    From cache	0 (00.0%)	0.000s
    Up-to-date	12 (09.7%)	0.062s
    Tasks executed	112 (90.3%)	2m 42.739s
    Cacheable	0 (00.0%)	0.000s
    Not cacheable	112 (90.3%)	2m 42.739s
    Lifecycle	45	0.023s
    No source	38	0.009s
    Skipped	0	0.000s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終実行時間は&lt;code&gt;1m 16.034s&lt;/code&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;kotlinx-coroutineを使わない&#34;&gt;kotlinx.coroutineを使わない&lt;/h2&gt;

&lt;p&gt;次に使わない例です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Time spent executing tasks 1m 1.520s
    All tasks	207	1m 57.416s
    Tasks avoided	12 (09.7%)	0.015s
    From cache	0 (00.0%)	0.000s
    Up-to-date	12 (09.7%)	0.015s
    Tasks executed	112 (90.3%)	1m 57.356s
    Cacheable	0 (00.0%)	0.000s
    Not cacheable	112 (90.3%)	1m 57.356s
    Lifecycle	45	0.021s
    No source	38	0.024s
    Skipped	0	0.000s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終実行時間は&lt;code&gt;1m 1.520s&lt;/code&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上記のような結果になりました。しかし、繰り返しになりますが、この比較は実環境に即して無い、そもそもサンプルコードが同等でないため正当じゃないです

&lt;ul&gt;
&lt;li&gt;ただ、Coroutineを入れてある程度の規模まで行くと、フルビルド時のビルド時間の増加は顕著になるかもしれません&lt;/li&gt;
&lt;li&gt;iMac Proを買ってもらいましょう💻s&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もっとこういうふうに比較してほしいであったり、間違っている部分があればご指摘いただければ幸いです😃&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/CoroutineBuildPerfExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>

&lt;p&gt;LiveDataの値を更新したい時、&lt;code&gt;MutableLiveData&lt;/code&gt;を使うのが一般的だと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel {
    val hoge = MutableLiveData&amp;lt;Int&amp;gt;()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だと、外のクラスから値を更新することが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val viewModel = MainViewModel()

// ok
viewModel.hoge.postValue(10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外のクラスからは更新出来ないようにするためには&lt;code&gt;LiveData&lt;/code&gt;に型変換する必要があります。&lt;/p&gt;

&lt;p&gt;例えば次のように書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel {
    private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;()
    val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、外のクラスからは&lt;code&gt;MutableLiveData&lt;/code&gt;が直接見えなくなり、明示的に型変換をしない限り&lt;code&gt;LiveData&lt;/code&gt;の値を更新できなくなります。&lt;/p&gt;

&lt;p&gt;ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。
なので、それの解決策を以下で紹介します。&lt;/p&gt;

&lt;h2 id=&#34;その1&#34;&gt;その1&lt;/h2&gt;

&lt;p&gt;まずコードをのせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ViewModel2 {
  protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) {
    postValue(value)
  }

  protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) {
    setValue(value)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ViewModel2と同じパッケージに定義
public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; {
  @Override
  protected void postValue(T value) {
    super.postValue(value);
  }

  @Override
  protected void setValue(T value) {
    super.setValue(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が定義になります。次に使い方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel2 : ViewModel2() {
  val userName = ViewModelLiveData2&amp;lt;String&amp;gt;()

  fun update() {
    userName.setValue(&amp;quot;test&amp;quot;)
    userName.postValue(&amp;quot;test2&amp;quot;)
  }
}

fun main2() {
  val viewModel = MainViewModel2()

  // compile error!!
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  viewModel.update()
  viewModel.userName.observeForever { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewModelLiveData2&lt;/code&gt;と&lt;code&gt;ViewModel2&lt;/code&gt;を作りました（名前は適当です）。&lt;/p&gt;

&lt;p&gt;ViewModelLiveData2クラスでpostValueメソッドとsetValueメソッドをオーバーライドし、
ViewModel2クラスと同じパッケージに入れることで、ViewModel2からそれらのメソッドをコール出来るようになり、
ViewModel2を継承したクラスからのみLiveDataの値を更新できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewModel.userName.setValue(&amp;quot;&amp;quot;)&lt;/code&gt;とクラス外からsetValueメソッドをコールするとコンパイルエラーになります。&lt;/p&gt;

&lt;p&gt;protectedメソッドが同一パッケージ内からアクセスすることが出来ることを利用したコードになります。&lt;/p&gt;

&lt;h2 id=&#34;その2&#34;&gt;その2&lt;/h2&gt;

&lt;p&gt;こちらもまずコードをのせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ViewModel3 {
  protected fun &amp;lt;T&amp;gt; ViewModelLiveData3&amp;lt;T&amp;gt;.postValue(value: T) {
    internalPostValue(value)
  }

  protected fun &amp;lt;T&amp;gt; ViewModelLiveData3&amp;lt;T&amp;gt;.setValue(value: T) {
    internalSetValue(value)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class ViewModelLiveData3&amp;lt;T&amp;gt; : LiveData&amp;lt;T&amp;gt;() {
  internal fun internalPostValue(value: T) {
    postValue(value)
  }

  internal fun internalSetValue(v: T) {
    value = v
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が定義になります。次に使い方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel3 : ViewModel3() {
  val userName = ViewModelLiveData3&amp;lt;String&amp;gt;()

  fun update() {
    userName.setValue(&amp;quot;test&amp;quot;)
    userName.postValue(&amp;quot;test2&amp;quot;)
  }
}

fun main3() {
  val viewModel = MainViewModel3()

  // compile error
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  viewModel.update()
  viewModel.userName.observeForever { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewModelLiveData3&lt;/code&gt;と&lt;code&gt;ViewModel3&lt;/code&gt;を作りました（名前は適当です）。&lt;/p&gt;

&lt;p&gt;ViewModelLiveData3クラスとViewModel3クラスを適当なサブモジュール内で定義します。
そして、Kotlinのinternalを修飾子を使うことで、外のモジュールからは直接値を更新することができなくなります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewModel.userName.setValue(&amp;quot;&amp;quot;)&lt;/code&gt;とクラス外からsetValueメソッドをコールしようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;abstract classをinterfaceにして上記のメソッドをデフォルトメソッドにすると次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface ViewModel2 {
  fun &amp;lt;T&amp;gt; ViewModelLiveData1&amp;lt;T&amp;gt;.setValue(value: T) {
    this.value = value
  }

  fun &amp;lt;T&amp;gt; ViewModelLiveData1&amp;lt;T&amp;gt;.postValue(value: T) {
    postValue(value)
  }
}

fun main() {
  ...

  // compile error
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  // ok
  with(viewModel) {
    userName.setValue(&amp;quot;&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;applyやwithを使ってViewModel2がreceiverになると、setValueメソッドがコール出来るため、外から値を更新することが出来てしまいます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;おそらくLiveDataの値を更新する部分は、&lt;code&gt;ViewModel&lt;/code&gt;や&lt;code&gt;Store&lt;/code&gt;クラスに集中すると思うので、それらのBaseクラスで上記のメソッドを定義することで楽ができるようになると思います。&lt;/li&gt;
&lt;li&gt;もっと良い、楽できる書き方があればぜひ教えてください!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いた&lt;a href=&#34;https://github.com/satoshun-android-example/LiveDataRemoveUnderScoreExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/blob/master/CHANGELOG.md#version-250-2018-11-18&#34;&gt;Retrofit 2.5.0&lt;/a&gt;からカスタムアノテーションが使えるようになったので、それの紹介です。&lt;/p&gt;

&lt;p&gt;例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。&lt;/p&gt;

&lt;p&gt;まず最初にアノテーションを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;annotation class RequireAuth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、上記で定義したアノテーションを使い、Apiを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface ApiService {
  @RequireAuth
  @GET(&amp;quot;login&amp;quot;)
  fun login(: retrofit2.Call&amp;lt;Unit&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;RequireAuth&lt;/code&gt;を処理するための&lt;code&gt;okhttp3.Interceptor&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class AuthInterceptor : Interceptor {
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()

    val invocation = request.tag(Invocation::class.java)
    val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)
    if (authAnnotation != null) {
      request = request
        .newBuilder()
        .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic AAAAA&amp;quot;).build()
    }
    return chain.proceed(request)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは、&lt;code&gt;val invocation = request.tag(Invocation::class.java)&lt;/code&gt;です。
Retrofit 2.5.0から&lt;code&gt;Invocation&lt;/code&gt;が追加され、&lt;code&gt;Request&lt;/code&gt;から&lt;code&gt;Invocation&lt;/code&gt;が取得できるようになりました。
&lt;code&gt;Invocation&lt;/code&gt;には、処理している&lt;code&gt;Request&lt;/code&gt;の&lt;code&gt;java.lang.reflect.Method&lt;/code&gt;が格納されており、
そこからアノテーションの情報を取得することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)&lt;/code&gt;で、
メソッドに&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションが付与されているかどうかを知ることが出来ます。
&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションがついていれば、&lt;code&gt;Request&lt;/code&gt;のヘッダーに認証情報を追加します。&lt;/p&gt;

&lt;p&gt;最後に、上記の&lt;code&gt;Interceptor&lt;/code&gt;をOkHttpクライアントに付与します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val client = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor())
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでRetrofitでカスタムアノテーションを使うことが出来ます!!&lt;/p&gt;

&lt;h2 id=&#34;invocation以前の場合&#34;&gt;Invocation以前の場合&lt;/h2&gt;

&lt;p&gt;Invocation以前は、&lt;code&gt;Headers&lt;/code&gt;を使い認証情報を付与するテクニックがありました。
詳しくは&lt;a href=&#34;https://speakerdeck.com/jakewharton/making-retrofit-work-for-you-ohio-devfest-2016?slide=39&#34;&gt;Making Retrofit Work For You&lt;/a&gt;にあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Headers(&amp;quot;Auth: true&amp;quot;)
@GET(&amp;quot;useheaderlogin&amp;quot;)
fun login(): retrofit2.Call&amp;lt;Unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Auth2Interceptor : Interceptor {
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()

    if (request.header(&amp;quot;Auth&amp;quot;) != null) {
      request = request
        .newBuilder()
        .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic BBBBB&amp;quot;).build()
    }
    return chain.proceed(request)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでも動くのですが、カスタムアノテーションを定義するやり方のほうが意味が伝わりやすいと思うので、よりよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Retrofit 2.5.0でInvocationが追加されてカスタムアノテーションが使えるようになりました

&lt;ul&gt;
&lt;li&gt;さらにInvocationはメソッドの引数リストを持っており、ログやアナリティクスなどに有効に使うことができます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/RetrofitCustomAnnotationExample&#34;&gt;ここに&lt;/a&gt;あります😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>

&lt;p&gt;Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、
そんな夢をみたAndroidエンジニアは数多くいると思います。&lt;/p&gt;

&lt;p&gt;この記事ではそんな夢を叶える方法を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ConstructorInjectionExample&#34;&gt;サンプルコードはここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;fragmentfactory&#34;&gt;FragmentFactory&lt;/h2&gt;

&lt;p&gt;Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment : Fragment() {
  @Inject lateinit var userHandler: UserHandler
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコンストラクタインジェクションにしたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment @Inject constructor(
  private val userHandler: UserHandler
) : Fragment() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;androidx.fragment:fragment:1.1.0-alpha01&lt;/code&gt;から、FragmentFactoryが追加されました!!
これを使うことでコンストラクタインジェクションが可能になります。&lt;/p&gt;

&lt;p&gt;MainFragmentインスタンスを生成する&lt;code&gt;FragmentFactory&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragmentFactory @Inject constructor(
  private val fragment: Provider&amp;lt;MainFragment&amp;gt;
) : FragmentFactory() {
  override fun instantiate(
    classLoader: ClassLoader,
    className: String,
    args: Bundle?
  ): Fragment {
    if (className == MainFragment::class.java.name) {
      return fragment.get()
    }
    return super.instantiate(classLoader, className, args)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FragmentFactory.instantiate&lt;/code&gt;をoverrideし、そこでMainFragmentのインスタンスを生成します。&lt;/p&gt;

&lt;p&gt;最後に、作成した&lt;code&gt;MainFragmentFactory&lt;/code&gt;をActivityの&lt;code&gt;FragmentManager&lt;/code&gt;に登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  @Inject lateinit var fragmentFactory: MainFragmentFactory

  override fun onCreate(savedInstanceState: Bundle?) {
    DaggerAppComponent.create().inject(this)
    supportFragmentManager.fragmentFactory = fragmentFactory

    super.onCreate(savedInstanceState)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SupportFragmentManager.fragmentFactory&lt;/code&gt;に登録します。
これで、Fragmentが生成されるとき&lt;code&gt;MainFragmentFactory&lt;/code&gt;がフックされます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SupportFragmentManager.fragmentFactory&lt;/code&gt;にFactoryを登録するタイミングは&lt;code&gt;super.onCreate(savedInstanceState)&lt;/code&gt;の前が良いと思います。
それは&lt;code&gt;super.onCreate&lt;/code&gt;のタイミングで以前のFragmentが復元されるためです。
復元されるタイミングで適切なFactoryがないとクラッシュするので、復元する前で登録する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;layoutinflater-factory&#34;&gt;LayoutInflater.Factory&lt;/h2&gt;

&lt;p&gt;次にViewです。&lt;code&gt;LayoutInflater.Factory&lt;/code&gt;が定義されています。
これを使うことでカスタムのコンストラクタを持ったViewを定義することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainTextView(
  context: Context,
  private val userHandler: UserHandler
) : TextView(context) {
  class Factory @Inject constructor(private val userHandler: UserHandler) {
    fun create(context: Context): MainTextView {
      return MainTextView(context, userHandler)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;カスタムのコンストラクタを持ったViewは通常の方法ではインスタンスを生成できませんが、
&lt;code&gt;LayoutInflater.Factory&lt;/code&gt;を使うことで、インスタンスを生成できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainLayoutInflaterFactory @Inject constructor(
  private val factory: MainTextView.Factory
) : LayoutInflater.Factory {
  override fun onCreateView(name: String, context: Context, attrs: AttributeSet?): View? {
    if (name == MainTextView::class.java.name) {
      return factory.create(context)
    }
    return null
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LayoutInflater.Factory.onCreateView&lt;/code&gt;をoverrideし、&lt;code&gt;MainTextView&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;p&gt;最後に、作成した&lt;code&gt;MainLayoutInflaterFactory&lt;/code&gt;をActivityの&lt;code&gt;layoutInflater.factory&lt;/code&gt;に登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  private lateinit var layoutInflaterFactory: MainLayoutInflaterFactory

  override fun onCreate(savedInstanceState: Bundle?) {
    DaggerAppComponent.create().inject(this)
    layoutInflater.factory = layoutInflaterFactory

    super.onCreate(savedInstanceState)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activityの&lt;code&gt;LayoutInflater.factory&lt;/code&gt;に登録します。登録するタイミングはsetContentViewの前が良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;appcomponentfactory&#34;&gt;AppComponentFactory&lt;/h2&gt;

&lt;p&gt;次にActivityです。
Activityに依存関係を注入する時、普通にやると以下のコードになると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : Activity() {
  @Inject lateinit var presenter: UserPresenter
  @Inject lateinit var analytics: Analytics
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコンストラクタインジェクションにしたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity @Inject constructor(
  private val presenter: UserPresenter,
  private val analytics: Analytics
): Activity() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、この書き方はうまくいきません。なぜならActivityインスタンスはシステム側で自動的に生成されるためです。
カスタム定義のコンストラクタだと、システム側でインスタンスを生成することが出来ません。&lt;/p&gt;

&lt;p&gt;これを解決するべく、API28からAppComponentFactoryというクラスが追加されました!!&lt;/p&gt;

&lt;p&gt;MainActivityインスタンスを生成する&lt;code&gt;AppComponentFactory&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Suppress(&amp;quot;unused&amp;quot;)
class MainAppComponentFactory : AppComponentFactory() {
  private lateinit var application: App

  override fun instantiateActivityCompat(
    cl: ClassLoader,
    className: String,
    intent: Intent?
  ): Activity {
    if (className == MainActivity::class.java.name) {
      return application.appComponent.mainActivity
    }
    return super.instantiateActivityCompat(cl, className, intent)
  }

  override fun instantiateApplicationCompat(cl: ClassLoader, className: String): Application {
    application = super.instantiateApplicationCompat(cl, className) as App
    return application
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にAndroidマニフェストに&lt;code&gt;MainAppComponentFactory&lt;/code&gt;を登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;...
  &amp;lt;application
    android:allowBackup=&amp;quot;true&amp;quot;
    android:name=&amp;quot;.App&amp;quot;
    android:appComponentFactory=&amp;quot;com.github.satoshun.example.sample.MainAppComponentFactory&amp;quot;
    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
    android:label=&amp;quot;@string/app_name&amp;quot;
    android:roundIcon=&amp;quot;@mipmap/ic_launcher_round&amp;quot;
    android:supportsRtl=&amp;quot;true&amp;quot;
    android:theme=&amp;quot;@style/AppTheme&amp;quot;
    tools:replace=&amp;quot;android:appComponentFactory&amp;quot;&amp;gt;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AppComponentFactory.instantiateActivityCompat&lt;/code&gt;をoverrideし、&lt;code&gt;MainActivity&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;p&gt;これで、カスタムのコンストラクタを持ったActivityインスタンスを生成することが出来ます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fragment、Viewは今からでも使い始めることができる。Daggerなどのライブラリと組み合わせると最高☆&lt;/li&gt;
&lt;li&gt;AppComponentFactoryはAPI28からなので&amp;hellip;5年後くらいでしょうか😢&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ConstructorInjectionExample&#34;&gt;サンプルコードはここです&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;何か疑問点があれば、twitterやサンプルコードのISSUEなどで聞いてください😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Contracts &#43; 拡張関数でより便利に</title>
      <link>https://satoshun.github.io/2018/11/more_convenient_contracts/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/more_convenient_contracts/</guid>
      <description>

&lt;p&gt;Kotlin 1.3.0からContractsが実装されました。
Contractsを使うことで、関数がどのような振る舞いをするか、どういう効果をもたらすかを定義（契約）することが出来ます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;isNullOrEmpty&lt;/code&gt;メソッドがfalse返すなら、
Contractsによりnullでないことが保証されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a: String? = ...
if (!a.isNullOrEmpty()) {
    println(a.length) // !!が必要ない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Contractsがない時代だと呼び出し元で&lt;code&gt;isNullOrEmpty&lt;/code&gt;がどんな振る舞いをするかを知るすべがなかったので、
&lt;code&gt;!!&lt;/code&gt;をつける必要があったのですが、Contractsによりnullでないことが保証できるので、&lt;code&gt;!!&lt;/code&gt;を省略できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isNullOrEmpty&lt;/code&gt;の実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@kotlin.internal.InlineOnly
public inline fun CharSequence?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }

    return this == null || this.length == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;contract&lt;/code&gt;はDSL（関数）として定義されています。
これを呼び出し、そのブロックの中でこの関数が満たす振る舞いを定義する事ができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isNullOrEmpty&lt;/code&gt;の場合は&lt;code&gt;returns(false) implies (this@isNullOrEmpty != null)&lt;/code&gt;が契約として定義されています。&lt;/p&gt;

&lt;p&gt;これは、&lt;code&gt;「returns(false)&lt;/code&gt;: falseを返すなら &lt;code&gt;(this@isNullOrEmpty != null)&lt;/code&gt;: 自分自身がnullじゃない」という意味になります。
なので呼び出し元ではfalseが返ってきたら、nullではないことが保証されるので、smartcastにより&lt;code&gt;!!&lt;/code&gt;をつける必要がなくなるわけです。&lt;/p&gt;

&lt;p&gt;なので、例えば&lt;code&gt;T.isEmpty(t: T?): Boolean&lt;/code&gt;のようなメソッドがあり、ついでにnullチェックもこの関数の中でやっているようなときは、
contractを定義することでより使いやすい関数にすることが出来ます。&lt;/p&gt;

&lt;p&gt;他の例を見てみます。スコープ関数&lt;code&gt;apply&lt;/code&gt;の実装は次になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@kotlin.internal.InlineOnly
public inline fun &amp;lt;T&amp;gt; T.apply(block: T.() -&amp;gt; Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;関数内では、&lt;code&gt;callsInPlace(block, InvocationKind.EXACTLY_ONCE)&lt;/code&gt;が契約として定義されています。
これは、&lt;code&gt;block&lt;/code&gt;関数が必ず1度呼び出されることを意味します。
これにより、以下のように書くことが可能になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a: String
hoge.apply {
    a = &amp;quot;hoge&amp;quot;
}
println(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;関数は1度しか呼び出されないので&lt;code&gt;val a: String&lt;/code&gt;の初期化が、&lt;code&gt;apply&lt;/code&gt;関数内で正しく行われることが保証されます。
Kotlin 1.3.0以前のcontractが内時代では上記のコードはコンパイルエラーになっていたのですが、
contractにより、実行することが可能になりました。&lt;/p&gt;

&lt;p&gt;今まで見てきたのはKotlinのスタンダートライブラリに入っていた関数ですが、カスタムで定義することも可能です。
今回は例として、&lt;code&gt;ActivityScenario.onActivity&lt;/code&gt;メソッドをcontract + 拡張関数を使ってより便利にしたいと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/android/android-test/blob/f2f3589c9d6e2ff5740117192cb7e13bd8873a0f/core/java/androidx/test/core/app/ActivityScenario.java#L500&#34;&gt;ActivityScenario.onActivity&lt;/a&gt;メソッドは、callbackを登録すると、Activityの準備ができたタイミングでcallbackが叩かれます。そして、この&lt;code&gt;onActivity&lt;/code&gt;メソッドは一度しかコールされず、実行したスレッドをブロックします。なので、前述した&lt;code&gt;apply&lt;/code&gt;関数と同じcontractを書くことが可能です。&lt;/p&gt;

&lt;p&gt;以下のように拡張関数を書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UseExperimental(ExperimentalContracts::class)
fun &amp;lt;T : Activity&amp;gt; ActivityScenario&amp;lt;T&amp;gt;.onActivity2(block: (T) -&amp;gt; Unit) {
  contract {
    callsInPlace(block, InvocationKind.EXACTLY_ONCE)
  }
  onActivity {
    block(it)
  }
}


// コンパイルエラーにならない!!
val activity: Activity
scenario.onActivity2 {
    activity = it
}
println(activity)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@UseExperimental(ExperimentalContracts::class)&lt;/code&gt;をつけることで、ユーザ定義のcontractを定義することが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1度しかコールされないcallbackや、関数内でnullチェックをする場合はcontractを使うと超便利になるかも&lt;/li&gt;
&lt;li&gt;拡張関数を新しく定義することで、既存のメソッドをよりkotlin-friendlyなメソッドにできるかも!?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md&#34;&gt;https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: デバッグ時にMoshi、Daggerリフレクションライブラリを使いビルド時間を短縮する</title>
      <link>https://satoshun.github.io/2018/11/debug_reflection/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/debug_reflection/</guid>
      <description>

&lt;p&gt;ビルド時間の短縮は開発効率を上げる大きな要素です。
極力kapt（アノテーションプロセッサー）を使わなくすることで、ビルド時間を短縮出来ます。
アノテーションプロセッサーを使ったライブラリは、アノテーションプロセッサーを使わない、
リフレクションを用いたデバッグ用の機能を提供していることがあります。&lt;/p&gt;

&lt;p&gt;今回は、MoshiとDaggerリフレクションライブラリの紹介をします。
Daggerリフレクションは絶賛開発中 + 公式ではないので、機能がかなり制限されている、どういう未来が待っているかわからない点に注意してください。&lt;/p&gt;

&lt;p&gt;検証に用いた&lt;a href=&#34;https://github.com/satoshun-android-example/DebugReflectExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;moshiリフレクション&#34;&gt;Moshiリフレクション&lt;/h2&gt;

&lt;p&gt;Moshiにはmoshi-codegenと呼ばれる、アノテーションプロセッサーでコード生成してくれるライブラリがあります。
これは実行時のパフォーマンスには優れているのですが、アノテーションプロセッサーを使っているため、ビルドに時間がかかってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、Moshiではmoshi-reflectionと呼ばれるライブラリを提供しており、これはアノテーションプロセッサーを使うことなく、
moshi-codegenと同等の機能を提供してくれます。
ただし、moshi-reflectionは内部でリフレクションを使っているため、実行時のパフォーマンスには優れていません。あくまでデバッグ用、という立ち位置だと思います。&lt;/p&gt;

&lt;p&gt;デバッグ時にmoshi-reflectionを使い、リリース時にmoshi-codegenを使うことで、ビルド速度と実効速度の天秤を勝ち取ることが出来ます。&lt;/p&gt;

&lt;p&gt;具体的には、デバッグ時、リリース時に&lt;code&gt;build.gradle&lt;/code&gt;で指定するライブラリを、Moshiに登録するAdapterを変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// bulid.gradle

implementation &amp;quot;com.squareup.moshi:moshi:1.8.0&amp;quot;
debugImplementation &amp;quot;com.squareup.moshi:moshi-kotlin:1.8.0&amp;quot;
kaptRelease &amp;quot;com.squareup.moshi:moshi-kotlin-codegen:1.8.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// debug時
fun createMoshiBuilder() = Moshi.Builder()
    .add(KotlinJsonAdapterFactory()) // KotlinJsonAdapterFactoryを指定する
    .build()

// release時
fun createMoshiBuilder() = Moshi.Builder()
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、リリース時のみkaptを実行するようになります。&lt;/p&gt;

&lt;h2 id=&#34;daggerリフレクション&#34;&gt;Daggerリフレクション&lt;/h2&gt;

&lt;p&gt;これはSdkSearch内で開発が行われているライブラリです。有名なAndroidエンジニアであるJake Whartonさんが開発をしています。&lt;/p&gt;

&lt;p&gt;これもMoshiと同様に、リフレクションを使っています。
Daggerリフレクションでは、必要最低限のクラスはアノテーションプロセッサーで作成するようになっています。
アノテーションプロセッサーの完全除去というわけではありません。例えば、アノテーションプロセッサーで&lt;code&gt;DaggerAppComponent&lt;/code&gt;は作られます。
しかし、かなりの数のクラスを作成しないようになっています。&lt;/p&gt;

&lt;p&gt;具体的なコードは、以下のようになります。
Mavenにアップデートされていないので、SdkSearchからソースコードをコピーして使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &amp;quot;com.google.dagger:dagger:2.18&amp;quot;
debugImplementation project(&#39;:dagger-reflect:reflect&#39;) // SdkSearchからコピー
kaptDebug project(&#39;:dagger-reflect:reflect-compiler&#39;) // SdkSearchからコピー
kaptRelease &amp;quot;com.google.dagger:dagger-compiler:2.18&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバッグ時にはDaggerリフレクションを使い、リリース時にはdagger-compilerを使っています。
変更差分はbuild.gradleのみです。コードは全く修正する必要はありません。&lt;/p&gt;

&lt;p&gt;最初にも書いたのですが、Daggerリフレクションは絶賛開発中で、Scope、セッターインジェクションなど、多くの機能が使えない状態です。
ここが揃ってくればデバッグ時にはDaggerリフレクションを使うことで、プロダクションビルドと同等の動作で、ビルド時間の短縮が可能になってくると思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;デバッグ時にはkapt、アノテーションプロセッサーを抑制しビルド時間を短縮しよう😃

&lt;ul&gt;
&lt;li&gt;butterknifeもreflectionを使うことができる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Daggerリフレクションには期待しかない😄

&lt;ul&gt;
&lt;li&gt;何か進みがあったらまたまとめようと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の記事を検証するために作った&lt;a href=&#34;https://github.com/satoshun-android-example/DebugReflectExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JakeWharton/SdkSearch&#34;&gt;https://github.com/JakeWharton/SdkSearch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/moshi&#34;&gt;https://github.com/square/moshi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jakewharton.com/helping-dagger-help-you/&#34;&gt;https://jakewharton.com/helping-dagger-help-you/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>