<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Sat, 23 Feb 2019 02:47:59 UTC</updated>
    
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>

&lt;p&gt;Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。
まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、&lt;code&gt;AndroidJUnit4&lt;/code&gt;ランナーが使えるなど、かなりの部分が共通化出来ます。&lt;/p&gt;

&lt;p&gt;この記事では、ユニットテストで&lt;code&gt;Activity.onActivityResult&lt;/code&gt;のテストをどこまでandroid testのように書けるかを検証します。&lt;/p&gt;

&lt;h2 id=&#34;テスト対象コード&#34;&gt;テスト対象コード&lt;/h2&gt;

&lt;p&gt;まず最初に、テスト対象コードは次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  ...
  override fun onCreate(savedInstanceState: Bundle?) {
    ...

    button.setOnClickListener {
      startActivityForResult(
        Intent(this, Sub2Activity::class.java).apply {
          putExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;)
        },
        1
      )
    }
  }

  override fun onActivityResult(
    requestCode: Int,
    resultCode: Int,
    data: Intent?
  ) {
    super.onActivityResult(requestCode, resultCode, data)
    if (requestCode == 1) {
      if (resultCode == Activity.RESULT_OK) {
        val value = data!!.getIntExtra(&amp;quot;test&amp;quot;, -1)
        button.text = value.toString()
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Sub2Activity : AppCompatActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)

    button.setOnClickListener {
      val intent = Intent()
      intent.putExtra(&amp;quot;test&amp;quot;, 10)
      setResult(Activity.RESULT_OK, intent)
      finish()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはMainActivityで&lt;code&gt;startActivityForResult&lt;/code&gt;がコールされ、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;で値をセットし、MainActivityの&lt;code&gt;onActivityResult&lt;/code&gt;で結果を受け取るサンプルコードになります。&lt;/p&gt;

&lt;p&gt;では、テストを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;テストコード&#34;&gt;テストコード&lt;/h2&gt;

&lt;p&gt;以下が、今回書いたテストコードになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(AndroidJUnit4::class)
internal class MainActivityTest {
  @get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)

  @Test
  fun onActivityResultTest() {
    val expectCode = 10

    // assertion setResult
    val scenario = ActivityScenario.launch(Sub2Activity::class.java)
    scenario.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
    }

    // assertion resultCode
    val result = scenario.result
    assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

    // assertion intent params
    val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
    bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)

    scenario.close()

    Intents
      .intending(
        IntentMatchers.hasComponent(
          ComponentName(
            ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
            Sub2Activity::class.java
          )
        )
      )
      .respondWith(result)

    val main = ActivityScenario.launch(MainActivity::class.java)
    main.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

      // assertion intent for startActivity(ForResult)
      val name = ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
      Intents.intended(IntentMatchers.hasComponent(name))
      Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

      // assertion onActivityResult behaves
      Espresso
        .onView(ViewMatchers.withId(R.id.button))
        .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上から順番に重要な部分を説明していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、Espresso-Intentsを使うときに必要なルールです。&lt;code&gt;Intens.intended&lt;/code&gt;、&lt;code&gt;intending&lt;/code&gt;を使うために必要なルールになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val scenario = ActivityScenario.launch(Sub2Activity::class.java)
scenario.onActivity {
    it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioはActivityを起動するためのクラスです。これはSub2Activityを起動して、ボタンをクリックするという意味になります。
ボタンがクリックされると、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;が発火するようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val result = scenario.result
assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioでは、ActivityResultクラスから結果を取得することが出来ます。このクラスにはresultCodeと、resultDataがセットされており、それらの値をTruthを使いチェックします。この場合、&lt;code&gt;setResult&lt;/code&gt;で、resultcodeに&lt;code&gt;Activity.RESULT_OK&lt;/code&gt;が、resultdataにはキー名&lt;code&gt;test&lt;/code&gt;、値10がセットされていることを確認してします。&lt;/p&gt;

&lt;p&gt;ここまでで、Sub2ActivityのsetResultで正しい値をセットしていることがテスト出来ます。&lt;/p&gt;

&lt;p&gt;では次に、MainActivityで上記の値を受け取れることをテストしていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Intents
  .intending(
    IntentMatchers.hasComponent(
      ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
    )
  )
  .respondWith(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Intents.intending&lt;/code&gt;はマッチしたIntentが発行されたときに、onActivityResultに結果を返すAPIになります。
MainActivityのonActivityResultに、先ほどのSub2Activityの結果を渡すという意味になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val main = ActivityScenario.launch(MainActivity::class.java)
main.onActivity {
  it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

  val name = ComponentName(
    ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
    Sub2Activity::class.java
  )
  Intents.intended(IntentMatchers.hasComponent(name))
  Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

  Espresso
    .onView(ViewMatchers.withId(R.id.button))
    .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは、クリックイベントを発火し、&lt;code&gt;startActivityForResult&lt;/code&gt;をコールします。渡したIntentを&lt;code&gt;Intents.intended&lt;/code&gt;で正しいことを確認します。最後に、Espressoを使って、&lt;code&gt;onActivityResult&lt;/code&gt;の結果を正しく反映されているかを確認します。&lt;/p&gt;

&lt;p&gt;これで、テスト完了です😃
2つのActivityに関連するonActivityResultのテストが無事に出来ました！！&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Espressoにはご存知、clickをするためのAPIがあるのですが、うまく動きませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// not working!!
Espresso
  .onView(ViewMatchers.withId(R.id.button))
  .perform(ViewActions.click())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;調べたんですが、原因がわかりませんでした😂分かり次第追記します。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上記のテストくらいなら、ユニットテストで書ける。すごい😃

&lt;ul&gt;
&lt;li&gt;onActivityResultみたいな、クラス間のつながりが弱い部分は意図せず壊れやすいので、テストを書いておくと安心かも😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/tests/lifecycle/MainActivityTest.kt&#34;&gt;satoshun-android-example/Tests&lt;/a&gt;にあります。&lt;/p&gt;

&lt;p&gt;もっと良い書き方を知っているよと言う人は教えて頂けるととても嬉しいです😃😃😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>

&lt;p&gt;マルチモジュール遷移方法Part2です。&lt;a href=&#34;https://satoshun.github.io/2018/12/multi-module_transition_part1/&#34;&gt;Part1&lt;/a&gt;はここになります😌&lt;/p&gt;

&lt;p&gt;Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。&lt;/p&gt;

&lt;p&gt;また、今回の検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;モジュール構成について&#34;&gt;モジュール構成について&lt;/h2&gt;

&lt;p&gt;細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/img/SoWkIImgAStDuU8goIp9ILLutBpeSTEEnyrB7pVlUToy-kdipLnS1Od9sOdfgGfAYGK5yMcfYIMbHQbA2jLS2WhHG95O45sKNrgIMXJBLOkakhWqoH1DEKWe5iQ8nw7925EJ4KoJ4RAcvFpSWloyrBmIi3lGN1wha5Yi01H6LWNHYqqXH0PPxUF6kOyRrptPFGqi3t8likpBnktFb-z-tBJaSVFcnqtxmIPDVToq7CHesWdN4a-4kKQacmiB1Iuka2KAkdOebe4KGCKG2e4XeQ2Rab-U1rCC3MDq2IEi4Z1Jk20Cg7WDghrOv13sEwJcfG2J6G00&#34; width=600&gt;&lt;/p&gt;

&lt;p&gt;各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。&lt;/p&gt;

&lt;p&gt;このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。&lt;/p&gt;

&lt;p&gt;では、実装に入っていきます。今回はDagger2を使って実装をします。&lt;/p&gt;

&lt;h2 id=&#34;featureモジュール側の遷移用インターフェースの定義&#34;&gt;featureモジュール側の遷移用インターフェースの定義&lt;/h2&gt;

&lt;p&gt;前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。&lt;/p&gt;

&lt;p&gt;main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainModuleRouter {
  // sub1画面へ移動する
  fun routeToSub1()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mainモジュール用のインターフェースなので、&lt;code&gt;MainModuleRouter&lt;/code&gt;という名前にし、sub1画面へ遷移するためのメソッドを定義しています。&lt;/p&gt;

&lt;p&gt;そしてこのインターフェースを、MainFragmentで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment : Fragment() {
  @Inject lateinit var moduleRouter: MainModuleRouter

  ...

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    view.findViewById&amp;lt;View&amp;gt;(R.id.route).setOnClickListener {
      moduleRouter.routeToSub1()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでfeatureモジュールでの遷移用インターフェースの定義は完了です。&lt;/p&gt;

&lt;p&gt;次にこのインターフェースの実装をします。&lt;/p&gt;

&lt;h2 id=&#34;routerモジュール側の遷移用インターフェースの実装&#34;&gt;routerモジュール側の遷移用インターフェースの実装&lt;/h2&gt;

&lt;p&gt;今回は、遷移用インタフェースの実装をrouterモジュールで行います。まずは、Navigation Componentを用いて、Graphを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
  android:id=&amp;quot;@+id/nav_graph&amp;quot;
  app:startDestination=&amp;quot;@id/nav_main_frag&amp;quot;&amp;gt;

  &amp;lt;fragment
    android:id=&amp;quot;@+id/nav_main_frag&amp;quot;
    android:name=&amp;quot;com.github.satoshun.example.feature.main.MainFragment&amp;quot;&amp;gt;

    &amp;lt;action
      android:id=&amp;quot;@+id/main_to_sub1&amp;quot;
      app:destination=&amp;quot;@id/nav_sub1_frag&amp;quot; /&amp;gt;
  &amp;lt;/fragment&amp;gt;

  ...
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、これを用いて遷移用インターフェースを実装します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainModuleRouterImpl @Inject constructor(
  private val controller: NavController
) : MainModuleRouter {
  override fun routeToSub1() {
    // NavComponentで自動生成されるコードを用いて遷移
    controller.navigate(MainFragmentDirections.mainToSub1())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実装は完了です。Navigation Componentを使っているため、実装はかなり楽です。&lt;/p&gt;

&lt;p&gt;あとはDaggerで配るだけです。Daggerで配る部分はサンプルコードを見ていただけたらと思います。サンプルでは、Dagger Androidを用いています。&lt;/p&gt;

&lt;h2 id=&#34;メモ&#34;&gt;メモ&lt;/h2&gt;

&lt;h3 id=&#34;routerモジュールをわざわざ作る必要はないかも&#34;&gt;routerモジュールをわざわざ作る必要はないかも&lt;/h3&gt;

&lt;p&gt;構成図を見てほしいのですが、実はrouterモジュールをわざわざ作る必要はなく、appモジュールに含めても良いです。routerモジュールを作るのがめんどう、もしくは意味がないと感じるなら、appモジュールで実装しても良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Navigation Componentでモジュール間の遷移を宣言的にXMLで書けるのは見やすくて非常に良いと思いました。

&lt;ul&gt;
&lt;li&gt;またNavigation Componentはactivityの記述もできるので、既存アプリへの導入も比較的しやすいと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;app/routerでは各featureモジュールへの依存を持つことができるので、クラスへの参照を持ちながら、navgationのgraphを作ることができる

&lt;ul&gt;
&lt;li&gt;navigation graphはActivity/Fragmentへの参照を持たなくても作ることが可能だが、持ったほうがLintなどの兼ね合いで安全&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次は最終章になる予定です。DFMの遷移について書きます😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>

&lt;p&gt;マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）&lt;/p&gt;

&lt;p&gt;例えば、以下のモジュール構成を考えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0mYXQcxO-RfvcY4rbSMcI8QPI8nnAZRYuk81cA-Ycv9VdwTf1TAC90DKufEQb0Bq40000&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0miXQGGPEcunDOMPnQHAA9KrR7pTFCyIc5AZI45Ef4GwbHbnSN41NAEYcv9VdwTf1BE82aN0Xi87e8a1z3gbvAS000G00&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。&lt;/p&gt;

&lt;p&gt;ただし、いくつか条件があります。&lt;/p&gt;

&lt;h3 id=&#34;1-中間モジュールで公開可能なものに限る&#34;&gt;1. 中間モジュールで公開可能なものに限る&lt;/h3&gt;

&lt;p&gt;例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。
これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。&lt;/p&gt;

&lt;p&gt;中間モジュールのコードイメージとしては以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun createUserFragment(userName: String, age: Int): Fragment {
  return UserFragment.createFragment(userName, age)
}

fun createUserIntent(context: Context): Intent {
  return Intent(context, UserActivity::class.java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserActivity、UserFragmentが公開されていないことが分かります。Androidのいわゆるfeatureモジュールでは、Activity、Fragmentを公開する場合が多いと思うので、その場合には有効に使うことができます。&lt;/p&gt;

&lt;h3 id=&#34;2-implementationで依存を定義する&#34;&gt;2. implementationで依存を定義する&lt;/h3&gt;

&lt;p&gt;apiを使うと、依存が推移するため再ビルドが行われてしまうためです。implementationで依存を記述する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;3-dagger2使ってると多分無理&#34;&gt;3. Dagger2使ってると多分無理&lt;/h3&gt;

&lt;p&gt;Dagger2では、解決する依存をAppComponentで知っている必要があります。上記の構成だと、appでAppComponentを持つことになるので、appからsub1、sub2が見えていないと最終的にDagger2で解決できません。なので、中間モジュールで、appからsubの依存が見えなくなるこのパターンは使えません。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://github.com/google/dagger/issues/970&#34;&gt;Dagger/#970&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;やりすぎ感はある

&lt;ul&gt;
&lt;li&gt;ただでさえ複雑な、モジュール構成がさらに煩雑になりそう。ただし、最終的には消えるので、差分ビルドの恩恵を受けるためのステップだとすれば許せるかも?&lt;/li&gt;
&lt;li&gt;Dagger2を使っていると推移的依存が必要になり、使えない、もしくは工夫が必要になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルは&lt;a href=&#34;https://github.com/satoshun-android-example/ApplicationModulesSpeedUpExample&#34;&gt;satoshun/ApplicationModulesSpeedUpExample&lt;/a&gt;にあります

&lt;ul&gt;
&lt;li&gt;サブモジュールを変更したときのビルドは爆速でした😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Daggerの部分のいい解決方法を知っている人がいたら、教えて頂けると幸いです😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>DroidKaigi2019で「R8/ProGuard 徹底比較」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2019/02/droidkaigi-2019/</link>
      <pubDate>Thu, 07 Feb 2019 13:19:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/droidkaigi-2019/</guid>
      <description>&lt;p&gt;DroidKaigi2019でセッションが採択されたので発表しました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;b801b49e61ef4c478e6020941393b9ed&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao&#34;&gt;https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最初に発表の反省点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多く詰め込みすぎて、1つ1つの掘り下げが疎かになった

&lt;ul&gt;
&lt;li&gt;結果的に広く浅い発表になってしまったため、1つの1つがあまり丁寧に説明できていなかったように感じています。重要な部分はもう少し丁寧に発表すべきでした。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;早口すぎ、俺は生き急いでるのか？

&lt;ul&gt;
&lt;li&gt;本当に申し訳ありませんでした。前日に最終確認したところ20分近くオーバーしてしまい、そこからある程度は間引いたんですが、早口でいくという戦略を取ってしまいました😂 他の方の発表のように聞きやすい発表を今後は意識していきます！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;次に良かった点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;発表前の休憩時間に、司会の@neonankitiさんの助けで、アイスブレイク?のようなことができた

&lt;ul&gt;
&lt;li&gt;@neonankitiさんとは初対面だったんですが、謎の掛け合いができ、会場の雰囲気も良くなったように思います😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;なんだかんだとR8のコードを触れたのは良かった

&lt;ul&gt;
&lt;li&gt;R8コンパイラのコードに触れるかどうか悩んだのですが、printデバッグなどを駆使して、理解が間違っていないことが確認できたので、載せてみました。概要だけですが、個人的には良かったと思っています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最後に話した実践編のウケが良くてよかった

&lt;ul&gt;
&lt;li&gt;R8の凄さが分かりやすく伝えられたのかなと思います😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;最後に、僕の発表を聞きに来てくれた人、運営のみなさんありがとうございました😊&lt;/p&gt;

&lt;p&gt;また来年もあれば登壇できるように頑張ります💪&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bit.ly/2UQggVj&#34; alt=&#34;DroidKaigi2019&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: JarファイルからProGuard設定ファイルを読み込んでくれるようになりました</title>
      <link>https://satoshun.github.io/2019/01/r8-proguard-metainf/</link>
      <pubDate>Mon, 28 Jan 2019 00:08:35 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-proguard-metainf/</guid>
      <description>

&lt;p&gt;&lt;del&gt;AGP3.3.0&lt;/del&gt;ProGuardはAGP3.3.0、R8は導入されたAGP3.2.0から、JarファイルのProGuard設定ファイルを組み込めるようになりました。その機能紹介です。
今まで、aarでは&lt;code&gt;consumerProguardFiles&lt;/code&gt;で、ライブラリのProGuard設定を指定できました。それのJar、Javaバージョンとなります。&lt;/p&gt;

&lt;h2 id=&#34;ライブラリ開発者側の設定&#34;&gt;ライブラリ開発者側の設定&lt;/h2&gt;

&lt;p&gt;RetrofitなどのSquare社のライブラリでは、早くもこの機能に対応しているので、それを例にして説明します。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;resources/META-INF/prougard&lt;/code&gt;ディレクトリの中にProGuardの設定ファイルを置きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/tree/master/retrofit/src/main/resources/META-INF/proguard&#34;&gt;square/retrofit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライブラリ側の設定はこれで完了です。&lt;/p&gt;

&lt;h2 id=&#34;使う側の設定&#34;&gt;使う側の設定&lt;/h2&gt;

&lt;p&gt;AGP3.3.0にアップデートするだけで使えます。META-INF/ProGuardはRetrofitの2.5.0から入っているので、まずはMETA-INFが入っていない、2.4.0でビルドをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.4.0&amp;quot;

&amp;gt; ./gradlew installRelease
...
Warning: there were 267 unresolved references to classes or interfaces.
         You may need to add missing library jars or update their versions.
         If your code works fine without the missing classes, you can suppress
         the warnings with &#39;-dontwarn&#39; options.
         (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedclass)
Warning: Exception while processing task java.io.IOException: Please correct the above warnings first.
Thread(Tasks limiter_2): destruction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;失敗しました😂&lt;/p&gt;

&lt;p&gt;次にMETA-INFが入った2.5.0でビルドをします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.5.0&amp;quot;

&amp;gt; ./gradlew installRelease
...

BUILD SUCCESSFUL in 21s
38 actionable tasks: 18 executed, 20 from cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功しました😊&lt;/p&gt;

&lt;p&gt;META-INFファイルをちゃんと読み込めているようです。ProGuardのconfigurationファイルを確認したところ、RetrofitのProGuard設定が入っていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// configuration.txt
...
# Retain service method parameters when optimizing.
-keepclassmembers,allowshrinking,allowobfuscation interface  * {
    @retrofit2.http.*
    &amp;lt;methods&amp;gt;;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;この機能はR8/ProGuard、両方とも対応しているようです。&lt;/p&gt;

&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;

&lt;p&gt;最初、冒頭でR8もAGP3.3.0からと書いたんですが、それは誤りで、AGP3.2.0のR8が導入されたタイミングでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kafumi__/status/1089816485386747905&#34;&gt;@kafumi__&lt;/a&gt;さんにご指摘いただきました！ありがとうございます😊&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ライブラリがJarであったとしても、ライブラリ作者が対応してくれればProGuardの設定が楽になる!!!

&lt;ul&gt;
&lt;li&gt;現状、有名なライブラリでは、OkHttp、Retrofit、Coroutineなどが対応しています😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;この機能がProGuardでも使えるのを知らなかったので、公式ドキュメントなどのリンクを知っている方がいれば教えてほしいです🙏🙏🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>

&lt;p&gt;FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。&lt;/p&gt;

&lt;p&gt;結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂&lt;/p&gt;

&lt;p&gt;また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。&lt;/p&gt;

&lt;h2 id=&#34;room-in-memory&#34;&gt;Room in memory?&lt;/h2&gt;

&lt;p&gt;Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。&lt;/p&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Room
  .inMemoryDatabaseBuilder(context, MyDatabase::class.java)
  .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in memoryを使う理由としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ディスパッチするアクションを永続化する必要はないだろう&lt;/li&gt;
&lt;li&gt;マイグレーションが必要ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;実装に入っていく&#34;&gt;実装に入っていく&lt;/h2&gt;

&lt;p&gt;では、実装の説明をしていきます。&lt;/p&gt;

&lt;p&gt;まずはActionをRoomのEntityとして定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sealed class AuthorAction

@Entity(tableName = &amp;quot;author1&amp;quot;)
data class Author1(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()

@Entity(tableName = &amp;quot;author2&amp;quot;)
data class Author2(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、&lt;code&gt;@PrimaryKey(autoGenerate = true)&lt;/code&gt;を使っても良いと思います。&lt;/p&gt;

&lt;p&gt;次にDaoを定義します。これはFluxでいうところのDispatcherになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Dao
interface AuthorDispatcher {
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author1)
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author2)

  // Storeに相当する
  @Query(&amp;quot;select * FROM author1 WHERE _id = 0&amp;quot;)
  fun author(): LiveData&amp;lt;Author1?&amp;gt;

  // Storeに相当する
  @Query(
    &amp;quot;&amp;quot;&amp;quot;
    select author1.name as name1, author2.name as name2
    FROM author1
     INNER JOIN author2
    WHERE author1._id = 0 AND author2._id = 0
    &amp;quot;&amp;quot;&amp;quot;
  )
  fun mappedAuthor(): LiveData&amp;lt;MappedAuthor?&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;code&gt;@Insert&lt;/code&gt;でアクションをdispatchメソッドを、&lt;code&gt;@Query&lt;/code&gt;でsubscribeメソッドを実装しています。&lt;/p&gt;

&lt;p&gt;これで、FluxのDispatcherに似た何かをRoomで表現することが出来ます！&lt;/p&gt;

&lt;h2 id=&#34;まとめ-考察&#34;&gt;まとめ/考察&lt;/h2&gt;

&lt;p&gt;RoomでDispatcher的なのを作る方法と、EventBusなどを使ったアプローチの違いは以下になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Storeに書いていたロジックをSQLに任せることが出来る

&lt;ul&gt;
&lt;li&gt;Transactionを上手く使えば、マルチスレッド環境でもそれっぽく動きそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ほげほげDispactherクラスがアプリ内に蔓延する&lt;/li&gt;
&lt;li&gt;コードが冗長😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工夫すれば、もう少しキレイに書けるとは思いますが、ただEventBusや、Coroutineを使ったアプローチには敵わないと思っています。
FluxのDispatcherの代替としては辛いですが、他の用途、例えばRepositoryの実装などには使える余地があると思うので、そういったところで思い出していただけたら幸いです😊&lt;/p&gt;

&lt;p&gt;検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/RoomDispatcherExample&#34;&gt;RoomDispatcherExample&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Daggerの生成コードがR8でどのように変わるかを見る</title>
      <link>https://satoshun.github.io/2019/01/r8-dagger-optimize/</link>
      <pubDate>Sun, 20 Jan 2019 13:55:46 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-dagger-optimize/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事では実践に寄せて、Daggerの生成コードがR8によってどのように変化するかを見ます。&lt;/p&gt;

&lt;p&gt;まずはサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(
  modules = [
    AppModule1::class,
    AppModule2::class
  ]
)
interface AppComponent {
  @Component.Builder
  interface Builder {
    fun build(): AppComponent
  }

  fun inject(activity: MainActivity)
}

@Module
class AppModule1 {
  @Provides
  fun provideService(): AppService {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

@Module
object AppModule2 {
  @JvmStatic
  @Provides
  fun provideService2(): AppService2 {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

---

class MainActivity : AppCompatActivity() {
  @Inject lateinit var appService: AppService
  @Inject lateinit var appService2: AppService2

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val appComponent = DaggerAppComponent.builder().build()
    appComponent.inject(this)

    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンプルなAppComponentを定義して、そこにAppModule1とAppModule2を紐づけています。それを、MainActivityで使うコードになっています。&lt;/p&gt;

&lt;p&gt;これを最適化なしでdex変換して、デコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends AppCompatActivity {
    @Inject
    @NotNull
    public AppService appService;
    @Inject
    @NotNull
    public AppService2 appService2;

    ...

    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        DaggerAppComponent.builder().build().inject(this);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通のコードです。KotlinをJava変換しただけなので、特におかしな部分もありません。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends m {
    public AppService o;
    public AppService2 p;
    ...

    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView((int) R.layout.activity_main);
        Object a = new AppModule1().a();
        a.a(a, &amp;quot;Cannot return null from a non-@Nullable @Provides method&amp;quot;);
        this.o = a;
        this.p = AppModule2_ProvideService2Factory.a();
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何ということでしょう。&lt;code&gt;DaggerAppComponent&lt;/code&gt;が消えました！&lt;/p&gt;

&lt;p&gt;DaggerAppComponentの各メソッドがMainActivity側にインライン展開されることで、完全にDaggerAppComponentを消すことが出来ます。
実際にapkの中身を見て、DaggerAppComponentクラスが存在しないことを確認しました。R8すごい😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Proguardだと、デフォルトのだと上記のサンプルから、&lt;code&gt;DaggerAppComponent&lt;/code&gt;を消すことが出来ませんでした。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8すごい😃😃😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。&lt;/p&gt;

&lt;h2 id=&#34;kotlin-lambda&#34;&gt;Kotlin lambda&lt;/h2&gt;

&lt;p&gt;Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。&lt;/p&gt;

&lt;p&gt;例えば、次のコードを最適化なしでコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun main() {
    lambdaTest1 { println(&amp;quot;Kotlin lambda1&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda2&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda3&amp;quot;) }
    ...
}

private fun lambdaTest1(body: () -&amp;gt; Unit) {
    ...
    body()
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// コンパイル後
public static final void main() {
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE);
    ...
}

final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1();

    LambdaTestKt$main$1() {
        super(0);
    }

    public final void invoke() {
        System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
    }
}

final class LambdaTestKt$main$2 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
final class LambdaTestKt$main$3 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LambdaTestKt$main$1&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt;、&lt;code&gt;$3&lt;/code&gt;が生成されていることが分かります。ラムダを使う箇所を増やすと$2、$3&amp;hellip;とクラスが増えていきます。&lt;/p&gt;

&lt;p&gt;この問題に対し、R8ではLambdaGroupというテクニックを使い最適化をします。&lt;/p&gt;

&lt;p&gt;R8を使って、上記のコードをコンパイルすると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final void main() {
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$0);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$1);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$2);
    ...
}

public final class -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI extends Lambda implements Function0 {
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$0 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(0);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$1 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(1);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$2 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(2);
    public final /* synthetic */ int $id$;

    public -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(int i) {
        this.$id$ = i;
        super(0);
    }

    public final Object invoke() {
        int i = this.$id$;
        if (i == 0) {
            System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 1) {
            System.out.println(&amp;quot;Kotlin lambda2&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 2) {
            System.out.println(&amp;quot;Kotlin lambda3&amp;quot;);
            return Unit.INSTANCE;
        } else {
            throw null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化しない場合では、それぞれのラムダに対して、専用のクラスが1つずつ定義されていました。最適化された後では1つのクラス、LambadGroupにまとまっていることが分かります。
このクラスでは、それぞれのラムダインスタンスにidを持たせることで、どのラムダかを分類することが出来ます。&lt;/p&gt;

&lt;p&gt;この最適化により、クラス数、メソッド数を抑えることが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。&lt;/p&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;https://jakewharton.com/r8-optimization-staticization/&#34;&gt;R8 Optimization: Staticization&lt;/a&gt;にとても影響を受けています。&lt;/p&gt;

&lt;h2 id=&#34;companion-object&#34;&gt;Companion object&lt;/h2&gt;

&lt;p&gt;例えば、次のコードがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CompanionTest {
    companion object {
        fun show(i: Int) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを最適化なしで変換すると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class CompanionTest {
    public static final Companion Companion = new Companion();

    public static final class Companion {
        private Companion() {
        }

        public final void show(int i) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。&lt;/p&gt;

&lt;p&gt;そこでR8による最適化を行うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class CompanionTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無駄な内部クラス（enclosing class）が消えて、staticメソッドに変換されているのが分かります。このshowメソッドはわざわざインスタンスメソッドにする必要がないため、このような最適化が行われます。&lt;/p&gt;

&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;

&lt;p&gt;objectも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object ObjectTest {
    fun show(i: Int) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化なしだと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ObjectTest {
    public static final ObjectTest INSTANCE = new ObjectTest();

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INSTANCEフィールドが生成されていることが分かります。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class ObjectTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companion objectと同様に冗長なインスタンス生成が消えています。
Proguardの場合、インスタンス生成は消えないので、R8の一歩進んだ最適化といえます。（もしかしたらProguardの設定次第でインスタンス生成をしないように出来るかもしれないです。）&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではClass Mergingについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;class-merging&#34;&gt;Class Merging?&lt;/h2&gt;

&lt;p&gt;その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。
Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。&lt;/p&gt;

&lt;p&gt;まずは縦方向のClass Mergingについて説明します。&lt;/p&gt;

&lt;h3 id=&#34;縦方向&#34;&gt;縦方向?&lt;/h3&gt;

&lt;p&gt;縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。&lt;/p&gt;

&lt;p&gt;例えば、次の実装は最適化によって1つにまとめられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface IVertical {
    fun show(i: Int)
}

class Vertical(
    private val a: Int
) : IVertical {
    override fun show(i: Int) {
        println(&amp;quot;start called $i $a&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Vertical {
    ...

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IVertical&lt;/code&gt;インターフェースが見事に消されていることが分かります。&lt;/p&gt;

&lt;p&gt;また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r8.googlesource.com/r8/+/master/src/main/java/com/android/tools/r8/shaking/VerticalClassMerger.java&#34;&gt;R8: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/proguard/blob/master/src/proguard/optimize/peephole/VerticalClassMerger.java&#34;&gt;Proguard: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に横方向のマージを紹介します。&lt;/p&gt;

&lt;h3 id=&#34;横方向&#34;&gt;横方向?&lt;/h3&gt;

&lt;p&gt;Staticメソッドのみを持つクラスを1つにまとめるなどの最適化を行います。&lt;/p&gt;

&lt;p&gt;例えばKotlinの複数のファイルで定義されたトップレベル関数を1つのクラスにまとめてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ShowExt.kt
fun Int.show1(i: Int) {
    ...
}

// ShowExt2.kt
fun Int.show2(i: Int) {
    ...
}

--&amp;gt; Proguard/R8による最適化後 --&amp;gt;

```java
public class ShowExt2Kt {
    public static final void show1(int i) {
        ...
    }
}

    public static final void show2(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つのクラスにまとめられていることが分かります。&lt;/p&gt;

&lt;p&gt;また、実際のAndroidプロジェクトで確認したところ、確かに拡張関数が他のクラスにマージされていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fuga.kt
fun Int.show1() {
    ...
}

// mapping.txtの内容
android.support.constraint.solver.widgets.Analyzer -&amp;gt; a.b.b.a.a.a:
    ...
    void com.github.satoshun.example.FugaKt.show1(int) -&amp;gt; d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこのクラスに移動したかは分からないので、今後の宿題とします。申し訳ありません😫&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;横方向のマージについては内容に自信がないので、もし間違っていたり、補足があれば教えて頂けるととても嬉しいです🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://medium.com/@keyboardsurfer/dependency-injection-in-a-multi-module-project-1a09511c14b7&#34;&gt;Dependency injection in a multi module project&lt;/a&gt;を見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。&lt;/p&gt;

&lt;p&gt;結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。&lt;/p&gt;

&lt;p&gt;また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。&lt;/p&gt;

&lt;p&gt;検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;satoshun-android-example/DynamicFeatureDaggerExample&lt;/a&gt;にあります😊&lt;/p&gt;

&lt;h2 id=&#34;前提知識&#34;&gt;前提知識&lt;/h2&gt;

&lt;p&gt;通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。
ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLukc_oixbB7pUkUx9lxjErCvxEtip5bPoVMv2VbvfNeX2TM53mk7dHuwOTZvkNFcxUyxXvTQn2Oh42K1XPrUEchO-RfnbYKrbSccI8gTG8Xr8ZBYukeDaAkYdvvNcwTX3TQ090DGwfUIb0Fm00&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLmgSnBpCrCLd1BJImfBKfztBZkoRwvJzVEU3fxCnTNSdvkGNvUQbw9GdHYGS7ZvaMFctOyRbxwk7dFu-RLiGg9nGf0OMHLZvksFcwUPeXDPN5faY6cKYCSIesukBX0EXHqK_BBytJjm1Q1n544k1nIyrA0dW40&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。&lt;/p&gt;

&lt;p&gt;ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。
実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。&lt;/p&gt;

&lt;p&gt;では、実装を始めます。&lt;/p&gt;

&lt;p&gt;最初に、SubActivityをDaggerApplicationのように振る舞わさせるために&lt;code&gt;ModuleRootActivity&lt;/code&gt;クラスを定義します。
それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ModuleRootActivity : AppCompatActivity(),
  HasModuleInjector {
  @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt;

  private lateinit var injector: ModuleActivityInjector

  override fun onCreate(savedInstanceState: Bundle?) {
    injector = moduleComponent.moduleInjector
    injector.activity.inject(this)
    super.onCreate(savedInstanceState)
  }

  protected abstract val moduleComponent: ModuleActivityComponent

  override fun supportFragmentInjector(): AndroidInjector&amp;lt;Fragment&amp;gt; =
    fragmentInjector
}

class ModuleActivityInjector @Inject constructor(
  internal val activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
)

interface ModuleActivityComponent {
  val moduleInjector: ModuleActivityInjector
}

interface HasModuleInjector : HasSupportFragmentInjector

abstract class ModuleChildFragment : Fragment() {
  override fun onAttach(context: Context) {
    AndroidSupportInjection.inject(this)
    super.onAttach(context)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、このbaseクラス群を使い、SubActivityとDagger Componentを実装をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ModuleScope
@Component(
  dependencies = [CoreComponent::class], // 共通で使うComponent
  modules = [
    AndroidSupportInjectionModule::class,
    SubBuilder::class
  ]
)
internal interface SubComponent : ModuleActivityComponent {
  @Component.Builder
  interface Builder {
    fun appComponent(module: CoreComponent): Builder
    fun build(): Sub1Component
  }
}

@Module(
  includes = [SubActivityModule::class]
)
interface SubBuilder

@Module
internal interface SubActivityModule {
  @ContributesAndroidInjector(modules = [SubFragmentsModule::class])
  fun contributeSubActivity(): SubActivity
}

@Module
internal interface SubFragmentsModule {
  @ContributesAndroidInjector
  fun contributeSubFragment(): SubFragment
}

class SubActivity : ModuleRootActivity() {
  @Inject lateinit var ...

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)
    ...
  }

  override val moduleComponent: ModuleActivityComponent
    get() = DaggerSubComponent
      .builder()
      .appComponent(App.coreComponent())
      .build()
}

class SubFragment : ModuleChildFragment() {
  @Inject lateinit var ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ModuleRootActivity&lt;/code&gt;で、Featureモジュール内で使うComponentを保持し、各Fragmentで保持したComponentを参照することで、ActivityをDaggerApplicationのように振る舞わさせる事ができます。ComponentやModuleの定義は従来のDagger Androidの書き方とほぼ一緒です。&lt;/p&gt;

&lt;p&gt;これで、Dynamic Featureモジュール + Dagger Androidを実現することが出来ます😃&lt;/p&gt;

&lt;p&gt;細かい部分はサンプルを見ていただけたらと思います。&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;DynamicFeatureDaggerExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;メモ1-1つのfeature-module内で複数activityがある場合&#34;&gt;メモ1: 1つのFeature Module内で複数Activityがある場合&lt;/h2&gt;

&lt;p&gt;このパターンは考慮出来ていないです😂
おそらく、頑張ってApplicationクラス内でstaticで保持するか、もしくは、CoreComponentでScopedで管理するのが良いと思っています。&lt;/p&gt;

&lt;h2 id=&#34;メモ2-configuration-change対応&#34;&gt;メモ2: Configuration Change対応&lt;/h2&gt;

&lt;p&gt;Feature Root ComponentはActivityではなく、AACのViewModelで保持したほうが良いかも知れないです。&lt;/p&gt;

&lt;h2 id=&#34;メモ3-そもそもdagger-androidを使う必要あるのか&#34;&gt;メモ3: そもそもDagger Androidを使う必要あるのか?&lt;/h2&gt;

&lt;p&gt;Scopeをガンガン使いたい時、すでにDagger Androidを導入している場合は使ってもいいかも。
ただPlaidのように、Dagger Androidを使わないほうがコードが複雑にならなそうなので、使わないほうが基本良いと思います。（今後心変わりする可能性は大いにあります）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、Happy Dagger Life 😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>dexdumpメモ</title>
      <link>https://satoshun.github.io/2019/01/reading_dexdump_result/</link>
      <pubDate>Sat, 05 Jan 2019 02:15:50 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/reading_dexdump_result/</guid>
      <description>&lt;p&gt;Android build-toolsにはdexdumpというdexファイルを逆アセンブルするツールがあります。
逆アセンブルしたファイルを読みたかったのでそれのメモです。&lt;/p&gt;

&lt;p&gt;内容はまとまっていません。自分用のメモレベルの記事になります。&lt;/p&gt;

&lt;p&gt;dexファイルをコマンドから作るにはjavacとd8コマンドを使います。d8コマンドは &lt;a href=&#34;https://r8.googlesource.com/r8&#34;&gt;https://r8.googlesource.com/r8&lt;/a&gt; の手順通りにビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javac *.java // or kotlinc *.kt
java -jar $R8_HOME/build/libs/d8.jar --lib $ANDROID_HOME/platforms/android-28/android.jar --release *.class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d8コマンドで出来たdexファイルをdexdumpで逆アセンブルします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば次のJavaコードを逆アセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Test {
    public void main() {
        show(1, 10.0);
        String[] array = {&amp;quot;&amp;quot;};
        toggle(array);
        fade();
        drag();
        hide();
        click();
        hover();
    }

    public String show(int a, double d) {
        System.out.println(a);
        return &amp;quot;showed&amp;quot;;
    }

    void toggle(String[] args) {
        System.out.println(&amp;quot;toggle&amp;quot;);
    }

    protected void fade() {
        System.out.println(&amp;quot;fade&amp;quot;);
    }

    final protected void drag() {
        System.out.println(&amp;quot;drag&amp;quot;);
    }

    private void hide() {
        System.out.println(&amp;quot;hide&amp;quot;);
    }

    public static void click() {
        System.out.println(&amp;quot;click&amp;quot;);
    }

    static void hover() {
        System.out.println(&amp;quot;hover&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Processing &#39;classes.dex&#39;...
Opened &#39;classes.dex&#39;, DEX version &#39;035&#39;
Class #0            -
  Class descriptor  : &#39;LTest;&#39; // クラス名Test
  Access flags      : 0x0000 () // パッケージプライベート
  Superclass        : &#39;Ljava/lang/Object;&#39; // スーパークラスがObject
  Interfaces        - // インターフェースを持たない
  Static fields     - // Staticフィールドを持たない
  Instance fields   - // インスタンスフィールドを持たない
  Direct methods    -
    #0              : (in LTest;)
      name          : &#39;&amp;lt;init&amp;gt;&#39; // コンストラクタを示す
      type          : &#39;()V&#39; // 引数なし/戻り値なし
      access        : 0x10000 (CONSTRUCTOR)
      code          -
      registers     : 1
      ins           : 1
      outs          : 1
      insns size    : 4 16-bit code units
0001e4:                                        |[0001e4] Test.&amp;lt;init&amp;gt;:()V
0001f4: 7010 0b00 0000                         |0000: invoke-direct {v0}, Ljava/lang/Object;.&amp;lt;init&amp;gt;:()V // method@000b // Objectのsuper
0001fa: 0e00                                   |0003: return-void
      catches       : (none)
      positions     :
        0x0000 line=1
      locals        :
        0x0000 - 0x0004 reg=0 this LTest;

    #1              : (in LTest;)
      name          : &#39;click&#39;
      type          : &#39;()V&#39;
      access        : 0x0009 (PUBLIC STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
0001fc:                                        |[0001fc] Test.click:()V
00020c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000210: 1a01 0f00                              |0002: const-string v1, &amp;quot;click&amp;quot; // string@000f
000214: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00021a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=35
      locals        :

    #2              : (in LTest;)
      name          : &#39;hide&#39;
      type          : &#39;()V&#39;
      access        : 0x0002 (PRIVATE)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00025c:                                        |[00025c] Test.hide:()V
00026c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000270: 1a01 1200                              |0002: const-string v1, &amp;quot;hide&amp;quot; // string@0012
000274: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00027a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=31
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #3              : (in LTest;)
      name          : &#39;hover&#39;
      type          : &#39;()V&#39;
      access        : 0x0008 (STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
00027c:                                        |[00027c] Test.hover:()V
00028c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000290: 1a01 1300                              |0002: const-string v1, &amp;quot;hover&amp;quot; // string@0013
000294: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00029a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=39
      locals        :

  Virtual methods   -
    #0              : (in LTest;)
      name          : &#39;drag&#39;
      type          : &#39;()V&#39;
      access        : 0x0014 (PROTECTED FINAL)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00021c:                                        |[00021c] Test.drag:()V
00022c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000230: 1a01 1000                              |0002: const-string v1, &amp;quot;drag&amp;quot; // string@0010
000234: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00023a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=27
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #1              : (in LTest;)
      name          : &#39;fade&#39;
      type          : &#39;()V&#39;
      access        : 0x0004 (PROTECTED)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00023c:                                        |[00023c] Test.fade:()V
00024c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000250: 1a01 1100                              |0002: const-string v1, &amp;quot;fade&amp;quot; // string@0011
000254: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00025a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=23
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #2              : (in LTest;)
      name          : &#39;main&#39;
      type          : &#39;()V&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 1
      outs          : 4
      insns size    : 32 16-bit code units
00029c:                                        |[00029c] Test.main:()V
0002ac: 1210                                   |0000: const/4 v0, #int 1 // #1
0002ae: 1901 2440                              |0001: const-wide/high16 v1, #long 4621819117588971520 // #4024
0002b2: 6e40 0700 0321                         |0003: invoke-virtual {v3, v0, v1, v2}, LTest;.show:(ID)Ljava/lang/String; // method@0007
0002b8: 2300 0800                              |0006: new-array v0, v0, [Ljava/lang/String; // type@0008
0002bc: 1201                                   |0008: const/4 v1, #int 0 // #0
0002be: 1a02 0000                              |0009: const-string v2, &amp;quot;&amp;quot; // string@0000
0002c2: 4d02 0001                              |000b: aput-object v2, v0, v1
0002c6: 6e20 0800 0300                         |000d: invoke-virtual {v3, v0}, LTest;.toggle:([Ljava/lang/String;)V // method@0008
0002cc: 6e10 0300 0300                         |0010: invoke-virtual {v3}, LTest;.fade:()V // method@0003
0002d2: 6e10 0200 0300                         |0013: invoke-virtual {v3}, LTest;.drag:()V // method@0002
0002d8: 7010 0400 0300                         |0016: invoke-direct {v3}, LTest;.hide:()V // method@0004
0002de: 7100 0100 0000                         |0019: invoke-static {}, LTest;.click:()V // method@0001
0002e4: 7100 0500 0000                         |001c: invoke-static {}, LTest;.hover:()V // method@0005
0002ea: 0e00                                   |001f: return-void
      catches       : (none)
      positions     :
        0x0003 line=3
        0x0006 line=4
        0x000d line=5
        0x0010 line=6
        0x0013 line=7
        0x0016 line=8
        0x0019 line=9
        0x001c line=10
      locals        :
        0x0000 - 0x0020 reg=3 this LTest;

    #3              : (in LTest;)
      name          : &#39;show&#39;
      type          : &#39;(ID)Ljava/lang/String;&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 4
      outs          : 2
      insns size    : 8 16-bit code units
0001c4:                                        |[0001c4] Test.show:(ID)Ljava/lang/String;
0001d4: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
0001d8: 6e20 0900 1200                         |0002: invoke-virtual {v2, v1}, Ljava/io/PrintStream;.println:(I)V // method@0009
0001de: 1a01 1800                              |0005: const-string v1, &amp;quot;showed&amp;quot; // string@0018
0001e2: 1101                                   |0007: return-object v1
      catches       : (none)
      positions     :
        0x0000 line=14
      locals        :
        0x0000 - 0x0008 reg=0 this LTest;

    #4              : (in LTest;)
      name          : &#39;toggle&#39;
      type          : &#39;([Ljava/lang/String;)V&#39;
      access        : 0x0000 ()
      code          -
      registers     : 3
      ins           : 2
      outs          : 2
      insns size    : 8 16-bit code units
0002ec:                                        |[0002ec] Test.toggle:([Ljava/lang/String;)V
0002fc: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000300: 1a00 1900                              |0002: const-string v0, &amp;quot;toggle&amp;quot; // string@0019
000304: 6e20 0a00 0200                         |0004: invoke-virtual {v2, v0}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00030a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=19
      locals        :
        0x0000 - 0x0008 reg=1 this LTest;

  source_file_idx   : 10 (Test.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;finalメソッドのdragがvirtualなのがなぜなのかわからない

&lt;ul&gt;
&lt;li&gt;finalはdirectメソッドなのでは?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>

&lt;p&gt;Androidのトレンドの1つにマルチモジュール構成があります。
マルチモジュールによるメリットとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビルド時間の短縮&lt;/li&gt;
&lt;li&gt;依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。&lt;/p&gt;

&lt;p&gt;この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい&lt;/li&gt;
&lt;li&gt;コード量を減らしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part1では、遷移専用のモジュールを作る方法を考えてみます。&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;遷移専用のモジュールを作る&#34;&gt;遷移専用のモジュールを作る&lt;/h2&gt;

&lt;p&gt;まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。&lt;/p&gt;

&lt;p&gt;例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メインではサブ画面が必要なのでサブモジュールに依存する&lt;/li&gt;
&lt;li&gt;サブではメイン画面が必要なのでメインモジュールに依存する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwecY1CaGcBmH5nSNa5BGBSfCpoZHjOE8WGW5tPpKDAW85vT3QbuAq6K0&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。
直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。&lt;/p&gt;

&lt;p&gt;そこで、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メイン画面に遷移するメインルーターモジュール&lt;/li&gt;
&lt;li&gt;サブ画面に遷移するサブルーターモジュール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのモジュールを作ります。&lt;/p&gt;

&lt;p&gt;メインルーターモジュールでは次の遷移専用インターフェースを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainRouter {
  fun routeToMain(context: Context): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;internal class MainRouterImpl @Inject constructor() : MainRouter {
  override fun routeToMain(context: Context): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---

@Module
internal interface MainActivityModule {
  @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SubActivity : AppCompatActivity() {
  @Inject lateinit var router: MainRouter

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な依存図は次のようになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwebLoUFcrO-RzpnksWyaOGgDKLGYMGTJO8If09iv9bnSN41AGRUqGBV63c8oZ6y7LG0o3Kc12K80ge7B8JKl1HWG0000&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで、相互に遷移する画面だとしても循環参照になることなく解決することが出来ます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;いちいちルーターモジュールを作るのがめんどうなのであれば、共通のRouterインターフェースを作る方法もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Router&amp;lt;T&amp;gt; {
  fun route(context: Context, params: T): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;---実装

internal class MainRouter2Impl @Inject constructor() : Router&amp;lt;Unit&amp;gt; {
  override fun route(context: Context, params: Unit): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---Daggerの設定

@Module
internal interface MainActivityModule {
  @Named(&amp;quot;main&amp;quot;)
  @Binds fun bindMain2Router(impl: MainRouter2Impl): Router&amp;lt;Unit&amp;gt;
}

---使用側

class SubActivity : AppCompatActivity() {
  @field:[Inject Named(&amp;quot;main&amp;quot;)] lateinit var router: Router&amp;lt;Unit&amp;gt;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DaggerのNamedアノテーションと組み合わせることでいい感じに共通Routerを作ることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;相互に行き来したい画面があったときに、遷移専用のモジュールを作ることで循環参照を防ぐことが出来る&lt;/li&gt;
&lt;li&gt;基本的に画面を含んだモジュールは遷移したいときがほとんどだと思うので、遷移専用のモジュールを作ることで無駄な依存を作ることを防ぐことが出来る&lt;/li&gt;
&lt;li&gt;遷移用のモジュールが増える😂😂😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part2ではDeeplinkやnavigationを絡めた遷移の方法について考えてみたいと思います😃&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: コーディングを支える技術</title>
      <link>https://satoshun.github.io/2018/12/coding_tech/</link>
      <pubDate>Fri, 28 Dec 2018 05:27:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coding_tech/</guid>
      <description>&lt;p&gt;「コーディングを支える技術」を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;比較、歴史から学ぶ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;その機能はなにかの問題を解決するために導入されている

&lt;ul&gt;
&lt;li&gt;歴史から紐解くことでなぜそれが必要かが理解できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語によってどの問題を解決したいのかが違う

&lt;ul&gt;
&lt;li&gt;Python: 同じようなコードになるような言語&lt;/li&gt;
&lt;li&gt;C++: 高速に動作することを目指している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;エラー処理の進化
- globalなエラーハンドリングはgotoと変わらない
- try catch finallyのように構造化されたエラー処理が誕生した
    - Javaでは検査型例外、必ずerrorを処理しなければいけない設計&lt;/p&gt;

&lt;p&gt;アドレスを覚えるのは人間には大変&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人間はメソッド、変数を介することでアドレスを忘れることが出来た

&lt;ul&gt;
&lt;li&gt;結果、メソッド名、変数名をいかにしてわかりやすくするかが重要になってきた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本的には何をするかというよりかは、何をさせないかで進化している&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスによるポリモーフィズム

&lt;ul&gt;
&lt;li&gt;関数ポインタを直接触らないように&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gotoの禁止

&lt;ul&gt;
&lt;li&gt;構造化、モジュール化できなくなるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方</title>
      <link>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</link>
      <pubDate>Tue, 25 Dec 2018 03:00:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</guid>
      <description>&lt;p&gt;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;継承とコンポジションはトレードオフ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;継承は自動的にaメッセージを委譲する

&lt;ul&gt;
&lt;li&gt;便利だが依存関係は強い&lt;/li&gt;
&lt;li&gt;親クラスが変更されたときに、自動的に子クラスにも影響があることを意味する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;継承は階層構造を生み出す

&lt;ul&gt;
&lt;li&gt;ポリモーフィズムを実現する&lt;/li&gt;
&lt;li&gt;これまた便利だが依存関係は強い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンポジションは自動的に委譲しない

&lt;ul&gt;
&lt;li&gt;必要に応じて集約クラスで操る必要がある&lt;/li&gt;
&lt;li&gt;依存は継承より少ない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単一責任について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あたりまえだけど守らないといけない

&lt;ul&gt;
&lt;li&gt;無駄な責務があると再利用できない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;達成することで再利用可能な素晴らしいクラスが出来る&lt;/li&gt;
&lt;li&gt;責任の依存先が不明なときは一旦privateとかに切り出しておいて未来に託す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ダックタイピング&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ダックにより、具体的なGearクラスからロールへのマインドシフトが出来る&lt;/li&gt;
&lt;li&gt;ロールを満たすことにより要件を満たす&lt;/li&gt;
&lt;li&gt;実装には依存しない、メッセージを送るだけで良い世界はOOPの真骨頂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依存関係について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;依存関係の向きを考えるのは大切

&lt;ul&gt;
&lt;li&gt;例えばコンストラクタ内で依存するのと、インスタンスメソッドだと距離が違う。コンストラクタ内で依存したほうが良い

&lt;ul&gt;
&lt;li&gt;さらに進めるとDI，コンストラクタの外から注入する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依存関係逆転の法則

&lt;ul&gt;
&lt;li&gt;低レイヤーに依存するのではなく、インターフェースに依存しておいて、あとから実装を注入することで達成

&lt;ul&gt;
&lt;li&gt;domain層などの他の層に依存したくない層で有効&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柔軟なインターフェース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトを信じるようなインターフェース

&lt;ul&gt;
&lt;li&gt;どのようにするかではなく、何をするかをメソッド名にする。宣言的に&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安定していなければいけない&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>