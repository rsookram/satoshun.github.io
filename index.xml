<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Sun, 02 Jun 2019 09:08:57 UTC</updated>
    
    
    <item>
      <title>Dagger2: 2.23に入ったHasAndroidInjectorについて</title>
      <link>https://satoshun.github.io/2019/06/dagger-android-injector/</link>
      <pubDate>Sun, 02 Jun 2019 09:08:57 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/06/dagger-android-injector/</guid>
      <description>

&lt;p&gt;Dagger 2.23に新しく、&lt;code&gt;HasAndroidInjector&lt;/code&gt;インターフェースが入りました。
これは、従来の&lt;code&gt;HasActivityInjector&lt;/code&gt;や&lt;code&gt;HasFragmentInjector&lt;/code&gt;などを置き換えるために作られました。&lt;/p&gt;

&lt;p&gt;この記事では、どのように置き換えるかを説明していきたいと思います。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;DaggerApplication&lt;/code&gt;や&lt;code&gt;DaggerActivity&lt;/code&gt;などの基底クラスは使っていないものとします。&lt;/p&gt;

&lt;h2 id=&#34;置き換えていく&#34;&gt;置き換えていく&lt;/h2&gt;

&lt;h3 id=&#34;appcomponent&#34;&gt;AppComponent&lt;/h3&gt;

&lt;p&gt;AndroidSupportInjectionModuleを使っているなら、&lt;code&gt;AndroidInjectionModule&lt;/code&gt;に置き換えます。
今後は、&lt;code&gt;AndroidSupportInjectionModule&lt;/code&gt;を使う必要はありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@dagger.Component(
  modules = [
    AndroidInjectionModule::class, // AndroidInjectionModuleを使う
    ...
  ]
)
interface AppComponent ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;application&#34;&gt;Application&lt;/h3&gt;

&lt;p&gt;Applicationで実装している、HasActivityInjector、 HasServiceInjectorを&lt;code&gt;HasAndroidInjector&lt;/code&gt;に置き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class App : Application(),
  // HasAndroidInjectorのみでおｋ
  HasAndroidInjector {

  // 型変数がAnyになる
  @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt;

  // 返り値の型変数がAnyになる
  override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; {
    DaggerAppComponent.factory().create(this).inject(this)
    return androidInjector
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今まではActivtity用、Fragment用、Service用とそれぞれに&lt;code&gt;DispatchingAndroidInjector&lt;/code&gt;がありましたが、それが1つの&lt;code&gt;DispatchingAndroidInjector&amp;lt;Any&amp;gt;&lt;/code&gt;まとまりました。&lt;/p&gt;

&lt;h2 id=&#34;activity-fragment&#34;&gt;Activity, Fragment&lt;/h2&gt;

&lt;p&gt;HasSupportFragmentInjectorなどのInjectorは、&lt;code&gt;HasAndroidInjector&lt;/code&gt;に置き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(),
  // HasSupportFragmentInjectorの代わりに、HasAndroidInjectorを使う
  HasAndroidInjector {

  @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt;

  override fun onCreate(savedInstanceState: Bundle?) {
    AndroidInjection.inject(this) // ここは一緒
    ...
  }

  override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; {
    return androidInjector
  }
}

---以下、Fragment---

class MainFragment : Fragment() {
  override fun onAttach(context: Context) {
    AndroidSupportInjection.inject(this) // ここは一緒
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。従来の***Injectorが汎用的な&lt;code&gt;HasAndroidInjector&lt;/code&gt;まとまりました😃&lt;/p&gt;

&lt;p&gt;大きなコードの修正は必要なさそうです。&lt;/p&gt;

&lt;h2 id=&#34;なぜこの変更が入ったか&#34;&gt;なぜこの変更が入ったか?&lt;/h2&gt;

&lt;p&gt;ronshapiroさんが以下のツイートをしていました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Dagger 2.23 turns off formatting by default so your build is faster, but has a flag to turn it back on if you&amp;#39;d like.&lt;br&gt;&lt;br&gt;It also brings bug fixes and a more flexible &lt;a href=&#34;https://t.co/d0MeQYkvAV&#34;&gt;https://t.co/d0MeQYkvAV&lt;/a&gt; API that will allow for more androidx support&lt;a href=&#34;https://t.co/vtW7gebmu2&#34;&gt;https://t.co/vtW7gebmu2&lt;/a&gt;&lt;/p&gt;&amp;mdash; Ron Shapiro (@rdshapiro) &lt;a href=&#34;https://twitter.com/rdshapiro/status/1133493726561619968?ref_src=twsrc%5Etfw&#34;&gt;May 28, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今後、androidxのサポートを柔軟に対応するために必要だった変更のようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HasAndroidInjectorという1つの汎用インターフェースが爆誕した&lt;/li&gt;
&lt;li&gt;androidxのサポート増やしてくれそう。嬉しい😃

&lt;ul&gt;
&lt;li&gt;（ViewModel対応してほしい&amp;hellip;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ViewModel SavedState &#43; Dagger</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</link>
      <pubDate>Sat, 25 May 2019 10:38:15 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</guid>
      <description>

&lt;p&gt;ViewModel + SavedStateでDaggerを使う方法を考えてみました。&lt;/p&gt;

&lt;h2 id=&#34;前提知識-課題&#34;&gt;前提知識・課題&lt;/h2&gt;

&lt;p&gt;SavedStateを使う場合、ViewModelに&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスを渡さなければいけません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyViewModel(
  private val state: SavedStateHandle
) : ViewModel() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateHandleインスタンスを作るために、&lt;code&gt;SavedStateVMFactory&lt;/code&gt;もしくは、&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を使う必要があります。&lt;/p&gt;

&lt;p&gt;生成したいViewModelのコンストラクタの引数がSavedStateHandleのみなら、SavedStateVMFactoryを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// thisはFragmentActivity
ViewModelProvider(this, MyViewModel(this))
  .get(MyViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタの引数がSavedStateHandle以外にもあるなら、&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を拡張します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class TestViewModel(
  private val state: SavedStateHandle,
  private val name: String
) : ViewModel()

class TestViewModelFactory(
  owner: SavedStateRegistryOwner,
  defaultArgs: Bundle? = null
) : AbstractSavedStateVMFactory(owner, defaultArgs) {
  override fun &amp;lt;T : ViewModel&amp;gt; create(
    key: String, modelClass: Class&amp;lt;T&amp;gt;,
    handle: SavedStateHandle
  ): T {
    return TestViewModel(handle, &amp;quot;test&amp;quot;) as T
  }
}

// 以下、生成コード
ViewModelProvider(this, TestViewModelFactory(this))
  .get(TestViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。&lt;/p&gt;

&lt;p&gt;今までとは違い、AbstractSavedStateVMFactoryに&lt;code&gt;SavedStateRegistryOwner&lt;/code&gt;インターフェース（実質、FragmentActivity or Fragment）を渡さなければいけません。
また、初期値が欲しい場合は、defaultArgs(Bundle)も渡す必要があります。&lt;/p&gt;

&lt;h2 id=&#34;daggerでどのように使うか&#34;&gt;Daggerでどのように使うか?&lt;/h2&gt;

&lt;p&gt;以下いろいろと書いていきます。クラス名は適当です。また、このサンプルはFragmentActivity + 初期値がintent.extras固定となります。Fragmentの場合はFragmentに置き換える必要があります&lt;/p&gt;

&lt;h3 id=&#34;1-abstractsavedstatevmfactoryを生成するクラスを定義する&#34;&gt;1. AbstractSavedStateVMFactoryを生成するクラスを定義する&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SavedStateViewModel2(
  private val dummy: Dummy,
  private val state: SavedStateHandle
) : ViewModel() {
  class Factory @Inject constructor(private val dummy: Dummy) {
    fun create(owner: FragmentActivity): AbstractSavedStateVMFactory {
      return object : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
        override fun &amp;lt;T : ViewModel&amp;gt; create(
          key: String,
          modelClass: Class&amp;lt;T&amp;gt;,
          handle: SavedStateHandle
        ): T {
          return SavedStateViewModel2(dummy, handle) as T
        }
      }
    }
  }
}

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory: SavedStateViewModel2.Factory
  private val viewModel by viewModels&amp;lt;SavedStateViewModel2&amp;gt; { // viewModelsはktxの拡張関数
    factory.create(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一番シンプルな方法だと思います。&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を作るためのFactory（FactoryのFactory）を作り、それに&lt;code&gt;@Inject&lt;/code&gt;をつけます。&lt;/p&gt;

&lt;h3 id=&#34;2-1の方法に加え-fragmentactivityをbinds-or-providesする&#34;&gt;2. 1の方法に加え、FragmentActivityをBinds or Providesする&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Binds
fun fragmentActivity(activity: MainActivity): FragmentActivity

or

@Provides
fun fragmentActivity(activity: MainActivity): FragmentActivity = fragmentActivity

--

class SavedStateViewModel5(
  private val dummy: Dummy,
  private val state: SavedStateHandle
) : ViewModel() {
  class Factory @Inject constructor(
    owner: FragmentActivity,
    private val dummy: Dummy
  ) : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
    override fun &amp;lt;T : ViewModel&amp;gt; create(
      key: String,
      modelClass: Class&amp;lt;T&amp;gt;,
      handle: SavedStateHandle
    ): T {
      return SavedStateViewModel5(dummy, handle) as T
    }
  }
}

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory: SavedStateViewModel5.Factory
  private val viewModel by viewModels&amp;lt;SavedStateViewModel5&amp;gt; {
    factory
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FragmentActivityがInject可能になったので直接AbstractSavedStateVMFactoryが生成可能になりました😃&lt;/p&gt;

&lt;h3 id=&#34;3-assistedinjectを使う&#34;&gt;3. AssistedInjectを使う&lt;/h3&gt;

&lt;p&gt;SavedStateHandleがDaggerで解決しにくい値なので、&lt;a href=&#34;https://github.com/square/AssistedInject&#34;&gt;square/AssistedInject&lt;/a&gt;を使うことで解決を試みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SavedStateViewModel3 @AssistedInject constructor(
  @Assisted private val state: SavedStateHandle,
  private val dummy: Dummy
) : ViewModel() {

  @AssistedInject.Factory
  interface Factory {
    fun create(state: SavedStateHandle): SavedStateViewModel3
  }
}

---

@AssistedModule
@Module(includes = [AssistedInject_SavedStateViewModelModule::class])
interface SavedStateViewModelModule

---

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory3: SavedStateViewModel3.Factory
  private val viewModel3 by viewModels&amp;lt;SavedStateViewModel3&amp;gt; {
    viewModelWrapper(this) { factory3.create(it) }
  }
}

---

// ただの便利関数
fun &amp;lt;T : ViewModel&amp;gt; viewModelWrapper(
  owner: FragmentActivity,
  body: (state: SavedStateHandle) -&amp;gt; T
): AbstractSavedStateVMFactory {
  return object : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
    override fun &amp;lt;T : ViewModel&amp;gt; create(
      key: String,
      modelClass: Class&amp;lt;T&amp;gt;,
      handle: SavedStateHandle
    ): T {
      @Suppress(&amp;quot;UNCHECKED_CAST&amp;quot;)
      return body(handle) as T
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。FragmentActivityをInject可能にすれば、もう少しいい感じに書けると思います。最終的なコード量は1、2のパターンに比べかなり減ると思います。&lt;/p&gt;

&lt;h3 id=&#34;4-assistedinject-multibindsを使う&#34;&gt;4. AssistedInject + multibindsを使う&lt;/h3&gt;

&lt;p&gt;DaggerでViewModelのインスタンスを生成するときに、multibindsを使うパターンがよく使われているので、SavedStateの場合も考えてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@MustBeDocumented
@Target(
  AnnotationTarget.FUNCTION,
  AnnotationTarget.PROPERTY_GETTER
)
@Retention(AnnotationRetention.RUNTIME)
@MapKey annotation class ViewModelKey(
  val value: KClass&amp;lt;out ViewModel&amp;gt;
)

---

class ViewModelFactory @Inject constructor(
  owner: FragmentActivity,
  private val creators: Map&amp;lt;Class&amp;lt;out ViewModel&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;SavedStateViewModelFactory&amp;gt;&amp;gt;
) : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
  override fun &amp;lt;T : ViewModel&amp;gt; create(
    key: String,
    modelClass: Class&amp;lt;T&amp;gt;,
    handle: SavedStateHandle
  ): T {
    var creator: Provider&amp;lt;out SavedStateViewModelFactory&amp;gt;? = creators[modelClass]
    if (creator == null) {
      for ((key, value) in creators) {
        if (modelClass.isAssignableFrom(key)) {
          creator = value
          break
        }
      }
    }
    if (creator == null) {
      throw IllegalArgumentException(&amp;quot;unknown model class $modelClass&amp;quot;)
    }
    try {
      @Suppress(&amp;quot;UNCHECKED_CAST&amp;quot;)
      return creator.get().create(handle) as T
    } catch (e: Exception) {
      throw RuntimeException(e)
    }
  }
}

---

interface SavedStateViewModelFactory {
  fun create(
    state: SavedStateHandle
  ): ViewModel
}

---

class SavedStateViewModel4 @AssistedInject constructor(
  @Assisted private val state: SavedStateHandle,
  private val dummy: Dummy
) : ViewModel() {

  @AssistedInject.Factory
  interface Factory : SavedStateViewModelFactory {
    override fun create(state: SavedStateHandle): SavedStateViewModel4
  }
}

---

@Binds
fun bindFragmentActivity(activity: MainActivity): FragmentActivity

@ViewModelKey(SavedStateViewModel4::class)
@IntoMap @Binds
fun bind(
  factory: SavedStateViewModel4.Factory
): SavedStateViewModelFactory

---

@Inject lateinit var viewModelFactory: ViewModelFactory
private val viewModel4 by viewModels&amp;lt;SavedStateViewModel4&amp;gt; {
  viewModelFactory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateViewModelFactoryインターフェースを作るところがポイントです。他の部分は従来のViewModel + multibindsと大体一緒です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SavedStateHandleはDaggerで解決しにくい・できない？

&lt;ul&gt;
&lt;li&gt;自分で頑張ってFactoryを書く、Assisted Injectを使うなどの方法をしなければ行けない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;multibindsを使う方法はさらに複雑になった

&lt;ul&gt;
&lt;li&gt;出来るとは思うけど、個人的には推奨しない。複雑になりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に使ったコードは&lt;a href=&#34;https://github.com/satoshun-android-example/ViewModelSavedState&#34;&gt;satoshun-android-example/ViewModelSavedState&lt;/a&gt;にあります😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>雑メモ: ViewModel SavedStateのコードリーディング</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate/</link>
      <pubDate>Tue, 21 May 2019 23:59:53 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate/</guid>
      <description>

&lt;p&gt;ViewModelのSavedStateがどのように実現しているのか、内部でどのように動作しているのか気になったので、ソースコードを読んでみました。&lt;/p&gt;

&lt;p&gt;この記事のソースコードは全て、下記のライセンスに従います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;/*
 * Copyright 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まずsavedstate本体のコード&#34;&gt;まずsavedstate本体のコード&lt;/h2&gt;

&lt;p&gt;主な登場クラスは以下です。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistry-savedstateprovider&#34;&gt;SavedStateRegistry.SavedStateProvider&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * This interface marks a component that contributes to saved state.
 */
public interface SavedStateProvider {
   /**
    * Called to retrieve a state from a component before being killed
    * so later the state can be received from {@link #consumeRestoredStateForKey(String)}
    *
    * @return S with your saved state.
    */
    @NonNull
    Bundle saveState();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;のタイミングでコールされ、&lt;code&gt;outState&lt;/code&gt;に追加で、保存したい値をBundle型で返却します。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistry&#34;&gt;SavedStateRegistry&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An interface for plugging components that consumes and contributes to the saved state.
 *
 * &amp;lt;p&amp;gt;This objects lifetime is bound to the lifecycle of owning component: when activity or
 * fragment is recreated, new instance of the object is created as well.
 */
public final class SavedStateRegistry {
    public Bundle consumeRestoredStateForKey(@NonNull String key)
    public void registerSavedStateProvider(@NonNull String key,
            @NonNull SavedStateProvider provider)
    public void unregisterSavedStateProvider(@NonNull String key)
    public boolean isRestored()
    public void runOnNextRecreation(@NonNull Class&amp;lt;? extends AutoRecreated&amp;gt; clazz)

    void performRestore(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)
    void performSave(@NonNull Bundle outBundle)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程のSavedStateProviderを&lt;code&gt;registerSavedStateProvider&lt;/code&gt;メソッドを通して集約し、&lt;code&gt;performRestore&lt;/code&gt;、&lt;code&gt;performSave&lt;/code&gt;によって、savedStateから読み込み、outStateに保存します。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistryowner&#34;&gt;SavedStateRegistryOwner&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * A scope that owns {@link SavedStateRegistry}
 */
public interface SavedStateRegistryOwner extends LifecycleOwner {
    /**
     * Returns owned {@link SavedStateRegistry}
     *
     * @return a {@link SavedStateRegistry}
     */
    @NonNull
    SavedStateRegistry getSavedStateRegistry();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateRegistryOwnerは先程の&lt;code&gt;SavedStateRegistry&lt;/code&gt;のOwnerになります。これは、&lt;code&gt;ComponentActivity&lt;/code&gt;や&lt;code&gt;Fragment&lt;/code&gt;が実装しています。LifecycleOwner、Lifecycleのような実装です。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistrycontroller&#34;&gt;SavedStateRegistryController&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An API for {@link SavedStateRegistryOwner} implementations to control {@link SavedStateRegistry}.
 * &amp;lt;p&amp;gt;
 * {@code SavedStateRegistryOwner} should call {@link #performRestore(Bundle)} to restore state of
 * {@link SavedStateRegistry} and {@link #performSave(Bundle)} to gather SavedState from it.
 */
public final class SavedStateRegistryController {
    public SavedStateRegistry getSavedStateRegistry()
    public void performRestore(@Nullable Bundle savedState)
    public void performSave(@NonNull Bundle outBundle)

    public static SavedStateRegistryController create(@NonNull SavedStateRegistryOwner owner)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SavedStateRegistryOwner&lt;/code&gt;のための実装です。ComponentActivityやFragmentではこのクラスを介して、Bundleから値を復元/restoreしたり、保存/saveします。&lt;/p&gt;

&lt;p&gt;これがSavedStateで使われている主なクラスになります。&lt;/p&gt;

&lt;p&gt;次に、ViewModelのsaveの実行の流れを見てみます。&lt;/p&gt;

&lt;h2 id=&#34;viewmodelのsaveの実行の流れ&#34;&gt;ViewModelのsaveの実行の流れ&lt;/h2&gt;

&lt;p&gt;ViewModelのSavedStateのsaveの実行の流れを見ながら、コードリーディングをしていきます。&lt;/p&gt;

&lt;h3 id=&#34;1-viewmodelを生成する&#34;&gt;1. ViewModelを生成する&lt;/h3&gt;

&lt;p&gt;ViewModelとSavedStateを一緒に扱い時は、&lt;code&gt;SavedStateVMFactory&lt;/code&gt;を使います。
これは、ViewModelインスタンスに&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスを渡すために必要なFactoryです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// thisはFragmentActivity
val vm = ViewModelProvider(this, SavedStateVMFactory(this))
    .get(MyViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書くことで、MyViewModelで&lt;code&gt;SavedStateHandle&lt;/code&gt;を受け取ることが出来ます。&lt;/p&gt;

&lt;p&gt;SavedStateVMFactoryでは以下の処理を行っています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスの生成

&lt;ul&gt;
&lt;li&gt;SavedStateHandleでは、&lt;code&gt;SavedStateProvider&lt;/code&gt;の実装と、outStateに保存/saveしたい状態を保持している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成したSavedStateHandleインスタンスをViewModelに渡す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SavedStateRegistry&lt;/code&gt;に、SavedStateHandleで保持しているSavedStateProviderを登録する&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-componentactivity-onsaveinstancestate&#34;&gt;2. &lt;code&gt;ComponentActivity#onSaveInstanceState&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ComponentActivity ... {
    private final SavedStateRegistryController mSavedStateRegistryController =
            SavedStateRegistryController.create(this);

    protected void onSaveInstanceState(@NonNull Bundle outState) {
        ...
        mSavedStateRegistryController.performSave(outState);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは、SavedStateRegistryControllerに、&lt;code&gt;outState&lt;/code&gt;に保存を頼みます。&lt;/p&gt;

&lt;h3 id=&#34;3-savedstateregistrycontroller-performsave&#34;&gt;3. &lt;code&gt;SavedStateRegistryController#performSave&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class SavedStateRegistryController {
    private final SavedStateRegistry mRegistry;

    ...

    public void performSave(@NonNull Bundle outBundle) {
        mRegistry.performSave(outBundle);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SavedStateRegistry&lt;/code&gt;に処理を委譲します。&lt;/p&gt;

&lt;h3 id=&#34;4-savedstateregistry-performsave&#34;&gt;4. &lt;code&gt;SavedStateRegistry#performSave&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class SavedStateRegistry {
    private SafeIterableMap&amp;lt;String, SavedStateProvider&amp;gt; mComponents =
            new SafeIterableMap&amp;lt;&amp;gt;();
    private Bundle mRestoredState;

    ...

    void performSave(@NonNull Bundle outBundle) {
        Bundle components = new Bundle();
        if (mRestoredState != null) {
            components.putAll(mRestoredState);
        }
        for (Iterator&amp;lt;Map.Entry&amp;lt;String, SavedStateProvider&amp;gt;&amp;gt; it =
                mComponents.iteratorWithAdditions(); it.hasNext(); ) {
            Map.Entry&amp;lt;String, SavedStateProvider&amp;gt; entry1 = it.next();
            components.putBundle(entry1.getKey(), entry1.getValue().saveState());
        }
        outBundle.putBundle(SAVED_COMPONENTS_KEY, components);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;outBundle#putBundle&lt;/code&gt;を通して、保存を行います。今で、直接Activityの&lt;code&gt;onSaveInstanceState&lt;/code&gt;をoverrideして書いていた処理がここに移ったイメージです。&lt;/p&gt;

&lt;h3 id=&#34;5-savedstatehandleの-savedstateprovider-の実装&#34;&gt;5. SavedStateHandleの&lt;code&gt;SavedStateProvider&lt;/code&gt;の実装&lt;/h3&gt;

&lt;p&gt;実際に保存される内容を決めるのはSavedStateHandleのSavedStateProviderの実装/中身になります。&lt;/p&gt;

&lt;p&gt;実装は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Map&amp;lt;String, Object&amp;gt; mRegular;

private static final String VALUES = &amp;quot;values&amp;quot;;
private static final String KEYS = &amp;quot;keys&amp;quot;;

private final SavedStateProvider mSavedStateProvider = new SavedStateProvider() {
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    @NonNull
    @Overrides
    public Bundle saveState() {
        Set&amp;lt;String&amp;gt; keySet = mRegular.keySet();
        ArrayList keys = new ArrayList(keySet.size());
        ArrayList value = new ArrayList(keys.size());
        for (String key : keySet) {
            keys.add(key);
            value.add(mRegular.get(key));
        }

        Bundle res = new Bundle();
        // &amp;quot;parcelable&amp;quot; arraylists - lol
        res.putParcelableArrayList(&amp;quot;keys&amp;quot;, keys);
        res.putParcelableArrayList(&amp;quot;values&amp;quot;, value);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapに保存したい値を保持しておいて、それをBundleに書き出すだけです。&lt;/p&gt;

&lt;p&gt;ざっくりと保存の流れはこんな感じです:D&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;LifecycleOwnerのような感じで実装されていた&lt;/li&gt;
&lt;li&gt;SavedStateProviderを実装して、registerSavedStateProviderに渡せば、誰でもカスタムのSavedStateが書ける😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ViewPager2 with TabLayout</title>
      <link>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</link>
      <pubDate>Fri, 17 May 2019 04:08:42 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</guid>
      <description>

&lt;p&gt;Material ComponentsでViewPager2 + TabLayoutのコードが入ったのでそれの紹介。まだalphaへのリリースもされていないので、APIは大きく変わるかもしれません。おそらく&lt;code&gt;1.1.0-alpha07&lt;/code&gt;に入ってくると思います。&lt;/p&gt;

&lt;p&gt;TabLayoutはViewPagerでサポートされていましたが、それがViewPager2にも来たって感じです。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;新しく追加された&lt;a href=&#34;https://github.com/material-components/material-components-android/blob/67e4489293290853de83ef1b00205058ae25fa8e/lib/java/com/google/android/material/tabs/TabLayoutMediator.java&#34;&gt;TabLayoutMediator&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;TabLayoutMediator&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val viewPager: ViewPager2 = findViewById(R.id.viewpager)
val tabLayout: TabLayout = findViewById(R.id.tab)
val mediator = TabLayoutMediator(tabLayout, viewPager) { tab: TabLayout.Tab, position: Int -&amp;gt;
  tab.text = &amp;quot;test $position&amp;quot; // タブにタイトルをセット
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタには、TabLayout、ViewPager2、OnConfigureTabCallbackを渡します。
&lt;code&gt;OnConfigureTabCallback&lt;/code&gt;は、tabとpositionを受け取り、tabに対して、タイトルをセットします。
ViewPagerのPageAdapterとは違い、RecyclerViewのAdapterからはタイトルを取得できないので、このような変更になったと思われます。&lt;/p&gt;

&lt;p&gt;最後に&lt;code&gt;attach&lt;/code&gt;関数を呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;mediator.attach()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、ViewPager2 + TabLayoutを実現できます。とても簡単！！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ViewPager2もエコシステムが整いつつある😊&lt;/li&gt;
&lt;li&gt;今回試したサンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/ViewPager2&#34;&gt;satoshun-android-example/ViewPager2&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Data Binding 3.5と3.6のまとめ/感想</title>
      <link>https://satoshun.github.io/2019/05/databinding-3dot5/</link>
      <pubDate>Thu, 16 May 2019 00:33:48 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/databinding-3dot5/</guid>
      <description>

&lt;p&gt;Google I/O 2019でDataBindingについて少し話されていたので感想とまとめを。
動画だと&lt;a href=&#34;https://youtu.be/Qxj2eBmXLHg?t=243&#34;&gt;ここらへん&lt;/a&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;改善系&#34;&gt;改善系&lt;/h2&gt;

&lt;h3 id=&#34;ビルドの高速化&#34;&gt;ビルドの高速化!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;20%くらいビルドが早くなった&lt;/li&gt;
&lt;li&gt;distributed build cache対応&lt;/li&gt;
&lt;li&gt;Incremental annotation processing対応

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android.databinding.incremental=true&lt;/code&gt; を設定にすると使えます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;android-studioとの連携強化&#34;&gt;Android Studioとの連携強化!!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Live Class Generation

&lt;ul&gt;
&lt;li&gt;XMLを変更したら、コンパイルせずともクラス、フィールドにアクセスすることが出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リファクタリング系

&lt;ul&gt;
&lt;li&gt;フィールド名の変更リファクタリングなどをしたときに、XML、コードの両方に反映される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;errorメッセージの改善&#34;&gt;Errorメッセージの改善!!!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;DataBinding用のエラーセクションが出来たことで、どこでエラーが出たか特定しやすくなった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/9sMrM9zLYG96Vg2Mlt7KON2audHhb2hPcryUDkkp9E0s2Q2oVKd94EsoxxvxZwhAfkORXabT2-V2lnxDlEF7gMoTWMmJ0AmIPjyp-o54bFdqoN7u4KQlNqwz6ufqT8xKx7JvKJoJc-cyaH-3IOujqq-m7V0h5QYeN1W2JAeon_fDv-vqPRqzHydPvW2zv8NEuboWPOCQFSqABPj61OEI0kLstUwClb6E6_1CAjtenJfmhUjG2_gBbNakPao6BnSb4-1_BHeZnpkUMPzWyip4I0bRtnAIZcCjt797Sk90o8e87H0y_JdGUu-crJ2LVL5QvJ8Sz2WKkFcs1AxaLnn4PfRYzooeh70hJAjFPXuR9tkonL5PjyT96EqgOhmQlmzmXaj6NEwYjmOc7VE8KDFXSvLUm1K5GlyaU1j8vUWhnNKvPPpfFn26XnIcTD0j2-YE_RhR4nP40LNS1XxCsFOJBpOWZCK69JwAp3flmULDQpmkJkeSp99T_suxdxlRDrPZnTb4gNAs6Bd0IMsalfJpOQWpAPQebqNkuan_BjytvzQl3sR0KPi73AafkfzcNQbPjsMXxMJNqbyMaxZFwDIIw5WLLm7GoOsU8PX8d1sadYbwTHVYpx9M_nqTcBLns-henpEBj89wDXy3tXg-xF2DyGNScK2blikn=w2160-h1620-no&#34; style=&#34;max-width: 600px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;新規系&#34;&gt;新規系&lt;/h2&gt;

&lt;h3 id=&#34;view-binding&#34;&gt;View Binding&lt;/h3&gt;

&lt;p&gt;簡易版Data Bindingのような立ち位置で、findViewByIdを省略 + コンパイルセーフ + コンパイルを高速にすることを目的に作られました。3.6で入るみたいです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/WfZyK356KdBHf5gHL1PExSKTXXo5_lEKhsvoDhrlRgSWH40Qa4Y6hhw_08w3Wm46KAoFAf26_cAhtDIzDja3OKxf7cVTju9UwNp-JAvaTDJrlI2gWHSmTkePpGB8Vl8pxzdmAcjuuJ1EzUW_h67sFEULzQE-a1ro96x03jAC5FCjWSArhx2f5jz9cqSPdhieW_zk1glrdLqHUogvoeJCoLbtaDy2KFnwQkwJDWPkWDfBs3Q2CxrkI6-Fom1fmpHIFMZ4NjUVU4TKfbDqYWCALnvB5G17HXy0YvFjYnSDLtWn4nUMH2rZWnh0R9JJU5fIVBDtncuZkqhp-AZUJBrInCsvV-8vIaUeBr6ZoUPTd9Ja4qz0ooODr7VOJDGBFPP4qHpNIzQwxWzCgYlsRU4l8i9dxMCKq0bLfTxZcIGBYYm-Bed8AGiUyPnsS_7HTMkuWu_NPGn-cTOTIFJ6n9vSdm2uR0IIJWXW8fS6s_q0S9eSZJYW6zeJBXOxdP4ot2FSaZDL8pmwbxivfaWTA_R3XraQizWG788EvVkpFvF2Xree28fR6qKP1zlKS2mSrooQCsQ-xNkoLWnTkNkLC8j9USiSRFrhDl0Mu9LmJckzPSq52FmaX8ClbXt8_H2vML3tmwqY8FQ92ZTmP9WNHDFr12jP96uX_3jKsraXa8btthUlzCHe58dIWeSlKU7GOqh1hr8k4GGcxZYvJVzjydsGIY-mqQ=w2160-h1620-no&#34; style=&#34;max-width: 600px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Data Bindingと比較したときの、メリット、デメリット以下になります。（ただし、まだalphaも出ていない段階なのでI/O動画から見る限りの感想です）&lt;/p&gt;

&lt;h4 id=&#34;メリット&#34;&gt;メリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;コンパイルが早くなる

&lt;ul&gt;
&lt;li&gt;Data Bindingより機能が少なくなるのでそれはそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;layout&amp;gt;&lt;/code&gt;で囲う必要がなくなった

&lt;ul&gt;
&lt;li&gt;これ個人的には好きでなかったので嬉しい。ネストが減る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;デメリット&#34;&gt;デメリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;data&amp;gt;&lt;/code&gt;セクションがなくなる

&lt;ul&gt;
&lt;li&gt;モデルの値とViewのマッピングはコード側ですることになりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多分BindingAdapterは使えない

&lt;ul&gt;
&lt;li&gt;これもコード側ですることになりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双方向バインディングとか使えない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;おそらくなんですけど、Data Binding、View Bindingは1つにプロジェクトに混在させることが出来るので、基本View Bindingで、双方向使いたいときはData Bindingみたいな使い方も出来るはずです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ-感想&#34;&gt;まとめ/感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;今、3.5-beta01を使っているんですが、肌感、かなり良くなっています😃

&lt;ul&gt;
&lt;li&gt;Live Class Generation便利すぎワロリン&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;View Bindingはとても良さそう

&lt;ul&gt;
&lt;li&gt;Kotlin syntheticの代わりに使ってもよさそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CameraX: CameraView触ってみた</title>
      <link>https://satoshun.github.io/2019/05/camerax-camera-view/</link>
      <pubDate>Mon, 06 May 2019 05:47:14 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/camerax-camera-view/</guid>
      <description>

&lt;p&gt;CameraXのコードが公開されていたので、その中にあったCameraViewを触ってみました。まだ、alphaであることからAPIは大きく変わる可能性があります。&lt;/p&gt;

&lt;p&gt;内部の実装であったり、細かい部分はpsideさんの「&lt;a href=&#34;https://p-side.net/posts/2019-05-05-camerax/&#34;&gt;CameraXのコードがきたので気合い入れて読んでみた&lt;/a&gt;」が詳しいです。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;CameraViewはまだ公開されていないため、ソースコードからビルドする必要があります。また、設定でpublishフラグがfalseになっているので、trueにしてビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; androidx {
     name = &amp;quot;Jetpack Camera View Library&amp;quot;
-    publish = false
+    publish = true
     mavenVersion = LibraryVersions.CAMERA
     mavenGroup = LibraryGroups.CAMERA
     inceptionYear = &amp;quot;2019&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;CameraViewは普通のViewのように使うことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&amp;gt;

  &amp;lt;androidx.camera.view.CameraView
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に初期化をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.bindToLifecycle(this) // thisはLifecycleOwner
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LifecycleOwnerとCameraViewを結びつけることでLifecycleに合わせて自動でリソースを調整してくれます。
CameraViewはLifecycle-Aware Componentとなっています。非常に扱いやすそうです。&lt;/p&gt;

&lt;p&gt;これだけでカメラ機能が使えるようになります！とても簡単！!&lt;/p&gt;

&lt;p&gt;以下、CameraViewで現状使えるAPIについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cameraviewで使えるapi達&#34;&gt;CameraViewで使えるAPI達&lt;/h2&gt;

&lt;h3 id=&#34;モードの変更&#34;&gt;モードの変更&lt;/h3&gt;

&lt;p&gt;CameraViewでは次の3つのモードがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Image: 写真を取る&lt;/li&gt;
&lt;li&gt;Video: ビデオを取る&lt;/li&gt;
&lt;li&gt;Mixed: 両方。ただし、動かない端末もあるらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Image
cameraView.captureMode = CameraView.CaptureMode.IMAGE
cameraView.takePicture(...)

// Video
cameraView.captureMode = CameraView.CaptureMode.VIDEO
cameraView.startRecording(...)
cameraView.stopRecording()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scaletypeの設定&#34;&gt;ScaleTypeの設定&lt;/h3&gt;

&lt;p&gt;Scaleを設定することができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CENTER_CROP&lt;/li&gt;
&lt;li&gt;CENTER_INSIDE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.scaleType = CameraView.ScaleType.CENTER_INSIDE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lensfacingの切り替え&#34;&gt;LensFacingの切り替え&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.toggleCamera()

// or

cameraView.setCameraByLensFacing(CameraX.LensFacing.FRONT)
cameraView.setCameraByLensFacing(CameraX.LensFacing.BACK)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flashモードの設定&#34;&gt;Flashモードの設定&lt;/h3&gt;

&lt;p&gt;撮影時にフラッシュを有効にすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.flash = FlashMode.ON
cameraView.flash = FlashMode.OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;torchの有効-無効&#34;&gt;torchの有効/無効&lt;/h3&gt;

&lt;p&gt;背面ライトを有効にすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.enableTorch(true)
cameraView.enableTorch(false)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zoomの設定&#34;&gt;zoomの設定&lt;/h3&gt;

&lt;p&gt;コードから変えることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.zoomLevel = 3f
cameraView.zoomLevel = 10f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、CameraViewはpinch-in-outでのzoomの変更にも対応しています。&lt;/p&gt;

&lt;h3 id=&#34;focus&#34;&gt;focus&lt;/h3&gt;

&lt;p&gt;指定した部分にfocusを合わせることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.focus(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CameraViewは柔軟性がない代わりに、簡単にカメラの機能を使うことが出来る

&lt;ul&gt;
&lt;li&gt;とはいえ、基本的な機能は揃っていそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後に、CameraViewを実装した結果になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/2_s_ijtuGJSuwaJlLbsBXZ1QMTrJDjaqCM4I4ZmJQexItcrj9TgHIsh7g_VgR0nhTf-kYZ00kRDILJEsfjkd57CDK_f-d835KBsdaYdJQ0w55gsA1iCze5mC5Sm_HxDmtgHT7Asm8RUjPmYgxuI22TmFuEhP0gzxqR4ZPAroobBb0itTuZZX2Gi3X7JMfCm31wNMYSUleaBBwm9X7V3edWVCERxyLXUSoTs4ewZ-J05OMozhe0r6Wx1TsJx_5-wc4k4yrex08x4osdIiZVGJHI4W_hrlcIBL131nwHzm29djjrYLiaeb-UnKnP1kdum0NPEDIMQyvCgs3R3BR_BjoeqhLV6CadhPT2PH-AFkH4jXDKXbCC-BNRmJFbeubUtg6ATOCSXNV_Zc0i8qjzqzQFQ-kHlknUgn592eQECQYSNxS4m340CXqy_xP0DnU-o6WjE5ay4gJuYH8kR1eGflOG8sgyvoNlxaFmIXZpreBQJaXfqImK9tncglYIwVQnxEL8uMxZ_31Rc2--SVsKNCDCl625teKj28EaedQ0lzjvXlFAge4OKz-dMmMRiz12TTIfq6TFGB3TPLmjtpV1Su6VbQ0peovn6AvKgAOW2XM7JxVUmZU20GI4jtKyBMGppf4hsTY624sFnaSwoBr_7RshaOZ6f4JFykCBE4P2AvC549faCde3pnGhsQ2_ZFwA7ESpMN1hsgI7gUjFzaeSc0iLYVIw=w600-h1067-no&#34; width=300 /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>MvRxの雑な感想</title>
      <link>https://satoshun.github.io/2019/05/mvrx-architecture/</link>
      <pubDate>Sun, 05 May 2019 05:05:09 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/mvrx-architecture/</guid>
      <description>

&lt;p&gt;雑多なことを書いただけのブログになります。内容はあまりないよう〜。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/airbnb/MvRx&#34;&gt;MvRx&lt;/a&gt;はAirbnbが開発をしているOSSフレームワークです。&lt;/p&gt;

&lt;p&gt;特徴としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kotlinファースト&lt;/li&gt;
&lt;li&gt;RxJavaを使っている&lt;/li&gt;
&lt;li&gt;AAC（Android Architecture Components）をベースにしている

&lt;ul&gt;
&lt;li&gt;AACをRxJavaであったり、便利関数、クラス群で補佐している感じ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多くの部分でReactのAPIを参考にしてる

&lt;ul&gt;
&lt;li&gt;State、renderなど&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/airbnb/epoxy&#34;&gt;Epoxy&lt;/a&gt;と相性が良い

&lt;ul&gt;
&lt;li&gt;一緒に使うことを推奨している&lt;/li&gt;
&lt;li&gt;ReactのComponentのように振る舞わうことが出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelが保持しているState（状態）に対して、Viewがpure functionのように振る舞う

&lt;ul&gt;
&lt;li&gt;副作用がない（減らしたい）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボイラープレートなコードを減らすことが期待できます😃&lt;/p&gt;

&lt;h2 id=&#34;個人的に気になった部分-好きなとこ&#34;&gt;個人的に気になった部分、好きなとこ&lt;/h2&gt;

&lt;h3 id=&#34;stateでview状態を管理するところ&#34;&gt;StateでView状態を管理するところ&lt;/h3&gt;

&lt;p&gt;Stateを定義することのメリットは以下かなと思ってます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stateを見れば、Viewの構成要素が分かる

&lt;ul&gt;
&lt;li&gt;MVPアーキテクチャのViewインターフェースのような役割を果たす&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;状態の管理が楽

&lt;ul&gt;
&lt;li&gt;Androidでは、configuration changes時の状態の保持が難しいが、Stateだけをケアすれば良い

&lt;ul&gt;
&lt;li&gt;MvRxの流儀に習って、正しく実装すればよしなに状態の管理をしてくれる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Viewからロジックを取ることが出来る

&lt;ul&gt;
&lt;li&gt;もちろん実装次第なのですが、StateでViewの状態を表現するようにすれば、Viewはマッピングするだけで良くなる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;asyncがすごい良い&#34;&gt;Asyncがすごい良い&lt;/h3&gt;

&lt;p&gt;MvRxではAsyncというsealed classが定義されていて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uninitialized&lt;/li&gt;
&lt;li&gt;Loading&lt;/li&gt;
&lt;li&gt;Success&lt;/li&gt;
&lt;li&gt;Fail&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の4状態を表現することができます。画面の初期値は上記4状態で、大体のケースはケア出来ると思います。&lt;/p&gt;

&lt;p&gt;プロジェクトに、Asyncだけ取り入れるのもアリだと思います。&lt;/p&gt;

&lt;h3 id=&#34;single-eventの処理をどうするのか&#34;&gt;Single Eventの処理をどうするのか&lt;/h3&gt;

&lt;p&gt;State内で保持すると、毎回発火してしまうので、Stateとは違う、他のstreamで表現することになると思う&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;invalidateメソッドではなく、直接ViewModelに定義したフィールドを、observeすることになるので、他のページと比較したときに違和感があるかも

&lt;ul&gt;
&lt;li&gt;やっぱりSingle Eventの取り扱いって大変なんやなって&lt;/li&gt;
&lt;li&gt;とはいえ、sealed classで定義すれば、同じように見えることが出来ると思うので、大きな話ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chrisbanes/tivi&#34;&gt;Tivi&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;プロジェクトも大きく、Coroutineなども使っている&lt;/li&gt;
&lt;li&gt;これ見れば、なんとなく肌感は分かると思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Material Components: MotionSpecを使ってアニメーションをカスタマイズする</title>
      <link>https://satoshun.github.io/2019/04/fab-motion-spec/</link>
      <pubDate>Tue, 30 Apr 2019 05:59:41 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/fab-motion-spec/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/com/google/android/material/animation/MotionSpec&#34;&gt;MotionSpec&lt;/a&gt;はAndroid material componentsに定義されている1クラスになります。
MotionSpecを使うことで、次のアニメーション属性をカスタマイズすることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;startOffset&lt;/li&gt;
&lt;li&gt;duration&lt;/li&gt;
&lt;li&gt;interpolator&lt;/li&gt;
&lt;li&gt;repeatCount&lt;/li&gt;
&lt;li&gt;repeatMode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例えば、アニメーションを長くしたいときは、durationの値を長く、アニメーションの開始時間を遅らせたいなら、startOffsetの値を長くします。&lt;/p&gt;

&lt;p&gt;FloatingActionButtonを例に、実際にMotionSpecの値をいじってみます。&lt;/p&gt;

&lt;h2 id=&#34;最初にmotionspec用のanimator-xmlを定義する&#34;&gt;最初にMotionSpec用のanimator XMLを定義する&lt;/h2&gt;

&lt;p&gt;デフォルトのXMLをコピペしてきて、それをベースにカスタマイズするのが良いと思います。&lt;/p&gt;

&lt;p&gt;FloatingActionButton用のXMLはソースコードを読んでいくと、&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;と&lt;code&gt;design_fab_hide_motion_spec.xml&lt;/code&gt;で定義されていることが分かります。MotionSpecは、show/hide用の2種類があり、カスタマイズしたいときは両方とも変更する必要があります。&lt;/p&gt;

&lt;p&gt;まずはshow用のMotionSpecを変更していきます。以下がデフォルトで定義されている&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;の中身になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;!--
    Copyright 2017 The Android Open Source Project

    Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
--&amp;gt;

&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;opacity&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;scale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;iconScale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;0&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_fast_out_slow_in&amp;quot;/&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は、アニメーションを長くして、アイコンをバウンドしたいとします。
それは、durationを長くして、interpolatorに&lt;code&gt;@android:anim/bounce_interpolator&lt;/code&gt;を指定すれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;opacity&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;scale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;iconScale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでshow用のMotionSpecが完成しました。hideでも同じようにXMLを定義してあげます。&lt;/p&gt;

&lt;p&gt;次に、これをViewにセットします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fab.showMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_show_motion_spec
)
fab.hideMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_hide_motion_spec
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な、アニメーションはこんな感じになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/7iMReht6cMrOlVErQmTAHUTkcsk8GG76aQR1hwVEA_TCnOtrAgCOEoJU8SH6bhzdMcEOv6Z-pWU=w246-h437-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;p&gt;アニメーション時間が長くなり、ボヨンボヨンしていることが分かると思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MotionSpecを使えば、アニメーションの長さやinterpolatorをカスタマイズすることが出来る

&lt;ul&gt;
&lt;li&gt;まだ、MotionSpecに対応しているViewは少ないが、今後Chipなども対応予定😃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ConstraintLayout Flowの紹介</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-flow/</link>
      <pubDate>Sun, 28 Apr 2019 11:13:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/constraintlayout-flow/</guid>
      <description>

&lt;p&gt;ConstraintLayoutの2.0.0 alpha 5にFlow Virtual Layoutが導入されました🎉
Flowを使うことで、対象のViewを様々なルールで並べることができます。&lt;/p&gt;

&lt;p&gt;メリットとしては、次のようなものがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Viewの階層をフラットに保つことが出来る&lt;/li&gt;
&lt;li&gt;Flowは普通のViewのように扱う事ができる&lt;/li&gt;
&lt;li&gt;MotionLayoutと相性が良い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では、どのように書くのかを見ていきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-配置する方向を決める&#34;&gt;1. 配置する方向を決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;android:orientation&lt;/code&gt;から、horizontal or verticalを指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはorientationにhorizontalを持ちます。また、通常のViewのように各constraintsを指定し、配置することができます。&lt;/p&gt;

&lt;h3 id=&#34;2-wrapmodeを決める&#34;&gt;2. wrapModeを決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;flow_wrapMode&lt;/code&gt;で指定することができます。&lt;/p&gt;

&lt;p&gt;wrapModeでは、どのようにViewを並べるかを指定でき、3種類のmodeがあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;none

&lt;ul&gt;
&lt;li&gt;単純にsingle lineに並べる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;chain

&lt;ul&gt;
&lt;li&gt;単純に順番に配置していく。その行（列）に収まらない場合は次の行（列）に配置する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;aligned

&lt;ul&gt;
&lt;li&gt;各要素を整列するように配置していく。テーブルのようなイメージ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはchainで対象のViewを配置します。&lt;/p&gt;

&lt;h3 id=&#34;3-対象のviewを指定する&#34;&gt;3. 対象のViewを指定する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;constraint_referenced_ids&lt;/code&gt;から指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:constraint_referenced_ids=&amp;quot;title1,title2,title3&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title1&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain1&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title2&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain2&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title3&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain3&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;50sp&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、「title1、title2、title3」が対象のViewになります。また、これらのViewはhorizontalの方向に、chainで順々に配置されます。&lt;/p&gt;

&lt;h3 id=&#34;4-その他-細かい調整&#34;&gt;4. その他、細かい調整&lt;/h3&gt;

&lt;p&gt;対象のView間のマージンや、行（列）の最大数、Viewの配置場所などの細かい部分の指定ができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app:flow_horizontalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_verticalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_verticalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_verticalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalAlign = &amp;ldquo;start|end|center&amp;rdquo; (default center)&lt;/li&gt;
&lt;li&gt;app:flow_verticalAlign = &amp;ldquo;top|bottom|center|baseline” (default center)&lt;/li&gt;
&lt;li&gt;app:flow_maxElementsWrap = &amp;ldquo;integer&amp;rdquo; (default : 0, not applied)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にMotionLayoutとFlowの使いかたについて見ていきます。&lt;/p&gt;

&lt;h2 id=&#34;motionlayout&#34;&gt;MotionLayout&lt;/h2&gt;

&lt;p&gt;これは通常のMotionLayoutの使い方と一緒です。Flowの値を変更してあげればよいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;MotionScene xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:motion=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&amp;gt;

  &amp;lt;Transition
    android:id=&amp;quot;@+id/transition&amp;quot;
    motion:constraintSetEnd=&amp;quot;@+id/end&amp;quot;
    motion:constraintSetStart=&amp;quot;@+id/start&amp;quot;
    motion:duration=&amp;quot;1000&amp;quot; /&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/start&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;0dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;horizontal&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/end&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;200dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;vertical&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;
&amp;lt;/MotionScene&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのアニメーションになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/qn9Xbhr9pqrmsJEzQ2YfhzSnJS1I9HpR_s6_UrCSxoqRHQQQ32unFB3G4ls72OuMLuIclSZ89-8=w246-h437-no&#34; width=400&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ConstraintLayout alpha5になってFlowが入った。かなり便利に使えそう

&lt;ul&gt;
&lt;li&gt;いろいろ指定できるので、実際に触って動かしてみるのが良いと思います。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;betaはGoogle I/O前後に来るらしいので、正式版までもう少し😃&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/camaelon/constraintlayout-2-dot-0&#34;&gt;ConstraintLayout 2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://androidstudio.googleblog.com/2019/04/constraintlayout-200-alpha-5.html&#34;&gt;ConstraintLayout 2.0.0 alpha 5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: プロパティの変更を検知する</title>
      <link>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</link>
      <pubDate>Wed, 24 Apr 2019 02:21:47 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</guid>
      <description>

&lt;p&gt;オブジェクト自身の変更ではなく、対象のオブジェクトが持つプロパティの変更を汎用的に検知する方法の紹介です。&lt;/p&gt;

&lt;p&gt;次が、この記事で紹介したいコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 1つのプロパティの変更を検知したい
fun &amp;lt;S, A1&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(prop1: KProperty1&amp;lt;S, A1&amp;gt;): LiveData&amp;lt;A1&amp;gt; =
  this
    .map { prop1.get(it) }
    .distinctUntilChanged()

// 2つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;
): LiveData&amp;lt;Pair&amp;lt;A1, A2&amp;gt;&amp;gt; =
  this
    .map { prop1.get(it) to prop2.get(it) }
    .distinctUntilChanged()

// 3つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2, A3&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;,
  prop3: KProperty1&amp;lt;S, A3&amp;gt;
): LiveData&amp;lt;Triple&amp;lt;A1, A2, A3&amp;gt;&amp;gt; =
  this
    .map { Triple(prop1.get(it), prop2.get(it), prop3.get(it)) }
    .distinctUntilChanged()

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KProperty1はKotlinが提供しているインターフェースで、プロパティの値を取得することが出来ます。
それと、LiveData ktxに追加された&lt;code&gt;distinctUntilChanged&lt;/code&gt;を組み合わせることで、汎用的に特定のプロパティの変更を検知することが可能です。&lt;/p&gt;

&lt;p&gt;この記事ではLiveDataを使いましたが、RxJavaやCoroutineでも同じような感じで書けると思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次にサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Presenter(initializeUser: User = User(name = &amp;quot;init&amp;quot;, age = 0)) {
  val user = MutableLiveData&amp;lt;User&amp;gt;(initializeUser)

  // nameの変更を検知する
  val watchUserName = user.watch(User::name)
  // ageの変更を検知する
  val watchUserAge = user.watch(User::age)
}

--- 以下main ---

val presenter = Presenter()

// 監視
presenter.watchUserName.observe(this) {
  Log.d(&amp;quot;watchUserName&amp;quot;, it)
}
presenter.watchUserAge.observe(this) {
  Log.d(&amp;quot;watchUserAge&amp;quot;, it.toString())
}

// 適当にUserを更新
presenter.user.postValue(User(name = &amp;quot;posted1&amp;quot;, age = 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、Userのnameプロパティだけが変更されているので、&lt;code&gt;presenter.watchUserName&lt;/code&gt;に登録したObserverのみが発火します。
変更が加わったプロパティだけを無事検知することができました😃&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多くのデータを持ったオブジェクトの一部の変更のみ検知したい時に使うと便利かもしれない😋&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ConstraintLayoutのImageFilterViewって単体でも使えるんやなって</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</link>
      <pubDate>Mon, 15 Apr 2019 13:17:53 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</guid>
      <description>

&lt;p&gt;ConstraintLayout 2.0.0-alphaから&lt;code&gt;ImageFilterView&lt;/code&gt;クラスが追加されました。今まで、MotionLayoutと一緒に使うものだから、使い所限られそうだなぁ〜と思っていたのですが、単体でも使えそうだったので、その報告記事になります。&lt;/p&gt;

&lt;p&gt;この記事ではConstraintLayout 2.0.0-alpha4を使っています。&lt;/p&gt;

&lt;h2 id=&#34;角丸にする&#34;&gt;角丸にする&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;round&lt;/code&gt;属性から指定する事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
  app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/w0ztp5sD9OXMBfDSR_hocSPM08c9eHvIQTHCSpZGbyQF7ci0lcS265HwEAPHRnvY4Q0ABX5soYO8nIB_3wSpdiDek1N2F1X1m6fkDOevgydQ5IXXyVDVMqriB_Odu-szOHdfZIJ0YCLYUEOkXNEwDc8kRgooA3eeHJMqxl3urpG4siDCaJqsnhkP4MfKH3gtqJlsw6ol7Hd27L1eyexPod5mnOz2edWIS12Ogf9yIaWkVU2or1yyoHqUlsqr8xPyChg1gNYQ1cTzwBD9u1_xewQzJyGCn4ae3jqg4CnJ-L6VmJ08KrRVA9xWGYQ14u_r6uu-dD48sLdb28XuQ0egxLC-KhjxkIKHR3cCnlz-orcZ7AeKFMHwuG74fPAXXZ4Pyry2UmYDFSTXCL0StUi7h3wbhETX8u_-e9vIePPSn-1ZTLGGaLfbJTn4Vp8gZqrU7mWjoUVx0tzNlljfc47SJCN7RfFddWlLQFrtjQc7mGCmj9GLFZcJcRrKxLzp7yAOQo4DxWAY6PMcN-LNup3v4uH8PtUW9r9I2KqbmtW8SaBb9EJOMHlGsbcFtughox_G1d7bBUpZeqTnteU3bUldjiUywQTA6lJEbH68mjpoLMWkGmGjVJN9cmszjKCvd1LYcaJq89HCmskyfCwlMtiNItgP6zFCY7M7uQcmD5d62VGnlXHDXKvsYfhHjC5WtwUmoWzIbBzwD8F3YEdfDlxL6Tq0uA=w1067-h530-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;彩度&#34;&gt;彩度&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;saturation&lt;/code&gt;属性から設定することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:saturation=&amp;quot;0.1&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/wCPl0zHaivuj-PtkvE-HrvkIgFWqBwlz5Gr614mGfxvQB4U7IsvIbMuQVI8sK1RRtgRJwctepaxU8rnOuY1MATEXZq3S3NoNqNdcU4ULpRFRYGRaFcWpWtbd70YBYB7vOkH9Qx1hEt6qkXIKn-olrNDjjro9LlxEs0SjkvtxsyjQOgf3V0hlKH_-0ip6Zy0zk_zeWMiworGc61jHd3E4NfjgdoiCR8Xjg3qtjDWLobHAPT7HGTNWBC6gv0-vkz_xHxM5FZyviTAvLkgDkkHeJh3m-YSbRBDFIZ1C4-LIqt67gABi7sgfT7w6A5r_RSNTUqkTZvRd7ZUx1LtM6SPcpDSTCs-rZFSpYKkU4suecLswHOKDLMUh1EG_K_h_mSbCZgdFEQPhvr5hP9p-EN8WMMuMdJZjpPtxi1Hw6gY0fw6iuHMHJaVb4Kbjyfi5NeJVFZnf6-WBdoieQX438Spo7weidl7HD1mVGtIbGdb30h3FDtjHUoFl6kHM3myZxWq9DN83xHlsvPOQY-7TOPWbqBOWxLy8hhbxA3Dz7qhz-x0O1O8fBrYEpDQKJprdLNhwsy1s_sH37YBP0wadBUchOGA2f0LS_bLTKLrkE2oJx2XS38yCAbfGi3QW411W_Hg6S6DDYuYsrPRTxC2bw0BmCjadyxV3AOmX=w1080-h502-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;コントラスト&#34;&gt;コントラスト&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;contrast&lt;/code&gt;属性から設定することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:contrast=&amp;quot;0.5&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/wnE8okXNQjzyLwlW0wHmGZreCJI1-BjgPT_ofryDbrDC1Zfz1qD3gTpGKPhCSKYpkPXRkkbpbBuGHccTxqgJG7ywcdpuWXfgIY71nquRVKmGT5YdoojjC18cQj3fRdiEQyXw2t-pXD-Pe-wBqsTrFJ6ZAk25RakjtTF8vrPMH6PvC8InmBGx1HaUWKkYO1x3umMz9ORGMJB0T9qZ8KFspUhMW05QlmiVQXrbqDD50OCXrP_HTG8ACwW1CL5XuMYAmgP6sH24zm48cYY3ABbxVQFyLOkPKx-dyFzQ1pqjzwOncnZZqvTHp6ykd3kzJwd6PYoyX2-3HMPtDtTjW2GJNUTo23MLZmEqTwDLEZP7ibAmcoivYw6IpSoa05AcT_aLD-fjEDtpZIGCiQDrVjxb32fBgaA6h6nqjbRClMN0ZpChFxsJOAP9zgC_SkAHBeGpAczvNfyPxOzR29-eFGf9q4p59axmdyFIls_y7h3W3vPEvZK_JYFe38avYSvru4C1HtU9CRslj2jvahdNN__ZblA7wQznj-MUnIdX5E1KfIP0vsiy1kFm7tCHLWyh5FZmf0sxxTCyQToL366hbXvgPsu-e4LTwuP3S1saYOZe2WVClG6cTiv98nqC8WxWO_FtosHZaY6Davi43S_VeO0kTsUn4NPDx4H5=w1080-h516-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;暖色-寒色&#34;&gt;暖色、寒色&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;warmth&lt;/code&gt;属性から、暖色、寒色？を設定することできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:warmth=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/a0aHhdG12uZoHpvFU8nCsxDwlnJt-ICgmdl2QhQi8GgeEifaDtLzM-xmwI8DmyB-Vqnii-ZQ4QEAvnUxqwef5P--45HBrSIFbRTT98XcfntFmaZYeduDAdNoWCMDTVXdz97uUfYewOF4p0fnKAvUbHoqjXFTdKU0lVLyTHUyyuNma6vx1qw9LE_Kri7xqevLstb6f5gvbCWsVmNuo_J-FlW133j7PK89zd-JbwYHf4B9L1tvo80Lo2eMKLjLvNyU26xFA0f88BBJeeT-Wh6IWm1_gTnEqBQlE9xrJvGTI93VjVE8SBYXSnmUN7Q9Qm5ZpY-dZLRr9H1Bvqju8O7nNcWPWdtLBLxyirDJ1fZlOJWqqXvzw1l4vncpPBNM-WfyCaY7TIxxTOD2Czvl8G9fNFs9ZQCehmvildHx088tpkB9IgMFanB9j1IZjzoP_c0ipaw_ayBR69dNNSUWVmWp5xlPCEjNXA7xi_JfruaHxhvMmocOkNKhQVxJ39BQv3KVWFIYHmZdDxnf7ZKj6iZ56V8eyb9E3R25V0_rljkAHLEC7cEEFjs9H7h7GDFAh71zbybA7bqauWB0VjRBuHDQ2eSpwKRSJh3wqLpArzKbjOkjiP9RNwGeI-CWcyQl7HCileL11hSbLem3GINlUkTLPiVoeSnMl0yG=w1080-h510-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:warmth=&amp;quot;0.5&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/Gac2-_7RbmYctobF_eztsBTlTGVNMNHor3tJYk-awVNB0Bz9rAiTfb_jkwLMd3JuKPJZd1B8tz4UDfITyw_2rUBAM2ji0bt5FYPvm9kebLZ0I1Wujn4-Ovv51XPdQ_61BNNfnPbdIztP408lWkPpkTJlbKe7JZcrjG-Ia2RZgnUo0z77LbPO56VXFlQSR9JvN8KEzzs4n2VaE0xmA_LBQ2elyirTzYWDlWiUs__MuD0e5JoqjXxfn6HM-ORGPb--PZeCFaUKUyizAxI7Vd_C27vGwTBEFwE3ITF-bT5e1HQW2J1QwrwygWnDMUnZBaoaHGjMDmKAs-nPRmqFGCrNSKYWJs6yKEQN4CEkj_Kk4E5ldCioCZiQIK4RtsjtEuQT1_-WOE_AGSh0eSUzbIFkDG5rofk-9c_e06-S8Nba-t8r8U7h0dVNOGMmmqmU5P3gcomoZUDJVZ6HJi_Q2mVUVsMQlZA6DKSwMRlivlvTHI1KbpyGxIBPPQrfnFp7TzLdh3f3MmPWXT3e3a47UQlnOxLPH6h1ZcMPoHXf8LTQ8y2duu9xzQ1gyxvYS8_o8Rit512VGxqCdcyt1J5y5i3Suq4fq7eezfg2tdjwR64GUjZbWEbWn57KNSiZIPmrQ2GC9p1m_GYAYg38KAjRHUDNvhLrJS4lT7sA=w1080-h513-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;クロスフェード&#34;&gt;クロスフェード&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;crossfade&lt;/code&gt;属性から設定することが出来ます。ただ、この属性はMotionLayoutと一緒に使うもので、単体では使わないと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ImageFilterView&lt;/code&gt;、単体でも結構使いどころあるかも😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger 2.22にFactoryクラスが導入されました</title>
      <link>https://satoshun.github.io/2019/04/dagger-component-factory/</link>
      <pubDate>Sun, 07 Apr 2019 06:04:22 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/dagger-component-factory/</guid>
      <description>

&lt;p&gt;Dagger 2.22からComponent.Factoryクラスが導入されました。この記事では、簡単な使い方とユースケースを見ていきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;component-factoryとは&#34;&gt;Component.Factoryとは?&lt;/h2&gt;

&lt;p&gt;実は、Component.FactoryでやれることはComponent.Builderクラスとほぼ変わりません。&lt;/p&gt;

&lt;p&gt;例えば、次のArticlePresenterインスタンスを生成する2つのコードは本質的にやっていることは同等です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Factoryを使う場合
@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Factory
  interface Factory {
    fun create(
      @BindsInstance id: Long
    ): AppComponent
  }
}

val component = DaggerAppComponent
  .factory()
  .create(50)
val presenter = component.presentere

---

// Builderを使う場合
@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Builder
  interface Builder {
    @BindsInstance fun bindId(id: Long): Builder
    fun build(): AppComponent
  }
}

val component = DaggerAppComponent
  .builder()
  .bindId(50)
  .build()
val presenter = component.presenter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのコードは、AppComponentにIntをBindsしています。渡し方、定義の仕方は違いますが、やっていることは変わりません。&lt;/p&gt;

&lt;p&gt;ただし、Factoryを使うパターンはstatelessです。
Builderはセッターメソッドを使ってフィールドの状態を変えていきますが、Factoryはcreateメソッドから必要な値を渡します。&lt;/p&gt;

&lt;h2 id=&#34;ユースケース&#34;&gt;ユースケース&lt;/h2&gt;

&lt;p&gt;次に、Factoryのユースケースを考えます。そもそもこの機能は &lt;a href=&#34;https://github.com/google/dagger/issues/935&#34;&gt;Feature request: factory method in components for assisted injection&lt;/a&gt; を解決したいモチベーションがあります。&lt;/p&gt;

&lt;p&gt;例えば、次のコードをDaggerで解決したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ArticlePresenter {
	...
	ArticlePresenter(long articleId, ArticleService articleService) {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;longの値を後から決めたいときには、今までだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AssistedInject&lt;/li&gt;
&lt;li&gt;AutoFactory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のどちらかを使っていました。これに、今回のdagger.Factoryが加わりました。
dagger.Factoryを使うと、このコードを解決することが出来ます！&lt;/p&gt;

&lt;p&gt;ただし、現状のdagger.Factoryだと多くのボイラープレートコードが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Factory
  interface Factory {
    fun create(
      @BindsInstance id: Long
    ): AppComponent
  }
}

val component = DaggerAppComponent
  .factory()
  .create(50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssistedInjectとAutoFactoryを使えば、ここらへんのボイラープレートコードを緩和することが出来ます。
なので、このようなパターンのコードがよく出てくるようなプロジェクトは、AssistedInject or AutoFactoryの導入を検討しても良いと思います。pure Daggerで運用したい、もしくはそこまでこのパターンが出てこないなら、dagger.Factoryを使うのが良いかと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;dagger.Factoryが導入された

&lt;ul&gt;
&lt;li&gt;ただし、AutoFactoryやAssistedInjectのほうが多機能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DaggerFactoryExample&#34;&gt;satoshun/DaggerFactoryExample&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあれば&lt;a href=&#34;https://twitter.com/stsn_jp&#34;&gt;Twitter&lt;/a&gt;などから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>DataBindingとActivityのコンストラクタ Layout Id指定を一緒に使う</title>
      <link>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</link>
      <pubDate>Thu, 04 Apr 2019 00:46:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</guid>
      <description>

&lt;p&gt;JetpackのActivityとFragmentのコンストラクタに、Layout Idが指定できるようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/activity#1.0.0-alpha06&#34;&gt;Activity Version 1.0.0-alpha06&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/fragment#1.1.0-alpha06&#34;&gt;Fragment Version 1.1.0-alpha06&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これは、次のように使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(R.layout.main_act)

class MainFragment : Fragment(R.layout.main_frag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activityの場合は、setConentViewが。Fragmentの場合はonCreateViewがそれぞれ省略することが出来ます。&lt;/p&gt;

&lt;p&gt;ここからが本題です。これをDataBindingと一緒に使うなら、次のようになるかなと思います。&lt;/p&gt;

&lt;h3 id=&#34;activityの場合&#34;&gt;Activityの場合&lt;/h3&gt;

&lt;p&gt;まずはActvityの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 拡張関数を定義しておく
fun &amp;lt;T : ViewDataBinding&amp;gt; ComponentActivity.bindView(): T =
  DataBindingUtil.bind(getContentView())!!

private fun Activity.getContentView(): View =
  findViewById&amp;lt;ViewGroup&amp;gt;(android.R.id.content)[0]


// MainActivity.kt
class MainActivity : AppCompatActivity(R.layout.main_act) {
  private lateinit var binding: MainActBinding

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = bindView()
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、Activityの場合に限り、by lazyと組み合わせることも可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(R.layout.main_act) {
  private val binding by lazy { bindView&amp;lt;MainActBinding&amp;gt;() }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fragmentの場合&#34;&gt;Fragmentの場合&lt;/h3&gt;

&lt;p&gt;次にFragmentの例になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 拡張関数を定義しておく
fun &amp;lt;T : ViewDataBinding&amp;gt; Fragment.bindView(): T = DataBindingUtil.bind(view!!)!!


// MainFragment.kt
class MainFragment : Fragment(R.layout.main_frag) {
  private lateinit var binding: MainFragBinding

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    binding = bindView()
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlinの拡張関数でやるなら、こんな感じになると思ってます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタにLayoud Idが指定できるようになり、それを使いたいなら、DataBindingの取得の仕方が少し変わりそう

&lt;ul&gt;
&lt;li&gt;Layout Id指定は必須ではないので、必ずしも使う必要はないと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;KotlinのDelegationを使えば、もっといい感じに書けるかもしれない&lt;/li&gt;
&lt;li&gt;サンプルは&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingContentLayoutIdExample&#34;&gt;satoshun/DataBindingContentLayoutIdExample&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>OkHttp: Java to KotlinのPRを見て勉強する</title>
      <link>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</link>
      <pubDate>Sun, 24 Mar 2019 02:36:27 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</guid>
      <description>

&lt;p&gt;OkHttpがKotlin化をするというISSUEが立てられました。
&lt;a href=&#34;https://github.com/square/okhttp/issues/4723&#34;&gt;Upgrade OkHttp 3 to Kotlin and call it OkHttp 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これの是非についてはさておき。現状、いくつかのJavaコードがKotlinへと置き換わっているので、それらのレビューで気になったこと、知らなかったこと、忘れがちなことを勉強がてらまとめたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;checknotnullを使うかどうか&#34;&gt;checkNotNullを使うかどうか&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266693078&#34;&gt;could also be &lt;em&gt;code&lt;/em&gt; no preference myself&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kotlinの標準ライブラリに、&lt;a href=&#34;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html&#34;&gt;checkNotNull&lt;/a&gt;があります。
これは、値がnullなら&lt;code&gt;IllegalStateException&lt;/code&gt;例外を投げるものです。&lt;/p&gt;

&lt;p&gt;以下のコードは同じ意味を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val state = someState ?: throw IllegalStateException(&amp;quot;State must be set beforehand&amp;quot;)

val state = checkNotNull(someState) { &amp;quot;State must be set beforehand&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、&lt;code&gt;no preference myself&lt;/code&gt;と言っている通り、使うかどうかはプロジェクトで分かれそうです。
事前に使うかどうかを、決めておくと揉めなく良さそうだと思いました。&lt;/p&gt;

&lt;h2 id=&#34;命名はto-が慣用的&#34;&gt;命名はto***が慣用的&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266693257&#34;&gt;idiomatic naming would be toUrl on the Kotlin side&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OkHttpでは、HttpUrlをURLに変換するためのメソッドとして&lt;code&gt;fun url(): URL&lt;/code&gt;が定義されています。しかし、&lt;code&gt;fun toUrl(): URL&lt;/code&gt;のほうがKotlinっぽいよと指摘がありました。&lt;/p&gt;

&lt;p&gt;確かに、言われてみるとAtoBクラス変換のメソッド名は、&lt;code&gt;to***&lt;/code&gt;が多い気がします。ただし、今回は下位互換を保つために、一旦この修正は入りませんでした。&lt;/p&gt;

&lt;h2 id=&#34;constを使う&#34;&gt;constを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266695491&#34;&gt;discussion link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;constを使うと、Compile Time Constantsとなり、付けない場合に比べ効率的に動作します。ただし、プリミティブか、String型のみに有効です。&lt;/p&gt;

&lt;p&gt;より詳しくは&lt;a href=&#34;https://kotlinlang.org/docs/reference/properties.html#compile-time-constants&#34;&gt;公式ドキュメント&lt;/a&gt;で。&lt;/p&gt;

&lt;p&gt;constを付けたほうが良いことは知っていたのですが、公式ドキュメントを読んだことがなかったので勉強になりました。&lt;/p&gt;

&lt;h2 id=&#34;事前計算済みプロパティにのみ依存している場合は-事前計算済みプロパティにを使う&#34;&gt;事前計算済みプロパティにのみ依存している場合は、事前計算済みプロパティにを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266702974&#34;&gt;scheme is a val, so this can just be a precomputed property without the get()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;isHttpsプロパティは最初、get()で定義していたんですが、isHttpsで使っているschemeプロパティがvalなので、get()が取り除かれました。&lt;/p&gt;

&lt;p&gt;事前計算出来るプロパティは事前に計算しておく方針のようです。そのほうが、無駄なメソッドが定義されないので、良いという判断なのでしょうか？&lt;/p&gt;

&lt;h2 id=&#34;プロパティ-get-jvmnameはより慣用的&#34;&gt;プロパティ + get:JvmNameはより慣用的&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266697339&#34;&gt;property + @getJvmName(&amp;ldquo;size&amp;rdquo;) seems more idiomatic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;単純かつ副作用がない関数はプロパティのほうがKotlinっぽいです。さらに、&lt;code&gt;@get:JvmName&lt;/code&gt;を使うことで、Javaからスムーズに使うことが出来ます、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun size(): Int = encodedNames.size

@get:JvmName(&amp;quot;size&amp;quot;)
val size get(): Int = encodedNames.size
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;valをうまく使うことが、Kotlinっぽさを出すのに大切なんだなって&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkNotNull&lt;/code&gt;は、スコープ関数と一緒で、ある程度使い方の認識を合わせないとコードの一貫性が無くなりそう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;今回の記事を書くために調べたコミット&#34;&gt;今回の記事を書くために調べたコミット&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4741&#34;&gt;Convert some basic types to Kotlin #4741&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745&#34;&gt;HttpUrl in Kotlin #4745&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4749&#34;&gt;Kotlin Platform refactor #4749&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4751&#34;&gt;Refactor exceptions and static classes to Kotlin #4751&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: コンストラクタ呼び出しっぽく関数やcompanion objectを使う</title>
      <link>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</link>
      <pubDate>Tue, 19 Mar 2019 12:31:05 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</guid>
      <description>

&lt;p&gt;KotlinではJavaと異なり、コンストラクタ呼び出しの時に&lt;code&gt;new&lt;/code&gt;キーワードが必要ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A
...
val a = A()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よって、次のように関数をコンストラクタのように使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Coroutine Jobの定義
@Suppress(&amp;quot;FunctionName&amp;quot;)
public fun Job(parent: Job? = null): Job = JobImpl(parent)
...
val job = Job()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、次のようにcompanion object + operator invokeを使うことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ref: https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter
class CoroutineCallAdapterFactory private constructor() : CallAdapter.Factory() {
  companion object {
    @JvmStatic @JvmName(&amp;quot;create&amp;quot;)
    operator fun invoke() = CoroutineCallAdapterFactory()
  }
}
...
val factory = CoroutineCallAdapterFactory()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JobImplのような実装クラスを隠したいときに便利&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>