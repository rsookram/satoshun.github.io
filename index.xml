<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Fri, 16 Nov 2018 00:00:00 UTC</updated>
    
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>

&lt;p&gt;Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、
そんな夢をみたAndroidエンジニアは数多くいると思います。&lt;/p&gt;

&lt;p&gt;この記事ではそんな夢を叶える方法を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ConstructorInjectionExample&#34;&gt;サンプルコードはここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;fragmentfactory&#34;&gt;FragmentFactory&lt;/h2&gt;

&lt;p&gt;Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment : Fragment() {
  @Inject lateinit var userHandler: UserHandler
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコンストラクタインジェクションにしたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment @Inject constructor(
  private val userHandler: UserHandler
) : Fragment() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;androidx.fragment:fragment:1.1.0-alpha01&lt;/code&gt;から、FragmentFactoryが追加されました!!
これを使うことでコンストラクタインジェクションが可能になります。&lt;/p&gt;

&lt;p&gt;MainFragmentインスタンスを生成する&lt;code&gt;FragmentFactory&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragmentFactory @Inject constructor(
  private val fragment: Provider&amp;lt;MainFragment&amp;gt;
) : FragmentFactory() {
  override fun instantiate(
    classLoader: ClassLoader,
    className: String,
    args: Bundle?
  ): Fragment {
    if (className == MainFragment::class.java.name) {
      return fragment.get()
    }
    return super.instantiate(classLoader, className, args)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FragmentFactory.instantiate&lt;/code&gt;をoverrideし、そこでMainFragmentのインスタンスを生成します。&lt;/p&gt;

&lt;p&gt;最後に、作成した&lt;code&gt;MainFragmentFactory&lt;/code&gt;をActivityの&lt;code&gt;FragmentManager&lt;/code&gt;に登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  @Inject lateinit var fragmentFactory: MainFragmentFactory

  override fun onCreate(savedInstanceState: Bundle?) {
    DaggerAppComponent.create().inject(this)
    supportFragmentManager.fragmentFactory = fragmentFactory

    super.onCreate(savedInstanceState)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SupportFragmentManager.fragmentFactory&lt;/code&gt;に登録します。
これで、Fragmentが生成されるとき&lt;code&gt;MainFragmentFactory&lt;/code&gt;がフックされます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SupportFragmentManager.fragmentFactory&lt;/code&gt;にFactoryを登録するタイミングは&lt;code&gt;super.onCreate(savedInstanceState)&lt;/code&gt;の前が良いと思います。
それは&lt;code&gt;super.onCreate&lt;/code&gt;のタイミングで以前のFragmentが復元されるためです。
復元されるタイミングで適切なFactoryがないとクラッシュするので、復元する前で登録する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;layoutinflater-factory&#34;&gt;LayoutInflater.Factory&lt;/h2&gt;

&lt;p&gt;次にViewです。&lt;code&gt;LayoutInflater.Factory&lt;/code&gt;が定義されています。
これを使うことでカスタムのコンストラクタを持ったViewを定義することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainTextView(
  context: Context,
  private val userHandler: UserHandler
) : TextView(context) {
  class Factory @Inject constructor(private val userHandler: UserHandler) {
    fun create(context: Context): MainTextView {
      return MainTextView(context, userHandler)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;カスタムのコンストラクタを持ったViewは通常の方法ではインスタンスを生成できませんが、
&lt;code&gt;LayoutInflater.Factory&lt;/code&gt;を使うことで、インスタンスを生成できるようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainLayoutInflaterFactory @Inject constructor(
  private val factory: MainTextView.Factory
) : LayoutInflater.Factory {
  override fun onCreateView(name: String, context: Context, attrs: AttributeSet?): View? {
    if (name == MainTextView::class.java.name) {
      return factory.create(context)
    }
    return null
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LayoutInflater.Factory.onCreateView&lt;/code&gt;をoverrideし、&lt;code&gt;MainTextView&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;p&gt;最後に、作成した&lt;code&gt;MainLayoutInflaterFactory&lt;/code&gt;をActivityの&lt;code&gt;layoutInflater.factory&lt;/code&gt;に登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  private lateinit var layoutInflaterFactory: MainLayoutInflaterFactory

  override fun onCreate(savedInstanceState: Bundle?) {
    DaggerAppComponent.create().inject(this)
    layoutInflater.factory = layoutInflaterFactory

    super.onCreate(savedInstanceState)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activityの&lt;code&gt;LayoutInflater.factory&lt;/code&gt;に登録します。登録するタイミングはsetContentViewの前が良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;appcomponentfactory&#34;&gt;AppComponentFactory&lt;/h2&gt;

&lt;p&gt;次にActivityです。
Activityに依存関係を注入する時、普通にやると以下のコードになると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : Activity() {
  @Inject lateinit var presenter: UserPresenter
  @Inject lateinit var analytics: Analytics
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコンストラクタインジェクションにしたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity @Inject constructor(
  private val presenter: UserPresenter,
  private val analytics: Analytics
): Activity() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、この書き方はうまくいきません。なぜならActivityインスタンスはシステム側で自動的に生成されるためです。
カスタム定義のコンストラクタだと、システム側でインスタンスを生成することが出来ません。&lt;/p&gt;

&lt;p&gt;これを解決するべく、API28からAppComponentFactoryというクラスが追加されました!!&lt;/p&gt;

&lt;p&gt;MainActivityインスタンスを生成する&lt;code&gt;AppComponentFactory&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Suppress(&amp;quot;unused&amp;quot;)
class MainAppComponentFactory : AppComponentFactory() {
  private lateinit var application: App

  override fun instantiateActivityCompat(
    cl: ClassLoader,
    className: String,
    intent: Intent?
  ): Activity {
    if (className == MainActivity::class.java.name) {
      return application.appComponent.mainActivity
    }
    return super.instantiateActivityCompat(cl, className, intent)
  }

  override fun instantiateApplicationCompat(cl: ClassLoader, className: String): Application {
    application = super.instantiateApplicationCompat(cl, className) as App
    return application
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にAndroidマニフェストに&lt;code&gt;MainAppComponentFactory&lt;/code&gt;を登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;...
  &amp;lt;application
    android:allowBackup=&amp;quot;true&amp;quot;
    android:name=&amp;quot;.App&amp;quot;
    android:appComponentFactory=&amp;quot;com.github.satoshun.example.sample.MainAppComponentFactory&amp;quot;
    android:icon=&amp;quot;@mipmap/ic_launcher&amp;quot;
    android:label=&amp;quot;@string/app_name&amp;quot;
    android:roundIcon=&amp;quot;@mipmap/ic_launcher_round&amp;quot;
    android:supportsRtl=&amp;quot;true&amp;quot;
    android:theme=&amp;quot;@style/AppTheme&amp;quot;
    tools:replace=&amp;quot;android:appComponentFactory&amp;quot;&amp;gt;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AppComponentFactory.instantiateActivityCompat&lt;/code&gt;をoverrideし、&lt;code&gt;MainActivity&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;p&gt;これで、カスタムのコンストラクタを持ったActivityインスタンスを生成することが出来ます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fragment、Viewは今からでも使い始めることができる。Daggerなどのライブラリと組み合わせると最高☆&lt;/li&gt;
&lt;li&gt;AppComponentFactoryはAPI28からなので&amp;hellip;5年後くらいでしょうか😢&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ConstructorInjectionExample&#34;&gt;サンプルコードはここです&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;何か疑問点があれば、twitterやサンプルコードのISSUEなどで聞いてください😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Contracts &#43; 拡張関数でより便利に</title>
      <link>https://satoshun.github.io/2018/11/more_convenient_contracts/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/more_convenient_contracts/</guid>
      <description>

&lt;p&gt;Kotlin 1.3.0からContractsが実装されました。
Contractsを使うことで、関数がどのような振る舞いをするか、どういう効果をもたらすかを定義（契約）することが出来ます。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;isNullOrEmpty&lt;/code&gt;メソッドがfalse返すなら、
Contractsによりnullでないことが保証されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a: String? = ...
if (!a.isNullOrEmpty()) {
    println(a.length) // !!が必要ない
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Contractsがない時代だと呼び出し元で&lt;code&gt;isNullOrEmpty&lt;/code&gt;がどんな振る舞いをするかを知るすべがなかったので、
&lt;code&gt;!!&lt;/code&gt;をつける必要があったのですが、Contractsによりnullでないことが保証できるので、&lt;code&gt;!!&lt;/code&gt;を省略できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isNullOrEmpty&lt;/code&gt;の実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@kotlin.internal.InlineOnly
public inline fun CharSequence?.isNullOrEmpty(): Boolean {
    contract {
        returns(false) implies (this@isNullOrEmpty != null)
    }

    return this == null || this.length == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;contract&lt;/code&gt;はDSL（関数）として定義されています。
これを呼び出し、そのブロックの中でこの関数が満たす振る舞いを定義する事ができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isNullOrEmpty&lt;/code&gt;の場合は&lt;code&gt;returns(false) implies (this@isNullOrEmpty != null)&lt;/code&gt;が契約として定義されています。&lt;/p&gt;

&lt;p&gt;これは、&lt;code&gt;「returns(false)&lt;/code&gt;: falseを返すなら &lt;code&gt;(this@isNullOrEmpty != null)&lt;/code&gt;: 自分自身がnullじゃない」という意味になります。
なので呼び出し元ではfalseが返ってきたら、nullではないことが保証されるので、smartcastにより&lt;code&gt;!!&lt;/code&gt;をつける必要がなくなるわけです。&lt;/p&gt;

&lt;p&gt;なので、例えば&lt;code&gt;T.isEmpty(t: T?): Boolean&lt;/code&gt;のようなメソッドがあり、ついでにnullチェックもこの関数の中でやっているようなときは、
contractを定義することでより使いやすい関数にすることが出来ます。&lt;/p&gt;

&lt;p&gt;他の例を見てみます。スコープ関数&lt;code&gt;apply&lt;/code&gt;の実装は次になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@kotlin.internal.InlineOnly
public inline fun &amp;lt;T&amp;gt; T.apply(block: T.() -&amp;gt; Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;関数内では、&lt;code&gt;callsInPlace(block, InvocationKind.EXACTLY_ONCE)&lt;/code&gt;が契約として定義されています。
これは、&lt;code&gt;block&lt;/code&gt;関数が必ず1度呼び出されることを意味します。
これにより、以下のように書くことが可能になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a: String
hoge.apply {
    a = &amp;quot;hoge&amp;quot;
}
println(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;関数は1度しか呼び出されないので&lt;code&gt;val a: String&lt;/code&gt;の初期化が、&lt;code&gt;apply&lt;/code&gt;関数内で正しく行われることが保証されます。
Kotlin 1.3.0以前のcontractが内時代では上記のコードはコンパイルエラーになっていたのですが、
contractにより、実行することが可能になりました。&lt;/p&gt;

&lt;p&gt;今まで見てきたのはKotlinのスタンダートライブラリに入っていた関数ですが、カスタムで定義することも可能です。
今回は例として、&lt;code&gt;ActivityScenario.onActivity&lt;/code&gt;メソッドをcontract + 拡張関数を使ってより便利にしたいと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/android/android-test/blob/f2f3589c9d6e2ff5740117192cb7e13bd8873a0f/core/java/androidx/test/core/app/ActivityScenario.java#L500&#34;&gt;ActivityScenario.onActivity&lt;/a&gt;メソッドは、callbackを登録すると、Activityの準備ができたタイミングでcallbackが叩かれます。そして、この&lt;code&gt;onActivity&lt;/code&gt;メソッドは一度しかコールされず、実行したスレッドをブロックします。なので、前述した&lt;code&gt;apply&lt;/code&gt;関数と同じcontractを書くことが可能です。&lt;/p&gt;

&lt;p&gt;以下のように拡張関数を書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UseExperimental(ExperimentalContracts::class)
fun &amp;lt;T : Activity&amp;gt; ActivityScenario&amp;lt;T&amp;gt;.onActivity2(block: (T) -&amp;gt; Unit) {
  contract {
    callsInPlace(block, InvocationKind.EXACTLY_ONCE)
  }
  onActivity {
    block(it)
  }
}


// コンパイルエラーにならない!!
val activity: Activity
scenario.onActivity2 {
    activity = it
}
println(activity)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@UseExperimental(ExperimentalContracts::class)&lt;/code&gt;をつけることで、ユーザ定義のcontractを定義することが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1度しかコールされないcallbackや、関数内でnullチェックをする場合はcontractを使うと超便利になるかも&lt;/li&gt;
&lt;li&gt;拡張関数を新しく定義することで、既存のメソッドをよりkotlin-friendlyなメソッドにできるかも!?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md&#34;&gt;https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: デバッグ時にMoshi、Daggerリフレクションライブラリを使いビルド時間を短縮する</title>
      <link>https://satoshun.github.io/2018/11/debug_reflection/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/debug_reflection/</guid>
      <description>

&lt;p&gt;ビルド時間の短縮は開発効率を上げる大きな要素です。
極力kapt（アノテーションプロセッサー）を使わなくすることで、ビルド時間を短縮出来ます。
アノテーションプロセッサーを使ったライブラリは、アノテーションプロセッサーを使わない、
リフレクションを用いたデバッグ用の機能を提供していることがあります。&lt;/p&gt;

&lt;p&gt;今回は、MoshiとDaggerリフレクションライブラリの紹介をします。
Daggerリフレクションは絶賛開発中 + 公式ではないので、機能がかなり制限されている、どういう未来が待っているかわからない点に注意してください。&lt;/p&gt;

&lt;p&gt;検証に用いた&lt;a href=&#34;https://github.com/satoshun-android-example/DebugReflectExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;moshiリフレクション&#34;&gt;Moshiリフレクション&lt;/h2&gt;

&lt;p&gt;Moshiにはmoshi-codegenと呼ばれる、アノテーションプロセッサーでコード生成してくれるライブラリがあります。
これは実行時のパフォーマンスには優れているのですが、アノテーションプロセッサーを使っているため、ビルドに時間がかかってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、Moshiではmoshi-reflectionと呼ばれるライブラリを提供しており、これはアノテーションプロセッサーを使うことなく、
moshi-codegenと同等の機能を提供してくれます。
ただし、moshi-reflectionは内部でリフレクションを使っているため、実行時のパフォーマンスには優れていません。あくまでデバッグ用、という立ち位置だと思います。&lt;/p&gt;

&lt;p&gt;デバッグ時にmoshi-reflectionを使い、リリース時にmoshi-codegenを使うことで、ビルド速度と実効速度の天秤を勝ち取ることが出来ます。&lt;/p&gt;

&lt;p&gt;具体的には、デバッグ時、リリース時に&lt;code&gt;build.gradle&lt;/code&gt;で指定するライブラリを、Moshiに登録するAdapterを変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// bulid.gradle

implementation &amp;quot;com.squareup.moshi:moshi:1.8.0&amp;quot;
debugImplementation &amp;quot;com.squareup.moshi:moshi-kotlin:1.8.0&amp;quot;
kaptRelease &amp;quot;com.squareup.moshi:moshi-kotlin-codegen:1.8.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// debug時
fun createMoshiBuilder() = Moshi.Builder()
    .add(KotlinJsonAdapterFactory()) // KotlinJsonAdapterFactoryを指定する
    .build()

// release時
fun createMoshiBuilder() = Moshi.Builder()
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、リリース時のみkaptを実行するようになります。&lt;/p&gt;

&lt;h2 id=&#34;daggerリフレクション&#34;&gt;Daggerリフレクション&lt;/h2&gt;

&lt;p&gt;これはSdkSearch内で開発が行われているライブラリです。有名なAndroidエンジニアであるJake Whartonさんが開発をしています。&lt;/p&gt;

&lt;p&gt;これもMoshiと同様に、リフレクションを使うことでアノテーションプロセッサーを極力使わないようにしています。
現状、最低限のクラスはアノテーションプロセッサーで作成するようになっているので、完全除去というわけではありません。
例えば、アノテーションプロセッサーで&lt;code&gt;DaggerAppComponent&lt;/code&gt;は作られます。&lt;/p&gt;

&lt;p&gt;最初にも書いたのですが、Daggerリフレクションは絶賛開発中で、Scope、セッターインジェクションなど、多くの機能が使えない状態です。
ここが揃ってくればデバッグ時にはDaggerリフレクションを使うことで、ビルド時間の短縮が可能になってくると思います。&lt;/p&gt;

&lt;p&gt;具体的なコードは、以下のようになります。
Mavenにアップデートされていないので、SdkSearchからコードをコピーして使っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &amp;quot;com.google.dagger:dagger:2.18&amp;quot;
debugImplementation project(&#39;:dagger-reflect:reflect&#39;) // SdkSearchからコピー
kaptDebug project(&#39;:dagger-reflect:reflect-compiler&#39;) // SdkSearchからコピー
kaptRelease &amp;quot;com.google.dagger:dagger-compiler:2.18&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバッグ時にはDaggerリフレクションを使い、リリース時にはdagger-compilerを使っています。
コードは全く修正することなく、ビルド時間の短縮が可能になります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;デバッグ時にはkapt、アノテーションプロセッサーを抑制しビルド時間を短縮しよう😃

&lt;ul&gt;
&lt;li&gt;butterknifeもreflectionを使うことができる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Daggerリフレクションには期待しかない😄

&lt;ul&gt;
&lt;li&gt;何か進みがあったらまたまとめようと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の記事を検証するために作った&lt;a href=&#34;https://github.com/satoshun-android-example/DebugReflectExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JakeWharton/SdkSearch&#34;&gt;https://github.com/JakeWharton/SdkSearch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/moshi&#34;&gt;https://github.com/square/moshi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jakewharton.com/helping-dagger-help-you/&#34;&gt;https://jakewharton.com/helping-dagger-help-you/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>KotlinのNon-Null型にnullを代入する方法</title>
      <link>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</guid>
      <description>

&lt;p&gt;Kotlinではnullを扱いやすくするためにNullable、Non-Nullを型で制限することが出来ます。
KotlinのNon-Null型に対してnullを代入しようとすると、代入するタイミングで例外を吐きます。
JavaとKotlinを一緒に使っていると、この例外に遭遇することがあると思います。&lt;/p&gt;

&lt;p&gt;具体的には以下の挙動をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Hoge {
    // nullを返すメソッド
    static String getName() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val d: String = Hoge.getName() // ここで例外が投げられる
println(d.length) // これは実行されない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは、&lt;code&gt;val d: String = Hoge.getName()&lt;/code&gt;で&lt;code&gt;IllegalStateException&lt;/code&gt;を投げます。
Non-Null型にnullを代入しようとしているからです。&lt;/p&gt;

&lt;p&gt;次に、代入するタイミングで例外を投げなくする方法を紹介します。&lt;/p&gt;

&lt;p&gt;具体的には以下のコードで達成できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; castNull(): T = null as T


val d: String = castNull() // ここでは例外が投げられない
println(d.length) // ここで例外が投げられる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこのような挙動になるのかを説明します。まず &lt;code&gt;castNull()&lt;/code&gt;メソッドに定義されたジェネリック型Tは&lt;code&gt;Any?&lt;/code&gt;をupperに持ちます。
Kotlinはジェネリックを使い、かつNullable型をupperに持つとき、nullかどうかのチェックをしません。これはバイトコードを見れば分かります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;GETSTATIC sample/SampleTestsJVMKt.a : Ljava/lang/String;
CHECKCAST java/lang/Object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CHECKCAST&lt;/code&gt;しかしておらず、nullかどうかのチェックをしていません。
なので、&lt;code&gt;val d: String = castNull()&lt;/code&gt;ではnullチェックがされないため例外が投げられず、実際にメソッドをコールする&lt;code&gt;println(d.length)&lt;/code&gt;のタイミングで例外が投げられます。&lt;/p&gt;

&lt;p&gt;Non-Null型である&lt;code&gt;String&lt;/code&gt;にnullを代入することが出来ました。&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;fun &amp;lt;T: Any&amp;gt; castNull(): T = null as T&lt;/code&gt;と、Non-Null型をupperにした場合のバイトコードは次になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;GETSTATIC sample/SampleTestsJVMKt.a : Ljava/lang/String;
DUP
IFNONNULL L1
NEW kotlin/TypeCastException
DUP
LDC &amp;quot;null cannot be cast to non-null type T&amp;quot;
INVOKESPECIAL kotlin/TypeCastException.&amp;lt;init&amp;gt; (Ljava/lang/String;)V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらのバイトコードには、nullチェックが入っていることが分かります。nullチェックをしているため、&lt;code&gt;val d: String = castNull()&lt;/code&gt;のタイミングで例外が投げられます。&lt;/p&gt;

&lt;p&gt;Nullableな型をupperに持つ、持たないでnullチェックをするかどうかが決まる、という話でした。&lt;/p&gt;

&lt;p&gt;この挙動は &lt;a href=&#34;https://youtrack.jetbrains.com/issue/KT-8135&#34;&gt;https://youtrack.jetbrains.com/issue/KT-8135&lt;/a&gt; ISSUEにバグとして報告されているので、今後異なるバイトコードが生成される可能性があります。
もし、この挙動に依存するようなコードを書いている場合は注意が必要です。&lt;/p&gt;

&lt;p&gt;実世界では、mockito-kotlinがこの挙動に依存しているので、より興味がある方はぜひ読んでください😃 &lt;a href=&#34;https://github.com/nhaarman/mockito-kotlin/blob/2.x/mockito-kotlin/src/main/kotlin/com/nhaarman/mockitokotlin2/internal/CreateInstance.kt#L46&#34;&gt;ここのあたりで使っています&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nhaarman/mockito-kotlin&#34;&gt;https://github.com/nhaarman/mockito-kotlin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtrack.jetbrains.com/issue/KT-8135&#34;&gt;https://youtrack.jetbrains.com/issue/KT-8135&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>拡張関数 &#43; ジェネリック型でよりタイプセーフを得る</title>
      <link>https://satoshun.github.io/2018/11/extension-typesafe/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/extension-typesafe/</guid>
      <description>

&lt;p&gt;Kotlinの拡張関数の話です。&lt;/p&gt;

&lt;p&gt;以下のクラスがあったとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A&amp;lt;T&amp;gt;(val value: T) {
  fun isNull(): Boolean {
    return value != null
  }
}

fun main() {
  val a1: A&amp;lt;Int&amp;gt; = ...
  a1.isNull()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき、&lt;code&gt;a1.isNull()&lt;/code&gt;の結果は自明です。なぜなら&lt;code&gt;A&amp;lt;Int&amp;gt;&lt;/code&gt;で宣言している時点でnonNullが確定しているためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun main() {
  val a2: A&amp;lt;Int?&amp;gt; = ...
  a2.isNull()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このとき、&lt;code&gt;a2.isNull()&lt;/code&gt;の結果は自明ではありません。
なぜなら&lt;code&gt;A&amp;lt;Int?&amp;gt;&lt;/code&gt;でジェネリック型を宣言しているので、nullableな値が入ってくる可能性があるためです。&lt;/p&gt;

&lt;p&gt;この2つの例から、&lt;code&gt;a1.isNull()&lt;/code&gt;はそもそもnonNullなので&lt;code&gt;isNull()&lt;/code&gt;メソッドをコールできないほうが良いのではないか？という考えが浮かびます。&lt;/p&gt;

&lt;p&gt;Kotlinの拡張関数を使うことで達成できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A&amp;lt;T&amp;gt;(val value: T)

// nullableのときにコールできるようにする
fun &amp;lt;T : Any&amp;gt; A&amp;lt;T?&amp;gt;.isNull(): Boolean {
  return value != null
}

fun main() {
  val a1: A&amp;lt;Int&amp;gt; = ...
  a1.isNull() // コンパイルエラー!!

  val a2: A&amp;lt;Int?&amp;gt; = ...
  a2.isNull()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fun &amp;lt;T : Any&amp;gt; A&amp;lt;T?&amp;gt;.isNull()&lt;/code&gt;と宣言することでnullable時のみコールできます。&lt;/p&gt;

&lt;p&gt;ジェネリック型がnullable時のみコールしたい場合に有効なテクニックでした😃&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.nightlynexus.com/kotlin-extension-members-are-great-even-for-types-you-do-control/&#34;&gt;http://blog.nightlynexus.com/kotlin-extension-members-are-great-even-for-types-you-do-control/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlinで3つの関数のパラメータを省略する</title>
      <link>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</guid>
      <description>

&lt;p&gt;Kotlinでは拡張関数が定義されており、拡張関数を使うことで1つ関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun hoge(a: String) {
  println(a)
}

-&amp;gt;

fun String.hoge() {
  println(this)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、インターフェース（クラス）内で拡張関数を定義することで、さらに1つの関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface User

fun hoge(a: String, b: User) {
  println(a)
  println(b)
}

-&amp;gt;

interface User {
  fun String.hoge() {
    println(this)
    println(this@User)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、reified type parameterを使うことで、関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; hoge(a: String, b: User, c: Class&amp;lt;T&amp;gt;) {
  println(a)
  println(b)
  println(c)
}

-&amp;gt;

class User {
  inline fun &amp;lt;reified T&amp;gt; String.hoge() {
    println(this)
    println(this@User)
    println(T::class)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interfaceだと、inline関数が使えないのでクラスで定義してあります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kotlinの拡張関数、reified便利😊&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description>

&lt;p&gt;ふとAACの&lt;a href=&#34;https://developer.android.com/reference/androidx/lifecycle/ViewModel&#34;&gt;ViewModel&lt;/a&gt;のonClearedメソッドをテストしたくなったので、 2つのやりかたを紹介します。&lt;/p&gt;

&lt;p&gt;環境は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;junit:junit:4.12&amp;quot;
&amp;quot;androidx.test:rules:1.1.0-beta02&amp;quot;
&amp;quot;androidx.test:runner:1.1.0-beta02&amp;quot;
&amp;quot;androidx.test.ext:junit:1.0.0-beta02&amp;quot;
&amp;quot;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;quot;
&amp;quot;org.robolectric:robolectric:4.0-beta-1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;p&gt;また、サンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/architectures/BaseViewModelTest.kt&#34;&gt;GitHub&lt;/a&gt;にあるので、参考してください😊&lt;/p&gt;

&lt;h3 id=&#34;1-viewmodelstore-を使う&#34;&gt;1. &lt;code&gt;ViewModelStore&lt;/code&gt;を使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ViewModelProviders.of(activity).get(class)&lt;/code&gt;からViewModelを取得したときに、取得したViewModelは&lt;a href=&#34;https://developer.android.com/reference/androidx/lifecycle/ViewModelStore&#34;&gt;ViewModelStore&lt;/a&gt;にキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(AndroidJUnit4::class)
class BaseViewModelTest {
  @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java)

  @Test
  fun `dispose a coroutine when finished lifecycle of ViewModel`() {
    activityRule.activity.viewModelStore.clear() // ViewModelが開放される
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このテストはコード的には簡単ですが、ViewModelStoreがViewModelのライフサイクルを管理しているということを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。&lt;/p&gt;

&lt;p&gt;なので、素直にonDestroyをコールするテストも書いてみます。&lt;/p&gt;

&lt;h3 id=&#34;2-instrumentation-callactivityondestroy-を使う&#34;&gt;2. &lt;code&gt;Instrumentation.callActivityOnDestroy&lt;/code&gt;を使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Instrumentation&lt;/code&gt;クラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。
&lt;code&gt;Instrumentation&lt;/code&gt;は&lt;code&gt;InstrumentationRegistry&lt;/code&gt;クラスから取得することができ、次のように書くことで、&lt;code&gt;onDestroy&lt;/code&gt;をコールすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Test
fun `dispose a coroutine when finished lifecycle of ViewModel 2`() {
  // onDestroyがコールされViewModelが開放される
  InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Unitテストで&lt;code&gt;ViewModel.onCleared&lt;/code&gt;のテストをすることが出来ます。&lt;/p&gt;

&lt;p&gt;以上です。Happy Testing☆彡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/architectures/BaseViewModelTest.kt&#34;&gt;サンプルコード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>

&lt;p&gt;（この記事は1.3-M2を使っています。）&lt;/p&gt;

&lt;p&gt;Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。&lt;/p&gt;

&lt;p&gt;例えば、次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline class UserId(val id: String) {
    val url get() = &amp;quot;http://$id&amp;quot;
}

val userId = UserId(&amp;quot;user-dayo&amp;quot;)
println(userId.url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは一見、UserIdインスタンスが生成されそうです。
しかし、コンパイルされたコードではUserIdインスタンスは生成されません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final class UserId$Erased {
    ...

    @NotNull
    public static final String getUrl(String $this) {
        return &amp;quot;http://&amp;quot; + $this;
    }

    ...
}

String userId = &amp;quot;user-dayo&amp;quot;;
String var1 = UserId$Erased.getUrl(userId);
System.out.println(var1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成された&lt;code&gt;UserId$Erased&lt;/code&gt;クラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。&lt;/p&gt;

&lt;p&gt;ここからが本題です。
Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。&lt;/p&gt;

&lt;p&gt;例えば、次のコードがあったとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class Response(
    @SerializedName(&amp;quot;user_id&amp;quot;) val userId: String,
    @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: String
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはuserIdとfriendIdをStringで受け取っており、このStringが何のStringかの情報が欠落しています。型による分類が出来てない状態です。&lt;/p&gt;

&lt;p&gt;これにInline classesを使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline class UserId(private val id: String) {
    val url get() = &amp;quot;http://my/$id&amp;quot;
}

inline class FriendId(private val id: String) {
    val url get() = &amp;quot;http://friend/$id&amp;quot;
}

data class Response(
    @SerializedName(&amp;quot;user_id&amp;quot;) val userId: UserId,
    @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: FriendId
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inline classesがコンパイルされると、Stringに展開されるので正しく動作します。
本来、カスタムのクラスで値を受け取るときはAdapterを別途定義する必要があったですが、その必要がなくなりました😄&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Inline classesを使えば、カスタムのAdapterを作成することなくserialize/deserializeできるので非常に便利です☺&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>

&lt;p&gt;みなさんこんにちは&lt;/p&gt;

&lt;p&gt;今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として&lt;code&gt;@Inject lateinit var&lt;/code&gt; になってしまうところがあると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    @Inject lateinit var hoge: Hoge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをなんとか出来ないかなと思って考えてみました。&lt;/p&gt;

&lt;p&gt;結論から言うと最終形はこのようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;IntoMap&lt;/code&gt;を使って実装することにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IntoMap&lt;/code&gt;とはその名の通りMapにバインドするためのアノテーションです。
詳しくは&lt;a href=&#34;https://google.github.io/dagger/multibindings.html&#34;&gt;ドキュメント&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;サンプルコードで説明していきます。&lt;/p&gt;

&lt;p&gt;まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module
interface HogeModule {
    @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any
    @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any
}

class Hoge1 @Inject constructor()
class Hoge2 @Inject constructor()

@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
@MapKey
annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。&lt;/p&gt;

&lt;p&gt;作ったModuleをComponentに組み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(modules = [HogeModule::class])
interface AppComponent {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ApplicationでAppComponentを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class App : Application() {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt; by lazy {
    DaggerAppComponent.builder().build().values
    }

    inline fun &amp;lt;reified T&amp;gt; get(): T = values[T::class.java]!!.get() as T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、Activity用に拡張関数を定義して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T&amp;gt; Activity.inject() = lazy { get&amp;lt;T&amp;gt;() }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成です!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : AppCompatActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このアプローチの問題点は、というか問題点しかないんですけど、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ランタイムで落ちる可能性がある

&lt;ul&gt;
&lt;li&gt;Daggerの良さであるアノテーション時のチェックが消え去る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ScopeとかSubcomponentとかの対応方法が良く分かんない

&lt;ul&gt;
&lt;li&gt;まあこれは考えていないだけなので、もしかしたらいい方法があるかもしれない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いわゆるService Locatorパターンになってしまい微妙&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;サンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/SimpleDaggerExample&#34;&gt;https://github.com/satoshun-android-example/SimpleDaggerExample&lt;/a&gt; にあります。よかったら見てください😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>

&lt;p&gt;RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これは&lt;code&gt;Message#setAsynchronous&lt;/code&gt;を使うことで、UIのパフォーマンス向上を狙った機能です。
下のリンクに詳細な内容が書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@sweers/rxandroids-new-async-api-4ab5b3ad3e93&#34;&gt;RxAndroid’s New Async API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。&lt;/p&gt;

&lt;p&gt;検証に使用したサンプルプロジェクトは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトをかいつまんで説明します。&lt;/p&gt;

&lt;p&gt;まず2つのスケジューラを作成し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false)
private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// asyncがfalseの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(mainScheduler)
    .subscribe(...)

// asyncがtrueの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(asyncMainScheduler)
    .subscribe(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フルコードは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;結果は、以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;// API27 エミュレータ
main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和
main=130857ms, async=126582ms
main=131401ms, async=126909ms
main=130763ms, async=126504ms
main=132758ms, async=127972ms

// API21 エミュレータ
main=129869ms, async=125795ms
main=130050ms, async=125888ms
main=129935ms, async=125853ms
main=129908ms, async=125838ms
main=129927ms, async=125824ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。&lt;/p&gt;

&lt;p&gt;ただ注意点として、この機能は副作用がある可能性があります(なのでデフォルトではasyncはfasle)。ただ、Uberで1年間、プロダクションで運用したところ、特に大きな問題は起きなかったらしいので  &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/pull/416&#34;&gt;https://github.com/ReactiveX/RxAndroid/pull/416&lt;/a&gt; 、ほぼ安全と考えて良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;サンプルコードで検証した結果、async=trueでパフォーマンスの向上が得られそう&lt;/li&gt;
&lt;li&gt;導入は以下のコードを追加するだけなので、とても簡単&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;RxAndroidPlugins.setInitMainThreadSchedulerHandler {
    AndroidSchedulers.from(Looper.getMainLooper(), true)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>

&lt;p&gt;Dagge 2.17でfastInitオプションが追加されました。
&lt;a href=&#34;https://google.github.io/dagger/compiler-options&#34;&gt;https://google.github.io/dagger/compiler-options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。&lt;/p&gt;

&lt;p&gt;確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。&lt;/p&gt;

&lt;h2 id=&#34;確認に使用したシェルスクリプト&#34;&gt;確認に使用したシェルスクリプト&lt;/h2&gt;

&lt;p&gt;adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for i in {0..10}
do
    adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt
    sleep 10
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記を参考にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/performance/vitals/launch-time&#34;&gt;https://developer.android.com/topic/performance/vitals/launch-time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fastinit有効の場合&#34;&gt;fastInit有効の場合&lt;/h2&gt;

&lt;p&gt;下記をbuild.gradleに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    javacOptions {
        option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1609ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fastinit無効の場合&#34;&gt;fastInit無効の場合&lt;/h2&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1607ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ほぼ変わらない数字が出てきてしまいました。悲しい。
Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。&lt;/p&gt;

&lt;p&gt;芳しくない結果になった推測として&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;担当アプリのDaggerの書き方が正しくないからこの結果になった?

&lt;ul&gt;
&lt;li&gt;要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;確認に使用したコマンドが良くないのかも?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8/Proguardをちゃんと使う&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。&lt;/p&gt;

&lt;p&gt;実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。&lt;/p&gt;

&lt;p&gt;まずは、R8無しで調べてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然メソッドカウントが1増えています。&lt;/p&gt;

&lt;p&gt;次に、inlineを付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらもメソッドカウントが1増えました。
show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Metadata(
    mv = {1, 1, 10},
    bv = {1, 0, 2},
    k = 2,
    d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;},
    d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;}
)
public final class MainActivityKt {
    public static final void hoge() {
        String var1 = &amp;quot;hogehoge&amp;quot;;
        System.out.println(var1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、ここで重要なのは、inlineをつけたメソッドはインライン化されるため、上記のメソッドは生成されるけど、実際にはコールされない点です。
コールされない、参照がないのでR8で削除することができます。&lt;/p&gt;

&lt;p&gt;実際にR8/Proguardを有効にしてBuild APK → Analyze APKで確認したところ、inlineをつけた場合はメソッドカウントが増えていないことが確認できました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;InlineメソッドはR8/Proguardと組み合わせればメソッドカウントを減らす効果がある

&lt;ul&gt;
&lt;li&gt;とはいえ、5.0(ART)からはruntimeからmultidexをサポートしているので、昔ほどメソッドカウントを意識する必要はないと思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>

&lt;p&gt;ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。
この記事では&lt;a href=&#34;https://developer.android.com/reference/android/widget/Space&#34;&gt;Space&lt;/a&gt;を使ったネガティブマージンの実現について説明します。&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;ネガティブマージンと同等の大きさを持った&lt;code&gt;Space&lt;/code&gt;を定義して、そこにConstraintを設定するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:clipToPadding=&amp;quot;false&amp;quot;
    android:padding=&amp;quot;80dp&amp;quot;&amp;gt;

  &amp;lt;Space
      android:id=&amp;quot;@+id/negative&amp;quot;
      android:layout_width=&amp;quot;15dp&amp;quot;
      android:layout_height=&amp;quot;15dp&amp;quot;
      app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;ImageView
      android:id=&amp;quot;@+id/icon&amp;quot;
      android:layout_width=&amp;quot;30dp&amp;quot;
      android:layout_height=&amp;quot;30dp&amp;quot;
      android:contentDescription=&amp;quot;icon&amp;quot;
      app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot;
      app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot;
      tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/LQrkHsAeTBvqlZWuw1Ccpm_dvrnCsdK7aH2rMB6HYakF_jv3q6Zf_-QBtfOo1eD0EjLBOjxy11nx2TAlZstr354XRiSXt7HUxENJXji8ZxWNxeJUTe8g9jIstSO1PRMsw7f8O5xuCakktrJLSUPLk01CI1N6OJ9MGMvsSbSDO6o4t7oeipkV9f7klqmzdxtoxESyDzoEI5SfeMOxynhmTGLwv6RnaASEOzVyL2xEW8eq63erAiu6ptdwl-_rQkxAnAIhYpSuPZjweCPBzf3GiMJi5gx_Ciz348GmoSaTIhuGM6grHd181fBGkZQkbvgg5ggrk5pLlja1N4eZA54n5rgzKs5gT36fA8K_ZFrAQI0H50cvAbesIeDVb05MZ2pP592Kwb8moTt6xp0TTFYrJf-c-MVljio-JvAKuUC0fPWPpdgMyxkJHW4AzK9l-Yo4f2-dUdfEf06J6ktMOsld0Yzsyu07Hki6MSGeBjU3bJ3R0vDi-W6SBUNmcDzJu5kC-2ItGmq4sN8fq06XJMSwVTmfDAyfHOluWHOTlL5LV3YVvYZxxgGJ6_ldqdD2HZ0ZW8wuNpfrHTxGLYCHR5EN5ouY5ILx-snrNAfQPQ9Z9Ph0U_4UeCMlODslXyRpueecgOSBJUhwc47xrQ04b-xOJz_01EWEA61x=w1452-h720-no&#34; alt=&#34;constraintlayout-image&#34; width=&#34;600px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;簡単に説明すると、&lt;code&gt;Space&lt;/code&gt;に15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。
上記の例だと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginStart=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginTop=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と同等の振る舞いをしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ConstraintLayoutではネイティブでネガティブマージンに対応していないため、&lt;code&gt;Space&lt;/code&gt;を使った、ややテクニカルな方法で実現するのが良いと思われます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>&lt;p&gt;Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-aliases.html&#34;&gt;https://kotlinlang.org/docs/reference/type-aliases.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias MyHandler = (Int, String, Any) -&amp;gt; Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにtypealiasは、アノテーションをつけることも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JvmSuppressWildcards&lt;/code&gt;はDagger(&lt;a href=&#34;https://github.com/google/dagger/issues/668&#34;&gt;参考リンク&lt;/a&gt;)やretrofit(&lt;a href=&#34;https://github.com/square/retrofit/issues/1805&#34;&gt;参考リンク&lt;/a&gt;)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/google/dagger&#34;&gt;Dagger&lt;/a&gt;を使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。
Androidでは、すべてのActivityで共通のインスタンスを使うには &lt;code&gt;Singleton&lt;/code&gt;スコープとAppComponentを組み合わせて使う方法がよく知られています。
しかし、&lt;strong&gt;特定&lt;/strong&gt;のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。Singletonだと&lt;strong&gt;すべて&lt;/strong&gt;のActivity間で共通のインスタンスが使えてしまいます。&lt;/p&gt;

&lt;p&gt;この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。
また、基本的なDaggerの使い方は知っている前提で説明していきます。&lt;/p&gt;

&lt;p&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;になります。
コードを見ると理解がより深まると思うので、ぜひご覧になってください😊&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では説明していきます。今回のサンプルコードの目指すところは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserScopeを定義し、MainActivity、UserScopedActivityで同一の&lt;code&gt;UserManager&lt;/code&gt;インスタンスを使用する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;まず最初にUserScopeを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Scope
@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
annotation class UserScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にUserSubcomponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UserScope
@Subcomponent
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは、UserSubcomponentに&lt;code&gt;UserScope&lt;/code&gt;スコープを持たせています。
このように書くことで、SubcomponentとScopeを結びつけることが出来ます。&lt;/p&gt;

&lt;p&gt;次にAppComponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  // AppComponentとUserSubcomponentを結びつける
  val userComponentBuilder: UserSubcomponent.Builder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは&lt;code&gt;AppComponent&lt;/code&gt;に、&lt;code&gt;val userComponentBuilder: UserSubcomponent.Builder&lt;/code&gt;を定義することです。
こうすることで、&lt;code&gt;AppComponent&lt;/code&gt;に&lt;code&gt;UserSubcomponent&lt;/code&gt;を結び付けることが出来ます。&lt;/p&gt;

&lt;p&gt;これで基本的な部分の定義は完了しました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次に、各ActivityをComponentに結びつけていきます。
サンプルではMainActivity、UserScopedActivityとNoUserScopedActivityの3つのActivityを定義しており、
それぞれのActivityは以下のように振る舞わせたいとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mainactivity-userscopedactivityをusersubcomponentに従わせる&#34;&gt;MainActivity、UserScopedActivityをUserSubcomponentに従わせる&lt;/h2&gt;

&lt;p&gt;MainActivity、UserScopedActivityを&lt;code&gt;UserSubcomponent&lt;/code&gt;に定義することで、MainActivity、UserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従わせることが出来ます。
なぜなら、&lt;code&gt;UserSubcomponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いているためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserSubcomponent.kt
@UserScope
@Subcomponent(modules = [
  MainActivityModule::class,
  UserScopedActivityModule::class
])
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}

// MainActivityModule.kt
@Module
interface MainActivityModule {
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nouserscopedactivityはuserscopeに従わない&#34;&gt;NoUserScopedActivityはUserScopeに従わない&lt;/h2&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;AppComponent&lt;/code&gt;に定義することで、NoUserScopedActivityで&lt;code&gt;UserScope&lt;/code&gt;を使っていたらコンパイルエラーにすることが出来ます。
&lt;code&gt;AppComponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いていないためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// AppComponent.kt
@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class,
      NoUserScopedActivityModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  val userComponentBuilder: UserSubcomponent.Builder
}

// NoUserScopedActivityModule.kt
@Module
interface NoUserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeNoUserScopedActivity(): NoUserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、定義は完了です。実際に正しく動くかを確認してみます。
適当に&lt;code&gt;UserScope&lt;/code&gt;に従う&lt;code&gt;UserManager&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserManager.kt
@UserScope
class UserManager @Inject constructor() {
  var value = 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;UserScope&lt;/code&gt;に従うので、MainActivity、UserScopedActivityには期待通り同一インスタンスが&lt;code&gt;Inject&lt;/code&gt;できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivity.kt
class MainActivity : AppCompatActivity() {

  // ok
  @Inject lateinit var userManager: UserManager

  ...
}
// UserScopedActivity.kt
class UserScopedActivity : AppCompatActivity() {

  // ok: MainActivityと同じインスタンスが注入される
  @Inject lateinit var userManager: UserManager

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、NoUserScopedActivityに&lt;code&gt;Inject&lt;/code&gt;しようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// NoUserScopedActivity.kt
class NoUserScopedActivity : AppCompatActivity() {

  //  下のコメントアウトを取るとコンパイルエラー
  //  @Inject lateinit var userManager: UserManager
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従う形で定義してないためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が達成できました。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;そもそも、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;定義時に、&lt;code&gt;UserScope&lt;/code&gt;スコープを付与してあげればいいんじゃないかと思うかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivityModule.kt
@Module
interface MainActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このやり方だと、今回のケースには不都合です。&lt;/p&gt;

&lt;p&gt;MainActivity、UserScopedActivityは&lt;code&gt;UserScope&lt;/code&gt;に従うのでコンパイルは通ります。
しかし、MainActivity、UserScopedActivityで同一インスタンスを使うことは出来ません。&lt;/p&gt;

&lt;p&gt;何故かと言うと、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;はSubcomponentを作るシンタックスシュガーのようなものですが、
&lt;code&gt;MainActivityModule&lt;/code&gt;と&lt;code&gt;UserScopedActivityModule&lt;/code&gt;はそれぞれ独立したSubcomponentを作るので、独立したComponent間で同一インスタンスを使うことが出来ないためです。&lt;/p&gt;

&lt;p&gt;今回のように、&lt;code&gt;UserSubcomponent&lt;/code&gt;を定義して、そのComponentをベースに所属させる必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;特定のActivityのみで共通のインスタンスを使いたいときは、結構めんどう

&lt;ul&gt;
&lt;li&gt;冗長な気がするので、もっといい方法があったら教えてください😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;がどういう動作をするのかを知っておくと、いざというときに便利&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>