<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Mon, 31 Dec 2018 06:19:39 UTC</updated>
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>

&lt;p&gt;Androidのトレンドの1つにマルチモジュール構成があります。
マルチモジュールによるメリットとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビルド時間の短縮&lt;/li&gt;
&lt;li&gt;依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。&lt;/p&gt;

&lt;p&gt;この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい&lt;/li&gt;
&lt;li&gt;コード量を減らしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part1では、遷移専用のモジュールを作る方法を考えてみます。&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;遷移専用のモジュールを作る&#34;&gt;遷移専用のモジュールを作る&lt;/h2&gt;

&lt;p&gt;まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。&lt;/p&gt;

&lt;p&gt;例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メインではサブ画面が必要なのでサブモジュールに依存する&lt;/li&gt;
&lt;li&gt;サブではメイン画面が必要なのでメインモジュールに依存する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwecY1CaGcBmH5nSNa5BGBSfCpoZHjOE8WGW5tPpKDAW85vT3QbuAq6K0&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。
直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。&lt;/p&gt;

&lt;p&gt;そこで、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メイン画面に遷移するメインルーターモジュール&lt;/li&gt;
&lt;li&gt;サブ画面に遷移するサブルーターモジュール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのモジュールを作ります。&lt;/p&gt;

&lt;p&gt;メインルーターモジュールでは次の遷移専用インターフェースを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainRouter {
  fun routeToMain(context: Context): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;internal class MainRouterImpl @Inject constructor() : MainRouter {
  override fun routeToMain(context: Context): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---

@Module
internal interface MainActivityModule {
  @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SubActivity : AppCompatActivity() {
  @Inject lateinit var router: MainRouter

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な依存図は次のようになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwebLoUFcrO-RzpnksWyaOGgDKLGYMGTJO8If09iv9bnSN41AGRUqGBV63c8oZ6y7LG0o3Kc12K80ge7B8JKl1HWG0000&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで、相互に遷移する画面だとしても循環参照になることなく解決することが出来ます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;いちいちルーターモジュールを作るのがめんどうなのであれば、共通のRouterインターフェースを作る方法もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Router&amp;lt;T&amp;gt; {
  fun route(context: Context, params: T): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;---実装

internal class MainRouter2Impl @Inject constructor() : Router&amp;lt;Unit&amp;gt; {
  override fun route(context: Context, params: Unit): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---Daggerの設定

@Module
internal interface MainActivityModule {
  @Named(&amp;quot;main&amp;quot;)
  @Binds fun bindMain2Router(impl: MainRouter2Impl): Router&amp;lt;Unit&amp;gt;
}

---使用側

class SubActivity : AppCompatActivity() {
  @field:[Inject Named(&amp;quot;main&amp;quot;)] lateinit var router: Router&amp;lt;Unit&amp;gt;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DaggerのNamedアノテーションと組み合わせることでいい感じに共通Routerを作ることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;相互に行き来したい画面があったときに、遷移専用のモジュールを作ることで循環参照を防ぐことが出来る&lt;/li&gt;
&lt;li&gt;基本的に画面を含んだモジュールは遷移したいときがほとんどだと思うので、遷移専用のモジュールを作ることで無駄な依存を作ることを防ぐことが出来る&lt;/li&gt;
&lt;li&gt;遷移用のモジュールが増える😂😂😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part2ではDeeplinkやnavigationを絡めた遷移の方法について考えてみたいと思います😃&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: コーディングを支える技術</title>
      <link>https://satoshun.github.io/2018/12/coding_tech/</link>
      <pubDate>Fri, 28 Dec 2018 05:27:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coding_tech/</guid>
      <description>&lt;p&gt;「コーディングを支える技術」を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;比較、歴史から学ぶ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;その機能はなにかの問題を解決するために導入されている

&lt;ul&gt;
&lt;li&gt;歴史から紐解くことでなぜそれが必要かが理解できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語によってどの問題を解決したいのかが違う

&lt;ul&gt;
&lt;li&gt;Python: 同じようなコードになるような言語&lt;/li&gt;
&lt;li&gt;C++: 高速に動作することを目指している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;エラー処理の進化
- globalなエラーハンドリングはgotoと変わらない
- try catch finallyのように構造化されたエラー処理が誕生した
    - Javaでは検査型例外、必ずerrorを処理しなければいけない設計&lt;/p&gt;

&lt;p&gt;アドレスを覚えるのは人間には大変&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人間はメソッド、変数を介することでアドレスを忘れることが出来た

&lt;ul&gt;
&lt;li&gt;結果、メソッド名、変数名をいかにしてわかりやすくするかが重要になってきた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本的には何をするかというよりかは、何をさせないかで進化している&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスによるポリモーフィズム

&lt;ul&gt;
&lt;li&gt;関数ポインタを直接触らないように&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gotoの禁止

&lt;ul&gt;
&lt;li&gt;構造化、モジュール化できなくなるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方</title>
      <link>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</link>
      <pubDate>Tue, 25 Dec 2018 03:00:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</guid>
      <description>&lt;p&gt;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;継承とコンポジションはトレードオフ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;継承は自動的にaメッセージを委譲する

&lt;ul&gt;
&lt;li&gt;便利だが依存関係は強い&lt;/li&gt;
&lt;li&gt;親クラスが変更されたときに、自動的に子クラスにも影響があることを意味する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;継承は階層構造を生み出す

&lt;ul&gt;
&lt;li&gt;ポリモーフィズムを実現する&lt;/li&gt;
&lt;li&gt;これまた便利だが依存関係は強い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンポジションは自動的に委譲しない

&lt;ul&gt;
&lt;li&gt;必要に応じて集約クラスで操る必要がある&lt;/li&gt;
&lt;li&gt;依存は継承より少ない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単一責任について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あたりまえだけど守らないといけない

&lt;ul&gt;
&lt;li&gt;無駄な責務があると再利用できない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;達成することで再利用可能な素晴らしいクラスが出来る&lt;/li&gt;
&lt;li&gt;責任の依存先が不明なときは一旦privateとかに切り出しておいて未来に託す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ダックタイピング&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ダックにより、具体的なGearクラスからロールへのマインドシフトが出来る&lt;/li&gt;
&lt;li&gt;ロールを満たすことにより要件を満たす&lt;/li&gt;
&lt;li&gt;実装には依存しない、メッセージを送るだけで良い世界はOOPの真骨頂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依存関係について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;依存関係の向きを考えるのは大切

&lt;ul&gt;
&lt;li&gt;例えばコンストラクタ内で依存するのと、インスタンスメソッドだと距離が違う。コンストラクタ内で依存したほうが良い

&lt;ul&gt;
&lt;li&gt;さらに進めるとDI，コンストラクタの外から注入する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依存関係逆転の法則

&lt;ul&gt;
&lt;li&gt;低レイヤーに依存するのではなく、インターフェースに依存しておいて、あとから実装を注入することで達成

&lt;ul&gt;
&lt;li&gt;domain層などの他の層に依存したくない層で有効&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柔軟なインターフェース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトを信じるようなインターフェース

&lt;ul&gt;
&lt;li&gt;どのようにするかではなく、何をするかをメソッド名にする。宣言的に&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安定していなければいけない&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>

&lt;p&gt;Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、&lt;code&gt;ContinuationInterceptor&lt;/code&gt;を使えば上手くいきそうです。&lt;/p&gt;

&lt;h2 id=&#34;continuationinterceptorとは&#34;&gt;ContinuationInterceptorとは?&lt;/h2&gt;

&lt;p&gt;ContinuationInterceptorは次のようなインターフェースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * Marks coroutine context element that intercepts coroutine continuations.
 * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and
 * intercepts all coroutine continuations with [interceptContinuation] invocations.
 */
@SinceKotlin(&amp;quot;1.3&amp;quot;)
public interface ContinuationInterceptor : CoroutineContext.Element {
  public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;
  public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;)
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;interceptContinuation&lt;/code&gt;からContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class LifecycleContinuationInterceptor(
  private val lifecycle: Lifecycle
) : ContinuationInterceptor {
  override val key: CoroutineContext.Key&amp;lt;*&amp;gt;
    get() = ContinuationInterceptor

  override fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; {
    // ContinuationからJobを取得
    val job = continuation.context[Job]
    if (job != null) {
      lifecycle.addJob(job)
    }
    return continuation
  }
}

fun LifecycleOwner.addJob(job: Job) {
  lifecycle.addJob(job)
}

fun Lifecycle.addJob(job: Job) {
  val state = this.currentState
  val event = when (state) {
      ...
  }
  val observer = LifecycleJobObserver(job, event, this)
  this.addObserver(observer)
  job.invokeOnCompletion(observer)
}

private class LifecycleJobObserver(
  private val job: Job,
  private val event: Lifecycle.Event,
  private val lifecycle: Lifecycle
) : LifecycleObserver, CompletionHandler {
  @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
  fun onEvent(owner: LifecycleOwner, event: Lifecycle.Event) {
    if (event == this.event) {
      owner.lifecycle.removeObserver(this)
      job.cancel()
    }
  }

  override fun invoke(cause: Throwable?) {
    lifecycle.removeObserver(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Android Lifecycleと協調して動くContinuationInterceptorが出来ました。&lt;/p&gt;

&lt;p&gt;フルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample/blob/master/autodispose/src/main/java/com/github/satoshun/coroutine/autodispose/lifecycle/LifecycleContinuationInterceptor.kt&#34;&gt;ここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseActivity : AppCompatActivity(),
  CoroutineScope {

  private val job = Job()
  override val coroutineContext get() = job +
      Dispatchers.Main +
      LifecycleContinuationInterceptor(this) // ここでInterceptorを登録
}

class MainActivity : BaseActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // onCreateでlaunchしているので、onDestroyで自動的にキャンセルされる
    launch {
      ...
    }
  }

  override fun onResume() {
    super.onResume()

    // onResumeでlaunchしているので、onPauseで自動的にキャンセルされる
    launch {
      ...
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;a href=&#34;https://github.com/uber/AutoDispose&#34;&gt;Rx-AutoDispose&lt;/a&gt;のように実行したタイミングに応じて、キャンセルする場所を自動的に登録してくれます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もっと良い書き方が出来るか模索しているので、より適したAPI等を知っている人がいれば教えてくれると嬉しいです😊😊😊&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サンプルコードです😃&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample&#34;&gt;satoshun-android-example/AutoDisposeExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>

&lt;p&gt;この記事ではFragmentでLiveDataにObserverを登録するときは&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;を使うと良いという話をします。&lt;/p&gt;

&lt;p&gt;まず、Fragmentのおおまかなライフサイクルは次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onAttach&lt;/li&gt;
&lt;li&gt;onCreate

&lt;ul&gt;
&lt;li&gt;onCreateView&lt;/li&gt;
&lt;li&gt;onViewCreated

&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestoryView&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestroy&lt;/li&gt;
&lt;li&gt;onDetach&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここで重要なのは、&lt;code&gt;onDestroy&lt;/code&gt;が呼ばれることなく、複数回&lt;code&gt;onCreateView&lt;/code&gt;が呼ばれる可能性がある点です。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っている可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.data.observe(this, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。
このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。
しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。&lt;/p&gt;

&lt;p&gt;前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。
よって、FragmentにはView用のLifecycleが用意されています。それが、&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;前述のコードは次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // ViewのLifecycleOwnerを渡す
        viewModel.data.observe(viewLifecycleOwner, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！&lt;/p&gt;

&lt;h2 id=&#34;補足1&#34;&gt;補足1&lt;/h2&gt;

&lt;p&gt;Observerが開放されるタイミングはonDestroyがコールされるタイミングとは別にもう1つあります。
それは、Observerへの参照がなくなったタイミングです。内部的にObserverはWeakReferenceで保持されており、参照が無くなったタイミングでGCされます。&lt;/p&gt;

&lt;h2 id=&#34;補足2&#34;&gt;補足2&lt;/h2&gt;

&lt;p&gt;Observerの重複登録問題はattach/detachを繰り返す場合におこります。
サンプルコードは次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;while (true) {
    delay(3000)
    supportFragmentManager.commitNow {
        if (fragment.isDetached) attach(fragment)
        else detach(fragment)
　  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>

&lt;p&gt;この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃&lt;/p&gt;

&lt;h2 id=&#34;基本編&#34;&gt;基本編&lt;/h2&gt;

&lt;p&gt;Dagger + ViewModelを同時に使うのは少しツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel @Inject constructor(...): ViewModel()

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だとMainViewModelのインスタンス生成はViewModelProviderを介して行われません。よって次のように書く必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideMainViewModel(...) : MainViewModel {
        // ViewModelProviderを介して行う
        return ViewModelProviders.of(...).get(MainViewModel::class.java)
    }
}

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してインスタンス生成をすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。
このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()
or
class MainViewModel @Inject constructor(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideViewModelFactory(...) : ViewModelProvider.Factory {
        return object: ViewModelProvider.Factory {
            // ここでMainViewModelを生成する
            ...
        }
    }
}

class MainActivity : AppCompatActivity() {
    // ViewModelではなく、Factoryを注入する
    @Inject lateinit var factory: ViewModelProvider.Factory
    // activity-ktxで定義されている拡張関数を使う
    private val viewModel: MainViewModel by viewModels { factory }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;activity-ktxにある&lt;code&gt;viewModels&lt;/code&gt;拡張関数を使ってViewModelインスタンスを生成します。これでViewModelのライフサイクルを保つことができます！！&lt;/p&gt;

&lt;p&gt;Dagger + ViewModelは、大きくこの2つのアプローチがあるかなと思います。&lt;/p&gt;

&lt;h2 id=&#34;実例編&#34;&gt;実例編&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使うパターンと、Factoryを使うパターンのどっちの書き方がいいの？って話になると思うんですが、一長一短かなと思ってます。&lt;/p&gt;

&lt;p&gt;両方アプローチともに、ソースコード、ノウハウが出ているので参考リンクを張っておきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nickbutcher/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/dagger/DribbbleModule.kt#L43&#34;&gt;plaid&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Provides&lt;/code&gt; + ViewModelを直接Injectするパターン&lt;/li&gt;
&lt;li&gt;各ViewModelごとにFactoryクラスを定義する必要があるので記述量は多い&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;コンパイルチェックがうまく動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接Inject出来るので使い側からすると間違った使い方は出来ない（はず）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@marco_cattaneo/android-viewmodel-and-factoryprovider-good-way-to-manage-it-with-dagger-2-d9e20a07084c&#34;&gt;Android ViewModel and FactoryProvider: good way to manage it with Dagger Multibindings&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Daggerのmultibindings + ViewModel FactoryをInjectするパターン&lt;/li&gt;
&lt;li&gt;最初に仕組みを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;multibindingsを使っているのでランタイム時に落ちる可能性がある&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その書き方をするとViewModelProviderを介さないので正しくない。間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ActivityKtxDaggerExample/tree/master/app/src/main/java/com/github/satoshun/example/sample&#34;&gt;Activity-Ktx + Dagger Example&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Factory用のカスタムクラス + ViewModel FactoryをInjectするパターン

&lt;ul&gt;
&lt;li&gt;僕のサンプルコードです😃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最初に汎用クラスを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;コンパイルチェックがうまく動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その書き方をするとViewModelProviderを介さないので正しくない。間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;個人的には一番最後の自分のパターンを押したいところですが、上記のパターンはそれぞれメリット/デメリットがあると思うので、プロジェクトによって使い分けるのがよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一番プロジェクトに適したパターンを適用するのが良いと思います😃&lt;/li&gt;
&lt;li&gt;DaggerでViewModelサポートの&lt;a href=&#34;https://github.com/google/dagger/issues/1271&#34;&gt;ISSUE&lt;/a&gt;が立っており、ViewModel + Daggerの計画があります

&lt;ul&gt;
&lt;li&gt;なので前述のパターンは過去のものとなる可能性が高いです😭&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>

&lt;p&gt;&lt;code&gt;JitPack&lt;/code&gt;からライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。
詳しくは次のリンクを参照してください。&lt;a href=&#34;https://blog.autsoft.hu/a-confusing-dependency/&#34;&gt;A Confusing Dependency&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に &lt;a href=&#34;https://docs.gradle.org/5.1-rc-1/userguide/declaring_repositories.html#sec::matching_repositories_to_dependencies&#34;&gt;Matching repositories to dependencies&lt;/a&gt; が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）&lt;/p&gt;

&lt;p&gt;まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、&lt;code&gt;cloudflare&lt;/code&gt;のSDKを依存関係に入れることを目指します。
また、今回の検証にはGradle 5.1-rc-1を使いました。&lt;a href=&#34;https://github.com/satoshun-android-example/GradleDependencyMatchingExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは従来の書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
        }
    }
}

---

// projectのbuild.gradle
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと全てのライブラリに対して、repositoriesで指定した&lt;code&gt;https://storage.googleapis.com/cloudflare-maven/public/&lt;/code&gt;へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。&lt;/p&gt;

&lt;p&gt;次に新機能を使った書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
            content {
                // group idがcom.cloudflareのライブラリだけこのURLが有効になる
                includeGroup &amp;quot;com.cloudflare&amp;quot;
            }
        }
    }
}

---

// projectのbuild.gradleは一緒
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しくcontentブロックが追加されました。ここで、このURLがどのライブラリで有効になって欲しいかを記述することが出来ます。今回のURLは&lt;code&gt;com.cloudflare:cloudflare-mobile-sdk&lt;/code&gt;でのみ有効になって欲しいので、&lt;code&gt;includeGroup &amp;quot;com.cloudflare&amp;quot;&lt;/code&gt;とgroup id指定することで達成できます。これでcloudflareのライブラリに対してダウンロード制限をかけられます!!&lt;/p&gt;

&lt;p&gt;また今回の事件の場合、JCenterに悪意のあるライブラリがアップロードされたのが問題なので、JCenterからダウンロードしたいライブラリのgroup idを&lt;code&gt;includeGroup&lt;/code&gt;で指定してあげれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {
    ...
    jcenter().mavenContent {
        includeGroup &amp;quot;org.jetbrains.kotlin&amp;quot;
        includeGroup &amp;quot;org.jetbrains.kotlinx&amp;quot;
        includeGroup &amp;quot;com.google.dagger&amp;quot;
        includeGroup &amp;quot;org.jetbrains&amp;quot;
        includeGroup &amp;quot;javax.inject&amp;quot;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、JCenterからダウンロードするライブラリに制限をかけられます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AndroidだとGradle5系を使えるのがAndroid Gradle Plugin3.4からになると思うので、まだ先は長い😂&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://google.github.io/truth/&#34;&gt;Truth&lt;/a&gt;はGoogleが開発をしているテストアサーションライブラリです。&lt;/p&gt;

&lt;p&gt;従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readableにアサーションが書ける&lt;/li&gt;
&lt;li&gt;デフォルトの失敗メッセージがわかりやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;それぞれについて説明していきます。&lt;/p&gt;

&lt;h2 id=&#34;readableにアサーションが書ける&#34;&gt;readableにアサーションが書ける&lt;/h2&gt;

&lt;p&gt;ドキュメントのbenefitにあるサンプルを取り上げ説明します。
&lt;a href=&#34;http://google.github.io/truth/benefits&#34;&gt;http://google.github.io/truth/benefits&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まず従来のJUnitスタイルを使って書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertFalse(middleName.isPresent());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）&lt;/p&gt;

&lt;p&gt;これがTruthを使うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertThat(middleName).isAbsent();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertThatはTruthに定義されているメソッドです。&lt;code&gt;middleName&lt;/code&gt;がabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。&lt;/p&gt;

&lt;p&gt;上記の&lt;code&gt;isAbsent&lt;/code&gt;はOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。
例えばIterableには、&lt;code&gt;containsAnyIn&lt;/code&gt;や&lt;code&gt;isEmpty&lt;/code&gt;などが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;失敗メッセージがわかりやすい&#34;&gt;失敗メッセージがわかりやすい&lt;/h2&gt;

&lt;p&gt;こちらもbenefitにあるサンプルを取り上げます。&lt;/p&gt;

&lt;p&gt;まずは従来にJUnitスタイルから。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertTrue(googleColors.contains(PINK));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。
失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。&lt;/p&gt;

&lt;p&gt;次にTruthスタイルです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertThat(googleColors).contains(PINK);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt;&lt;/code&gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。&lt;/p&gt;

&lt;p&gt;以上がTruthのメリットになります。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;truth-androidライブラリ&#34;&gt;Truth-Androidライブラリ&lt;/h3&gt;

&lt;p&gt;JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。
例えば、Intentには以下のアサーションメソッドを使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hasComponent
hasComponentClass
hasComponentPackage
hasPackage
hasAction
hasNoAction
hasData
hasType
extras
categories
hasFlags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。&lt;/p&gt;

&lt;h3 id=&#34;assertjとの比較&#34;&gt;AssertJとの比較&lt;/h3&gt;

&lt;p&gt;これも公式ドキュメントにまとめてあります。&lt;a href=&#34;http://google.github.io/truth/comparison&#34;&gt;http://google.github.io/truth/comparison&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現状の主だった差分は次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Truhtはまだ1.0.0になっていないのでAPIが変わる可能性がある&lt;/li&gt;
&lt;li&gt;TruthはChainスタイルで書くことを想定していない

&lt;ul&gt;
&lt;li&gt;これは現状のTruth哲学だが、AssertJのようなChainスタイルも普及してきたので、どちらが便利かはわからない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多少の差異はあれど、AssertJとTruthはとても似ているライブラリです。どちらか一方を使っているなら、乗り換えるメリットはおそらくないだろうという旨の内容です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Truthを使うと失敗メッセージがわかりやすくなる、便利!&lt;/li&gt;
&lt;li&gt;AssertJを使っているなら乗り換えるメリットはないかも&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Result&lt;/code&gt;が1.3からstdlibに入ったので紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;Resultは&lt;code&gt;Success T | Failure Throwable&lt;/code&gt;の2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。&lt;/p&gt;

&lt;h2 id=&#34;基本的な使い方&#34;&gt;基本的な使い方&lt;/h2&gt;

&lt;p&gt;使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val i: Result&amp;lt;Int&amp;gt; = Result.success(10)
val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;runCatching&lt;/code&gt;関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a = runCatching { doSomeThing() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resultに対する操作は以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// successに対して操作
val i = Result.success(10)
i.getOrNull() // 10
i.isSuccess // true
i.exceptionOrNull() // null
i.map { 10 * 10 }.getOrNull() // 100
i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
i.recover { 1111 }.getOrNull() // 10

// failureに対して操作
val t = Result.failure(IOException())
t.getOrNull() // null
t.isFailure // true
t.exceptionOrNull() // IOException
t.map { 10 * 10 }.getOrNull() // null
t.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
t.recover { 1111 }.getOrNull() // 1111
t.getOrThrow() // throw IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値successに対しての操作と、failureに対しての操作をそれぞれすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、Resultを使うことで、functionalっぽく書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;try {
    val data = doSomethingSync()
    processData(data)
} catch(e: Throwable) {
    showErrorDialog(e)
}

--&amp;gt;

runCatching { doSomethingSync() }
    .onFailure { showErrorDialog(it) }
    .onSuccess { processData(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クライアント側から見たときは、functionalっぽく書ける点がメリットだと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;resultは戻り値として返せない&#34;&gt;Resultは戻り値として返せない&lt;/h3&gt;

&lt;p&gt;これは、Resultのユースケースから外さないための制約です。なぜなら、Resultはその関数内で処理すべき例外であり、関数の呼び出し側で処理させるべきではないためです。
例えば、ある関数の返り値が&lt;code&gt;Result&amp;lt;User&amp;gt;&lt;/code&gt;となっていたときに、失敗する可能性は呼び出し側に伝わりますが、どのような失敗が起こるか分かりません。どのようにエラーを処理するかはこの関数内で完結すべきなので、返り値としてResultを指定することは出来ません。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にまとめました。より詳細な内容は&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;を見てください😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>

&lt;p&gt;Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングで&lt;code&gt;namespacedRClass&lt;/code&gt;フラグが新しく追加されたので紹介します。
本記事では&lt;code&gt;3.4.0-alpha07&lt;/code&gt;で試しました。&lt;/p&gt;

&lt;p&gt;まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。
それを解決するために&lt;code&gt;namespacedRClass&lt;/code&gt;が追加されました。使い方は簡単で、次の記述を&lt;code&gt;gradle.properties&lt;/code&gt;に追加するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.namespacedRClass=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。
例として、appcompatに依存しているライブラリモジュールを用意します。&lt;/p&gt;

&lt;p&gt;まずは、&lt;code&gt;namespacedRClass=false&lt;/code&gt;の時のRクラスです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class anim {
        private anim() {}

        public static final int abc_fade_in = 0x7f010000;
        public static final int abc_fade_out = 0x7f010001;
        public static final int abc_grow_fade_in_from_bottom = 0x7f010002;
        public static final int abc_popup_enter = 0x7f010003;
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。&lt;/p&gt;

&lt;p&gt;では次に、&lt;code&gt;namespacedRClass=true&lt;/code&gt;の時です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class color {
        private color() {}

        public static final int red3 = 0x7f04004b;
    }
    public static final class id {
        private id() {}

        public static final int title = 0x7f0700b1;
    }
    public static final class layout {
        private layout() {}

        public static final int base3 = 0x7f09001d;
    }
    public static final class string {
        private string() {}

        public static final int base_string3 = 0x7f0b002a;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このモジュールで定義したリソースの内容しか含まれていないことが分かります。appcompatのRクラスは含まれていません。
ライブラリモジュールのRクラスのサイズがかなり小さくすることが出来ました!!&lt;/p&gt;

&lt;p&gt;今後、中、大規模なAndroid開発はマルチモジュールに強く依存することになると思うので、このオプションをつけることで、デバッグ時のapkサイズを抑えることが期待できます。（リリース時はR8/Proguardを使うと思うので特に影響はない）&lt;/p&gt;

&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;

&lt;p&gt;ただし、注意点として、依存関係にあるライブラリのRクラスのマージが行われないため、appcompatなどのRクラスにアクセスしたいときは、明示的にRクラスをimportをする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import androidx.appcompat.R as AppCompatR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までだとライブラリモジュールのRクラスからすべてのリソースにアクセスできたのですが、それができなくなります。なので、このオプションをtrueしたときは、ライブラリモジュールでRクラスのimportパスを変更する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;マルチモジュール時代に適した機能だと思う

&lt;ul&gt;
&lt;li&gt;ライブラリサブモジュールのRクラスのサイズ大きくなる問題を解決できる&lt;/li&gt;
&lt;li&gt;デバッグ時のapkサイズをやや小さく出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; この記事はapiとimplementationの説明をする類の記事ではありません。&lt;/p&gt;

&lt;p&gt;Gradleで&lt;code&gt;compile&lt;/code&gt;がDeprecatedになり、implementationまたはapiを使うことが推奨されています。
それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。&lt;/p&gt;

&lt;p&gt;Dagger2でもcompileをimplementationに置き換えるPRが出されました。&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;https://github.com/google/dagger/pull/1130&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内容が興味深かったのでまとめてみようと思います。&lt;/p&gt;

&lt;p&gt;まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Add Dagger dependencies
dependencies {
  - compile &#39;com.google.dagger:dagger:2.x&#39;
  + implementation &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでjakeさんが&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とコメントしました。「Daggerコンパイラの依存はすべてのモジュールで明示的に書くだろうから、多分implementationで問題ないけど、議論の余地はある。」と。&lt;/p&gt;

&lt;p&gt;この議論を生んだ要因として、Daggerライブラリの性質があります。
Daggerをライブラリで使ったときに、そのライブラリ内ではComponentやModuleを使うため、当然DaggerのAPIを使うことになります。
しかし、クライアント側ではComponentとModuleなどのDaggerのAPIを使う必要は必ずしもありません。ただ、DaggerではLazy、ProviderなどのAPIも定義されており、これらのAPIはクライアント側で使うことが予想されます。
なので、結局このライブラリを依存に持つようなモジュールはLazy、Providerを使うことになるので、最終的にDaggerに依存することが確定しているなら、implementationではなく、apiで指定したほうが良いのではという話です。ただし、プロジェクトのモジュール構成によってはimplementationのほうがふさわしい場合もあるので、その場合はimplementationに置き換えることが期待されています。&lt;/p&gt;

&lt;p&gt;最終的なこの議論の着地として、implementationを使うかapiを使うかはプロジェクトに強く依存するのでどちらが正しいかはない。そのため、今回置き換えたいcompileはapiとほぼ同等の意味を持つので、置き換えるならapiのほうがふさわしいんじゃないか、今までと同じ動作をするので安全じゃないかという感じでまとまりました。&lt;/p&gt;

&lt;p&gt;現状の差分は以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-  compile &#39;com.google.dagger:dagger:2.x&#39;
+  api &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

+ For more information on api vs implementation please see https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?utm_source=android-studio#new_configurations

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dagger-androidがimplementationのままなのは、こちらにはLazyやProviderなどのクライアントライブラリが使うであろうAPIが含まれていないためだと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;READMEを更新するのにかなり熱い議論をしているのがすごい印象的でした

&lt;ul&gt;
&lt;li&gt;手を抜かないって大事なんだなって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;より詳しい議論は、&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;ISSUE&lt;/a&gt;を見て下さい😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>

&lt;p&gt;Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。&lt;/p&gt;

&lt;p&gt;それが&lt;code&gt;3.4.0-alpha07&lt;/code&gt;以降で改善される見込みです🎉&lt;/p&gt;

&lt;p&gt;詳細はここにあります。&lt;a href=&#34;https://issuetracker.google.com/issues/116541301&#34;&gt;https://issuetracker.google.com/issues/116541301&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingApiDeprecateExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります😃&lt;/p&gt;

&lt;h2 id=&#34;エラーログの変化&#34;&gt;エラーログの変化&lt;/h2&gt;

&lt;p&gt;まずどのようなエラーログが出力されるかを見ていきます。
適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。&lt;/p&gt;

&lt;p&gt;まずはData Binding 3.2.1から。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Task :app:kaptGenerateStubsDebugKotlin
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol
  protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root,
                             ^
  symbol:   class DataBindingComponent
  location: class MainAct79Binding
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol
      boolean attachToRoot, @Nullable DataBindingComponent component) {
                                      ^
...
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data Binding周りのエラーログが無限に出ます。悲しい😂&lt;/p&gt;

&lt;p&gt;次に3.4.0-alpha07です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Task :app:kaptGenerateStubsDebugKotlin
e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation
@error.NonExistentClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃&lt;/p&gt;

&lt;h2 id=&#34;クライアント側の対応&#34;&gt;クライアント側の対応&lt;/h2&gt;

&lt;p&gt;これに伴い、一部APIがdeprecatedになります。例えば、&lt;code&gt;main_act.xml&lt;/code&gt;は次のようにAPIが変更されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class MainActBinding extends ViewDataBinding {
  @NonNull
  public static MainActBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup root,
      boolean attachToRoot
  )

  @NonNull
  @Deprecated
  public static MainActBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup root, boolean attachToRoot, @Nullable Object component
  )

  @NonNull
  public static MainActBinding inflate(@NonNull LayoutInflater inflater)

  @NonNull
  @Deprecated
  public static MainActBinding inflate(@NonNull LayoutInflater inflater, @Nullable Object component)

  public static MainActBinding bind(@NonNull View view)

  @Deprecated
  public static MainActBinding bind(@NonNull View view, @Nullable Object component)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使う側の作業としては、上記のdeprecatedになったAPIを置き換える必要があります。ただ、すぐに消えるわけではないので、急いで置き換える必要はないと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AGPのアップデートは気軽に出来ないので、
Data Bindingのバージョンだけをアップデートしようと思ったんですが、エラーが出てしまい出来ませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt &amp;quot;androidx.databinding:databinding-compiler:3.4.0-alpha07&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ERROR: Data Binding annotation processor version needs to match the Android Gradle Plugin version. You can remove the kapt dependency androidx.databinding:databinding-compiler:3.4.0-alpha07 and Android Gradle Plugin will inject the right version.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AGPとData Bindingのバージョンは紐付いているため、片方だけをアップデートしようとしても無理なようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;AGPのアップデートをすればData Bindingのツラミの1つであったエラーログから解放される（かも）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingApiDeprecateExample&#34;&gt;サンプルコードはここ&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Happy Data Binding Life🎉🎉🎉&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 計測方法は実環境に全く即していないので意味がない可能性が高いです。&lt;/p&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AGP3.4.0-alpha06&lt;/li&gt;
&lt;li&gt;Kotlin 1.3.10&lt;/li&gt;
&lt;li&gt;Kotlinx.coroutine 1.0.1&lt;/li&gt;
&lt;li&gt;Gradle 5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;比較対象&#34;&gt;比較対象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;kotlinx.coroutineを使ったサンプル

&lt;ul&gt;
&lt;li&gt;クラス数 300&lt;/li&gt;
&lt;li&gt;各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている&lt;/li&gt;
&lt;li&gt;300 * 7の2100箇所がCoroutine関連のコードになります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;kotlinx.coroutineを使わないサンプル

&lt;ul&gt;
&lt;li&gt;クラス数 300&lt;/li&gt;
&lt;li&gt;各クラスは7つのメソッドを持ち、その中で適当なメソッド（&lt;code&gt;Handler().post {}&lt;/code&gt;）をコールしている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/CoroutineBuildPerfExample&#34;&gt;サンプルコード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;計測コマンド&#34;&gt;計測コマンド&lt;/h3&gt;

&lt;p&gt;Build Scanを使って計測します。その際。build-cacheはoffにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew clean
./gradlew build --no-build-cache --scan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。
また試行回数は10回程度で、最終結果のみを以下に掲載します。&lt;/p&gt;

&lt;h2 id=&#34;kotlinx-coroutineを使う&#34;&gt;kotlinx.coroutineを使う&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Time spent executing tasks 1m 16.034s
    All tasks	207	2m 42.833s
    Tasks avoided	12 (09.7%)	0.062s
    From cache	0 (00.0%)	0.000s
    Up-to-date	12 (09.7%)	0.062s
    Tasks executed	112 (90.3%)	2m 42.739s
    Cacheable	0 (00.0%)	0.000s
    Not cacheable	112 (90.3%)	2m 42.739s
    Lifecycle	45	0.023s
    No source	38	0.009s
    Skipped	0	0.000s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終実行時間は&lt;code&gt;1m 16.034s&lt;/code&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;kotlinx-coroutineを使わない&#34;&gt;kotlinx.coroutineを使わない&lt;/h2&gt;

&lt;p&gt;次に使わない例です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Time spent executing tasks 1m 1.520s
    All tasks	207	1m 57.416s
    Tasks avoided	12 (09.7%)	0.015s
    From cache	0 (00.0%)	0.000s
    Up-to-date	12 (09.7%)	0.015s
    Tasks executed	112 (90.3%)	1m 57.356s
    Cacheable	0 (00.0%)	0.000s
    Not cacheable	112 (90.3%)	1m 57.356s
    Lifecycle	45	0.021s
    No source	38	0.024s
    Skipped	0	0.000s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終実行時間は&lt;code&gt;1m 1.520s&lt;/code&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上記のような結果になりました。しかし、繰り返しになりますが、この比較は実環境に即して無い、そもそもサンプルコードが同等でないため正当じゃないです

&lt;ul&gt;
&lt;li&gt;ただ、Coroutineを入れてある程度の規模まで行くと、フルビルド時のビルド時間の増加は顕著になるかもしれません&lt;/li&gt;
&lt;li&gt;iMac Proを買ってもらいましょう💻s&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もっとこういうふうに比較してほしいであったり、間違っている部分があればご指摘いただければ幸いです😃&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/CoroutineBuildPerfExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>

&lt;p&gt;LiveDataの値を更新したい時、&lt;code&gt;MutableLiveData&lt;/code&gt;を使うのが一般的だと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel {
    val hoge = MutableLiveData&amp;lt;Int&amp;gt;()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だと、外のクラスから値を更新することが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val viewModel = MainViewModel()

// ok
viewModel.hoge.postValue(10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外のクラスからは更新出来ないようにするためには&lt;code&gt;LiveData&lt;/code&gt;に型変換する必要があります。&lt;/p&gt;

&lt;p&gt;例えば次のように書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel {
    private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;()
    val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすることで、外のクラスからは&lt;code&gt;MutableLiveData&lt;/code&gt;が直接見えなくなり、明示的に型変換をしない限り&lt;code&gt;LiveData&lt;/code&gt;の値を更新できなくなります。&lt;/p&gt;

&lt;p&gt;ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。
なので、それの解決策を以下で紹介します。&lt;/p&gt;

&lt;h2 id=&#34;その1&#34;&gt;その1&lt;/h2&gt;

&lt;p&gt;まずコードをのせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ViewModel2 {
  protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) {
    postValue(value)
  }

  protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) {
    setValue(value)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ViewModel2と同じパッケージに定義
public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; {
  @Override
  protected void postValue(T value) {
    super.postValue(value);
  }

  @Override
  protected void setValue(T value) {
    super.setValue(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が定義になります。次に使い方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel2 : ViewModel2() {
  val userName = ViewModelLiveData2&amp;lt;String&amp;gt;()

  fun update() {
    userName.setValue(&amp;quot;test&amp;quot;)
    userName.postValue(&amp;quot;test2&amp;quot;)
  }
}

fun main2() {
  val viewModel = MainViewModel2()

  // compile error!!
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  viewModel.update()
  viewModel.userName.observeForever { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewModelLiveData2&lt;/code&gt;と&lt;code&gt;ViewModel2&lt;/code&gt;を作りました（名前は適当です）。&lt;/p&gt;

&lt;p&gt;ViewModelLiveData2クラスでpostValueメソッドとsetValueメソッドをオーバーライドし、
ViewModel2クラスと同じパッケージに入れることで、ViewModel2からそれらのメソッドをコール出来るようになり、
ViewModel2を継承したクラスからのみLiveDataの値を更新できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewModel.userName.setValue(&amp;quot;&amp;quot;)&lt;/code&gt;とクラス外からsetValueメソッドをコールするとコンパイルエラーになります。&lt;/p&gt;

&lt;p&gt;protectedメソッドが同一パッケージ内からアクセスすることが出来ることを利用したコードになります。&lt;/p&gt;

&lt;h2 id=&#34;その2&#34;&gt;その2&lt;/h2&gt;

&lt;p&gt;こちらもまずコードをのせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ViewModel3 {
  protected fun &amp;lt;T&amp;gt; ViewModelLiveData3&amp;lt;T&amp;gt;.postValue(value: T) {
    internalPostValue(value)
  }

  protected fun &amp;lt;T&amp;gt; ViewModelLiveData3&amp;lt;T&amp;gt;.setValue(value: T) {
    internalSetValue(value)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class ViewModelLiveData3&amp;lt;T&amp;gt; : LiveData&amp;lt;T&amp;gt;() {
  internal fun internalPostValue(value: T) {
    postValue(value)
  }

  internal fun internalSetValue(v: T) {
    value = v
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が定義になります。次に使い方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel3 : ViewModel3() {
  val userName = ViewModelLiveData3&amp;lt;String&amp;gt;()

  fun update() {
    userName.setValue(&amp;quot;test&amp;quot;)
    userName.postValue(&amp;quot;test2&amp;quot;)
  }
}

fun main3() {
  val viewModel = MainViewModel3()

  // compile error
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  viewModel.update()
  viewModel.userName.observeForever { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewModelLiveData3&lt;/code&gt;と&lt;code&gt;ViewModel3&lt;/code&gt;を作りました（名前は適当です）。&lt;/p&gt;

&lt;p&gt;ViewModelLiveData3クラスとViewModel3クラスを適当なサブモジュール内で定義します。
そして、Kotlinのinternalを修飾子を使うことで、外のモジュールからは直接値を更新することができなくなります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;viewModel.userName.setValue(&amp;quot;&amp;quot;)&lt;/code&gt;とクラス外からsetValueメソッドをコールしようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;abstract classをinterfaceにして上記のメソッドをデフォルトメソッドにすると次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface ViewModel2 {
  fun &amp;lt;T&amp;gt; ViewModelLiveData1&amp;lt;T&amp;gt;.setValue(value: T) {
    this.value = value
  }

  fun &amp;lt;T&amp;gt; ViewModelLiveData1&amp;lt;T&amp;gt;.postValue(value: T) {
    postValue(value)
  }
}

fun main() {
  ...

  // compile error
  // viewModel.userName.setValue(&amp;quot;&amp;quot;)

  // ok
  with(viewModel) {
    userName.setValue(&amp;quot;&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;applyやwithを使ってViewModel2がreceiverになると、setValueメソッドがコール出来るため、外から値を更新することが出来てしまいます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;おそらくLiveDataの値を更新する部分は、&lt;code&gt;ViewModel&lt;/code&gt;や&lt;code&gt;Store&lt;/code&gt;クラスに集中すると思うので、それらのBaseクラスで上記のメソッドを定義することで楽ができるようになると思います。&lt;/li&gt;
&lt;li&gt;もっと良い、楽できる書き方があればぜひ教えてください!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いた&lt;a href=&#34;https://github.com/satoshun-android-example/LiveDataRemoveUnderScoreExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/blob/master/CHANGELOG.md#version-250-2018-11-18&#34;&gt;Retrofit 2.5.0&lt;/a&gt;からカスタムアノテーションが使えるようになったので、それの紹介です。&lt;/p&gt;

&lt;p&gt;例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。&lt;/p&gt;

&lt;p&gt;まず最初にアノテーションを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;annotation class RequireAuth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、上記で定義したアノテーションを使い、Apiを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface ApiService {
  @RequireAuth
  @GET(&amp;quot;login&amp;quot;)
  fun login(: retrofit2.Call&amp;lt;Unit&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;RequireAuth&lt;/code&gt;を処理するための&lt;code&gt;okhttp3.Interceptor&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class AuthInterceptor : Interceptor {
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()

    val invocation = request.tag(Invocation::class.java)
    val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)
    if (authAnnotation != null) {
      request = request
        .newBuilder()
        .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic AAAAA&amp;quot;).build()
    }
    return chain.proceed(request)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは、&lt;code&gt;val invocation = request.tag(Invocation::class.java)&lt;/code&gt;です。
Retrofit 2.5.0から&lt;code&gt;Invocation&lt;/code&gt;が追加され、&lt;code&gt;Request&lt;/code&gt;から&lt;code&gt;Invocation&lt;/code&gt;が取得できるようになりました。
&lt;code&gt;Invocation&lt;/code&gt;には、処理している&lt;code&gt;Request&lt;/code&gt;の&lt;code&gt;java.lang.reflect.Method&lt;/code&gt;が格納されており、
そこからアノテーションの情報を取得することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java)&lt;/code&gt;で、
メソッドに&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションが付与されているかどうかを知ることが出来ます。
&lt;code&gt;RequireAuth&lt;/code&gt;アノテーションがついていれば、&lt;code&gt;Request&lt;/code&gt;のヘッダーに認証情報を追加します。&lt;/p&gt;

&lt;p&gt;最後に、上記の&lt;code&gt;Interceptor&lt;/code&gt;をOkHttpクライアントに付与します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val client = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor())
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでRetrofitでカスタムアノテーションを使うことが出来ます!!&lt;/p&gt;

&lt;h2 id=&#34;invocation以前の場合&#34;&gt;Invocation以前の場合&lt;/h2&gt;

&lt;p&gt;Invocation以前は、&lt;code&gt;Headers&lt;/code&gt;を使い認証情報を付与するテクニックがありました。
詳しくは&lt;a href=&#34;https://speakerdeck.com/jakewharton/making-retrofit-work-for-you-ohio-devfest-2016?slide=39&#34;&gt;Making Retrofit Work For You&lt;/a&gt;にあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Headers(&amp;quot;Auth: true&amp;quot;)
@GET(&amp;quot;useheaderlogin&amp;quot;)
fun login(): retrofit2.Call&amp;lt;Unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Auth2Interceptor : Interceptor {
  override fun intercept(chain: Interceptor.Chain): Response {
    var request = chain.request()

    if (request.header(&amp;quot;Auth&amp;quot;) != null) {
      request = request
        .newBuilder()
        .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic BBBBB&amp;quot;).build()
    }
    return chain.proceed(request)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでも動くのですが、カスタムアノテーションを定義するやり方のほうが意味が伝わりやすいと思うので、よりよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Retrofit 2.5.0でInvocationが追加されてカスタムアノテーションが使えるようになりました

&lt;ul&gt;
&lt;li&gt;さらにInvocationはメソッドの引数リストを持っており、ログやアナリティクスなどに有効に使うことができます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/RetrofitCustomAnnotationExample&#34;&gt;ここに&lt;/a&gt;あります😃&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>