<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Tue, 19 Mar 2019 12:31:05 UTC</updated>
    
    
    <item>
      <title>Kotlin: コンストラクタ呼び出しっぽく関数やcompanion objectを使う</title>
      <link>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</link>
      <pubDate>Tue, 19 Mar 2019 12:31:05 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</guid>
      <description>

&lt;p&gt;KotlinではJavaと異なり、コンストラクタ呼び出しの時に&lt;code&gt;new&lt;/code&gt;キーワードが必要ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A
...
val a = A()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よって、次のように関数をコンストラクタのように使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Coroutine Jobの定義
@Suppress(&amp;quot;FunctionName&amp;quot;)
public fun Job(parent: Job? = null): Job = JobImpl(parent)
...
val job = Job()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、次のようにcompanion object + operator invokeを使うことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ref: https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter
class CoroutineCallAdapterFactory private constructor() : CallAdapter.Factory() {
  companion object {
    @JvmStatic @JvmName(&amp;quot;create&amp;quot;)
    operator fun invoke() = CoroutineCallAdapterFactory()
  }
}
...
val factory = CoroutineCallAdapterFactory()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JobImplのような実装クラスを隠したいときに便利&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>

&lt;p&gt;Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { MainService.task1() }
  val task2 = async { MainService.task2() }

  println(&amp;quot;${task1.await()}\n${task2.await()}&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asyncで包むことで、並列に処理をすることができます。&lt;/p&gt;

&lt;p&gt;次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元で&lt;code&gt;runCatching&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { runCatching { MainService.task1() } }
  val task2 = async { runCatching { MainService.task2() } }

  val result1 = task1.await()
  val result2 = task2.await()
  println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;runCatching&lt;/code&gt;を使うことで、呼び出し先で例外が起こったとしても、処理を継続することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;また、次のように書くことは出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { MainService.task1() }
  val task2 = async { MainService.task2() }

  // awaitのタイミングでrunCatchingを使う
  val result1 = runCatching { task1.await() }
  val result2 = runCatching { task2.await() }
  println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デフォルトの設定だと例外は伝搬し、子が倒れたら親も倒れます。&lt;/p&gt;

&lt;p&gt;しかし、&lt;code&gt;supervisorScope&lt;/code&gt;を使うと、上記の振る舞いを防ぐことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  supervisorScope {
    val task1 = async { MainService.task1() }
    val task2 = async { MainService.task2() }

    // supervisorScopeを使っているのでこのタイミングでもおｋ
    val result1 = runCatching { task1.await() }
    val result2 = runCatching { task2.await() }
    println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;supervisorScope&lt;/code&gt;を使うと、&lt;code&gt;Deferred.await&lt;/code&gt;のタイミングで例外のハンドリングをすることが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最後にキャンセルについて考えてみます。&lt;/p&gt;

&lt;p&gt;任意の子ジョブがキャンセルされても処理を続けたいとしたら、前述のsupervisorScopeを使う必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  supervisorScope {
    val task1 = async { MainService.task1() }
    val task2 = async { MainService.task2() }

    val result1 = runCatching { task1.await() }
    val result2 = runCatching { task2.await() }
    println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、例えばtask1がキャンセルされたとしても、他の部分の処理を継続することが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;エラー &amp;amp; キャンセル時にも処理を継続したいならsupervisorScope + runCatchingを使う&lt;/li&gt;
&lt;li&gt;エラー時のみ処理を継続したいなら、runCatchingだけで対応できる&lt;/li&gt;
&lt;li&gt;正常系のみなら、asyncで包んであげるだけで良い&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>

&lt;p&gt;Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、
どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。&lt;/p&gt;

&lt;p&gt;以下、&lt;del&gt;2019年3月10日&lt;/del&gt; 2019年3月11日の調査結果になります。
また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。&lt;/p&gt;

&lt;p&gt;Lifecycle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Lifecycleに従うCoroutineScopeの生成
val Lifecycle.coroutineScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LifecycleOwner&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// LifecycleOwnerに従うCoroutineScopeの生成
val LifecycleOwner.lifecycleScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewModel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ViewModelに従うCoroutineScopeの生成
val ViewModel.viewModelScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WorkManager&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class CoroutineWorker(
  appContext: Context,
  params: WorkerParameters
) : ListenableWorker(appContext, params) {
  // suspendメソッドで定義された
  abstract suspend fun doWork(): Result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Room&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Dao内でsuspendメソッドが使える
@Dao
interface HogesDao {
  @Insert
  suspend fun add(hoge: Hoge)

  @Query(&amp;quot;SELECT * FROM hoge WHERE id = :id&amp;quot;)
  suspend fun get(id: String): Hoge

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lifecycle、LifecycleOwner、ViewModelはそれらのライフサイクルに従う、CoroutineScopeの生成が出来る&lt;/li&gt;
&lt;li&gt;WorkManagerのdoWorkがsuspendメソッドになった

&lt;ul&gt;
&lt;li&gt;doWorkの中で、他のsuspendメソッドがコールできる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RoomのDao内でsuspendメソッドが定義出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;結構対応がされていた😃😃😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;LiveDataへのサポートも入るかも

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android-review.googlesource.com/c/platform/frameworks/support/+/890736&#34;&gt;WIP corutine live data (Id0e47973) · Gerrit Code Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Lifecycleに特定のstateに入った時に実行される拡張関数群が入りそう

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android-review.googlesource.com/c/platform/frameworks/support/+/905134&#34;&gt;Lifecycle Dispatcher (Ib1211c0f) · Gerrit Code Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger2: ProvidesはKotlin extension methodと一緒に使うことが出来る</title>
      <link>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</link>
      <pubDate>Tue, 05 Mar 2019 00:10:42 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</guid>
      <description>

&lt;p&gt;Dagger2のちょっとしたtipsです。&lt;/p&gt;

&lt;p&gt;次の2つのメソッドは同じ振る舞いをします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module
class MainActivityModule {
  // 普通の書き方
  @Provides fun provideMainContractView(activity: MainActivity): MainContract.View {
    return activity
  }

  // 拡張関数を使った書き方
  @Provides fun MainActivity.provideMainContractView(): MainContract.View {
    return this
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、拡張関数はコンパイルされると次のように解釈されるためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
   @Provides
   @NotNull
   public final MainContract.View provideMainContractView(@NotNull MainActivity $receiver) {
      Intrinsics.checkParameterIsNotNull($receiver, &amp;quot;receiver$0&amp;quot;);
      return (MainContract.View)$receiver;
   }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拡張関数として定義したMainActivityは&lt;code&gt;$receiver&lt;/code&gt;となり、引数に入っていることが分かります。拡張関数は上記のように解釈されるため、&lt;code&gt;@Provides&lt;/code&gt;と組み合わせて使うことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;多分、使い所ないと思います😃😃😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>

&lt;p&gt;RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。&lt;/p&gt;

&lt;h2 id=&#34;issueの内容&#34;&gt;Issueの内容&lt;/h2&gt;

&lt;p&gt;実際のIssueは &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/issues/441&#34;&gt;HandlerScheduler.scheduleDirect supports async option?&lt;/a&gt; になります。&lt;/p&gt;

&lt;p&gt;Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これは&lt;code&gt;Worker.schedule&lt;/code&gt;のスケジュールからのみのサポートでした。RxJavaでは&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;でもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。&lt;/p&gt;

&lt;h2 id=&#34;そもそもこの問題に気づいたきっかけ&#34;&gt;そもそもこの問題に気づいたきっかけ&lt;/h2&gt;

&lt;p&gt;RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。&lt;/p&gt;

&lt;h2 id=&#34;調べ方&#34;&gt;調べ方&lt;/h2&gt;

&lt;p&gt;クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。&lt;/p&gt;

&lt;p&gt;結果、&lt;code&gt;Observable.observeOn&lt;/code&gt;では&lt;code&gt;Worker.schedule&lt;/code&gt;メソッドでタスクのスケジューリングをし、&lt;code&gt;Maybe.observeOn&lt;/code&gt;では&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;メソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。&lt;/p&gt;

&lt;h2 id=&#34;その他-感想&#34;&gt;その他・感想&lt;/h2&gt;

&lt;h3 id=&#34;jakeさんとzacさんにレビューをしてもらった&#34;&gt;JakeさんとZacさんにレビューをしてもらった&lt;/h3&gt;

&lt;p&gt;二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>

&lt;p&gt;Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。
まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、&lt;code&gt;AndroidJUnit4&lt;/code&gt;ランナーが使えるなど、かなりの部分が共通化出来ます。&lt;/p&gt;

&lt;p&gt;この記事では、ユニットテストで&lt;code&gt;Activity.onActivityResult&lt;/code&gt;のテストをどこまでandroid testのように書けるかを検証します。&lt;/p&gt;

&lt;h2 id=&#34;テスト対象コード&#34;&gt;テスト対象コード&lt;/h2&gt;

&lt;p&gt;まず最初に、テスト対象コードは次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  ...
  override fun onCreate(savedInstanceState: Bundle?) {
    ...

    button.setOnClickListener {
      startActivityForResult(
        Intent(this, Sub2Activity::class.java).apply {
          putExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;)
        },
        1
      )
    }
  }

  override fun onActivityResult(
    requestCode: Int,
    resultCode: Int,
    data: Intent?
  ) {
    super.onActivityResult(requestCode, resultCode, data)
    if (requestCode == 1) {
      if (resultCode == Activity.RESULT_OK) {
        val value = data!!.getIntExtra(&amp;quot;test&amp;quot;, -1)
        button.text = value.toString()
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Sub2Activity : AppCompatActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)

    button.setOnClickListener {
      val intent = Intent()
      intent.putExtra(&amp;quot;test&amp;quot;, 10)
      setResult(Activity.RESULT_OK, intent)
      finish()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはMainActivityで&lt;code&gt;startActivityForResult&lt;/code&gt;がコールされ、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;で値をセットし、MainActivityの&lt;code&gt;onActivityResult&lt;/code&gt;で結果を受け取るサンプルコードになります。&lt;/p&gt;

&lt;p&gt;では、テストを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;テストコード&#34;&gt;テストコード&lt;/h2&gt;

&lt;p&gt;以下が、今回書いたテストコードになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(AndroidJUnit4::class)
internal class MainActivityTest {
  @get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)

  @Test
  fun onActivityResultTest() {
    val expectCode = 10

    // assertion setResult
    val scenario = ActivityScenario.launch(Sub2Activity::class.java)
    scenario.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
    }

    // assertion resultCode
    val result = scenario.result
    assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

    // assertion intent params
    val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
    bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)

    scenario.close()

    Intents
      .intending(
        IntentMatchers.hasComponent(
          ComponentName(
            ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
            Sub2Activity::class.java
          )
        )
      )
      .respondWith(result)

    val main = ActivityScenario.launch(MainActivity::class.java)
    main.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

      // assertion intent for startActivity(ForResult)
      val name = ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
      Intents.intended(IntentMatchers.hasComponent(name))
      Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

      // assertion onActivityResult behaves
      Espresso
        .onView(ViewMatchers.withId(R.id.button))
        .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上から順番に重要な部分を説明していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、Espresso-Intentsを使うときに必要なルールです。&lt;code&gt;Intens.intended&lt;/code&gt;、&lt;code&gt;intending&lt;/code&gt;を使うために必要なルールになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val scenario = ActivityScenario.launch(Sub2Activity::class.java)
scenario.onActivity {
    it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioはActivityを起動するためのクラスです。これはSub2Activityを起動して、ボタンをクリックするという意味になります。
ボタンがクリックされると、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;が発火するようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val result = scenario.result
assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioでは、ActivityResultクラスから結果を取得することが出来ます。このクラスにはresultCodeと、resultDataがセットされており、それらの値をTruthを使いチェックします。この場合、&lt;code&gt;setResult&lt;/code&gt;で、resultcodeに&lt;code&gt;Activity.RESULT_OK&lt;/code&gt;が、resultdataにはキー名&lt;code&gt;test&lt;/code&gt;、値10がセットされていることを確認してします。&lt;/p&gt;

&lt;p&gt;ここまでで、Sub2ActivityのsetResultで正しい値をセットしていることがテスト出来ます。&lt;/p&gt;

&lt;p&gt;では次に、MainActivityで上記の値を受け取れることをテストしていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Intents
  .intending(
    IntentMatchers.hasComponent(
      ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
    )
  )
  .respondWith(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Intents.intending&lt;/code&gt;はマッチしたIntentが発行されたときに、onActivityResultに結果を返すAPIになります。
MainActivityのonActivityResultに、先ほどのSub2Activityの結果を渡すという意味になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val main = ActivityScenario.launch(MainActivity::class.java)
main.onActivity {
  it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

  val name = ComponentName(
    ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
    Sub2Activity::class.java
  )
  Intents.intended(IntentMatchers.hasComponent(name))
  Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

  Espresso
    .onView(ViewMatchers.withId(R.id.button))
    .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは、クリックイベントを発火し、&lt;code&gt;startActivityForResult&lt;/code&gt;をコールします。渡したIntentを&lt;code&gt;Intents.intended&lt;/code&gt;で正しいことを確認します。最後に、Espressoを使って、&lt;code&gt;onActivityResult&lt;/code&gt;の結果を正しく反映されているかを確認します。&lt;/p&gt;

&lt;p&gt;これで、テスト完了です😃
2つのActivityに関連するonActivityResultのテストが無事に出来ました！！&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Espressoにはご存知、clickをするためのAPIがあるのですが、うまく動きませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// not working!!
Espresso
  .onView(ViewMatchers.withId(R.id.button))
  .perform(ViewActions.click())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;調べたんですが、原因がわかりませんでした😂分かり次第追記します。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上記のテストくらいなら、ユニットテストで書ける。すごい😃

&lt;ul&gt;
&lt;li&gt;onActivityResultみたいな、クラス間のつながりが弱い部分は意図せず壊れやすいので、テストを書いておくと安心かも😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/tests/lifecycle/MainActivityTest.kt&#34;&gt;satoshun-android-example/Tests&lt;/a&gt;にあります。&lt;/p&gt;

&lt;p&gt;もっと良い書き方を知っているよと言う人は教えて頂けるととても嬉しいです😃😃😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>

&lt;p&gt;マルチモジュール遷移方法Part2です。&lt;a href=&#34;https://satoshun.github.io/2018/12/multi-module_transition_part1/&#34;&gt;Part1&lt;/a&gt;はここになります😌&lt;/p&gt;

&lt;p&gt;Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。&lt;/p&gt;

&lt;p&gt;また、今回の検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;モジュール構成について&#34;&gt;モジュール構成について&lt;/h2&gt;

&lt;p&gt;細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/img/SoWkIImgAStDuU8goIp9ILLutBpeSTEEnyrB7pVlUToy-kdipLnS1Od9sOdfgGfAYGK5yMcfYIMbHQbA2jLS2WhHG95O45sKNrgIMXJBLOkakhWqoH1DEKWe5iQ8nw7925EJ4KoJ4RAcvFpSWloyrBmIi3lGN1wha5Yi01H6LWNHYqqXH0PPxUF6kOyRrptPFGqi3t8likpBnktFb-z-tBJaSVFcnqtxmIPDVToq7CHesWdN4a-4kKQacmiB1Iuka2KAkdOebe4KGCKG2e4XeQ2Rab-U1rCC3MDq2IEi4Z1Jk20Cg7WDghrOv13sEwJcfG2J6G00&#34; width=600&gt;&lt;/p&gt;

&lt;p&gt;各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。&lt;/p&gt;

&lt;p&gt;このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。&lt;/p&gt;

&lt;p&gt;では、実装に入っていきます。今回はDagger2を使って実装をします。&lt;/p&gt;

&lt;h2 id=&#34;featureモジュール側の遷移用インターフェースの定義&#34;&gt;featureモジュール側の遷移用インターフェースの定義&lt;/h2&gt;

&lt;p&gt;前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。&lt;/p&gt;

&lt;p&gt;main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainModuleRouter {
  // sub1画面へ移動する
  fun routeToSub1()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mainモジュール用のインターフェースなので、&lt;code&gt;MainModuleRouter&lt;/code&gt;という名前にし、sub1画面へ遷移するためのメソッドを定義しています。&lt;/p&gt;

&lt;p&gt;そしてこのインターフェースを、MainFragmentで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment : Fragment() {
  @Inject lateinit var moduleRouter: MainModuleRouter

  ...

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    view.findViewById&amp;lt;View&amp;gt;(R.id.route).setOnClickListener {
      moduleRouter.routeToSub1()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでfeatureモジュールでの遷移用インターフェースの定義は完了です。&lt;/p&gt;

&lt;p&gt;次にこのインターフェースの実装をします。&lt;/p&gt;

&lt;h2 id=&#34;routerモジュール側の遷移用インターフェースの実装&#34;&gt;routerモジュール側の遷移用インターフェースの実装&lt;/h2&gt;

&lt;p&gt;今回は、遷移用インタフェースの実装をrouterモジュールで行います。まずは、Navigation Componentを用いて、Graphを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
  android:id=&amp;quot;@+id/nav_graph&amp;quot;
  app:startDestination=&amp;quot;@id/nav_main_frag&amp;quot;&amp;gt;

  &amp;lt;fragment
    android:id=&amp;quot;@+id/nav_main_frag&amp;quot;
    android:name=&amp;quot;com.github.satoshun.example.feature.main.MainFragment&amp;quot;&amp;gt;

    &amp;lt;action
      android:id=&amp;quot;@+id/main_to_sub1&amp;quot;
      app:destination=&amp;quot;@id/nav_sub1_frag&amp;quot; /&amp;gt;
  &amp;lt;/fragment&amp;gt;

  ...
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、これを用いて遷移用インターフェースを実装します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainModuleRouterImpl @Inject constructor(
  private val controller: NavController
) : MainModuleRouter {
  override fun routeToSub1() {
    // NavComponentで自動生成されるコードを用いて遷移
    controller.navigate(MainFragmentDirections.mainToSub1())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実装は完了です。Navigation Componentを使っているため、実装はかなり楽です。&lt;/p&gt;

&lt;p&gt;あとはDaggerで配るだけです。Daggerで配る部分はサンプルコードを見ていただけたらと思います。サンプルでは、Dagger Androidを用いています。&lt;/p&gt;

&lt;h2 id=&#34;メモ&#34;&gt;メモ&lt;/h2&gt;

&lt;h3 id=&#34;routerモジュールをわざわざ作る必要はないかも&#34;&gt;routerモジュールをわざわざ作る必要はないかも&lt;/h3&gt;

&lt;p&gt;構成図を見てほしいのですが、実はrouterモジュールをわざわざ作る必要はなく、appモジュールに含めても良いです。routerモジュールを作るのがめんどう、もしくは意味がないと感じるなら、appモジュールで実装しても良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Navigation Componentでモジュール間の遷移を宣言的にXMLで書けるのは見やすくて非常に良いと思いました。

&lt;ul&gt;
&lt;li&gt;またNavigation Componentはactivityの記述もできるので、既存アプリへの導入も比較的しやすいと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;app/routerでは各featureモジュールへの依存を持つことができるので、クラスへの参照を持ちながら、navgationのgraphを作ることができる

&lt;ul&gt;
&lt;li&gt;navigation graphはActivity/Fragmentへの参照を持たなくても作ることが可能だが、持ったほうがLintなどの兼ね合いで安全&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次は最終章になる予定です。DFMの遷移について書きます😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>

&lt;p&gt;マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）&lt;/p&gt;

&lt;p&gt;例えば、以下のモジュール構成を考えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0mYXQcxO-RfvcY4rbSMcI8QPI8nnAZRYuk81cA-Ycv9VdwTf1TAC90DKufEQb0Bq40000&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0miXQGGPEcunDOMPnQHAA9KrR7pTFCyIc5AZI45Ef4GwbHbnSN41NAEYcv9VdwTf1BE82aN0Xi87e8a1z3gbvAS000G00&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。&lt;/p&gt;

&lt;p&gt;ただし、いくつか条件があります。&lt;/p&gt;

&lt;h3 id=&#34;1-中間モジュールで公開可能なものに限る&#34;&gt;1. 中間モジュールで公開可能なものに限る&lt;/h3&gt;

&lt;p&gt;例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。
これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。&lt;/p&gt;

&lt;p&gt;中間モジュールのコードイメージとしては以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun createUserFragment(userName: String, age: Int): Fragment {
  return UserFragment.createFragment(userName, age)
}

fun createUserIntent(context: Context): Intent {
  return Intent(context, UserActivity::class.java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserActivity、UserFragmentが公開されていないことが分かります。Androidのいわゆるfeatureモジュールでは、Activity、Fragmentを公開する場合が多いと思うので、その場合には有効に使うことができます。&lt;/p&gt;

&lt;h3 id=&#34;2-implementationで依存を定義する&#34;&gt;2. implementationで依存を定義する&lt;/h3&gt;

&lt;p&gt;apiを使うと、依存が推移するため再ビルドが行われてしまうためです。implementationで依存を記述する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;3-dagger2使ってると多分無理&#34;&gt;3. Dagger2使ってると多分無理&lt;/h3&gt;

&lt;p&gt;Dagger2では、解決する依存をAppComponentで知っている必要があります。上記の構成だと、appでAppComponentを持つことになるので、appからsub1、sub2が見えていないと最終的にDagger2で解決できません。なので、中間モジュールで、appからsubの依存が見えなくなるこのパターンは使えません。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://github.com/google/dagger/issues/970&#34;&gt;Dagger/#970&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;やりすぎ感はある

&lt;ul&gt;
&lt;li&gt;ただでさえ複雑な、モジュール構成がさらに煩雑になりそう。ただし、最終的には消えるので、差分ビルドの恩恵を受けるためのステップだとすれば許せるかも?&lt;/li&gt;
&lt;li&gt;Dagger2を使っていると推移的依存が必要になり、使えない、もしくは工夫が必要になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルは&lt;a href=&#34;https://github.com/satoshun-android-example/ApplicationModulesSpeedUpExample&#34;&gt;satoshun/ApplicationModulesSpeedUpExample&lt;/a&gt;にあります

&lt;ul&gt;
&lt;li&gt;サブモジュールを変更したときのビルドは爆速でした😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Daggerの部分のいい解決方法を知っている人がいたら、教えて頂けると幸いです😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>DroidKaigi2019で「R8/ProGuard 徹底比較」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2019/02/droidkaigi-2019/</link>
      <pubDate>Thu, 07 Feb 2019 13:19:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/droidkaigi-2019/</guid>
      <description>&lt;p&gt;DroidKaigi2019でセッションが採択されたので発表しました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;b801b49e61ef4c478e6020941393b9ed&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao&#34;&gt;https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最初に発表の反省点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多く詰め込みすぎて、1つ1つの掘り下げが疎かになった

&lt;ul&gt;
&lt;li&gt;結果的に広く浅い発表になってしまったため、1つの1つがあまり丁寧に説明できていなかったように感じています。重要な部分はもう少し丁寧に発表すべきでした。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;早口すぎ、俺は生き急いでるのか？

&lt;ul&gt;
&lt;li&gt;本当に申し訳ありませんでした。前日に最終確認したところ20分近くオーバーしてしまい、そこからある程度は間引いたんですが、早口でいくという戦略を取ってしまいました😂 他の方の発表のように聞きやすい発表を今後は意識していきます！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;次に良かった点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;発表前の休憩時間に、司会の@neonankitiさんの助けで、アイスブレイク?のようなことができた

&lt;ul&gt;
&lt;li&gt;@neonankitiさんとは初対面だったんですが、謎の掛け合いができ、会場の雰囲気も良くなったように思います😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;なんだかんだとR8のコードを触れたのは良かった

&lt;ul&gt;
&lt;li&gt;R8コンパイラのコードに触れるかどうか悩んだのですが、printデバッグなどを駆使して、理解が間違っていないことが確認できたので、載せてみました。概要だけですが、個人的には良かったと思っています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最後に話した実践編のウケが良くてよかった

&lt;ul&gt;
&lt;li&gt;R8の凄さが分かりやすく伝えられたのかなと思います😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;最後に、僕の発表を聞きに来てくれた人、運営のみなさんありがとうございました😊&lt;/p&gt;

&lt;p&gt;また来年もあれば登壇できるように頑張ります💪&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bit.ly/2UQggVj&#34; alt=&#34;DroidKaigi2019&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: JarファイルからProGuard設定ファイルを読み込んでくれるようになりました</title>
      <link>https://satoshun.github.io/2019/01/r8-proguard-metainf/</link>
      <pubDate>Mon, 28 Jan 2019 00:08:35 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-proguard-metainf/</guid>
      <description>

&lt;p&gt;&lt;del&gt;AGP3.3.0&lt;/del&gt;ProGuardはAGP3.3.0、R8は導入されたAGP3.2.0から、JarファイルのProGuard設定ファイルを組み込めるようになりました。その機能紹介です。
今まで、aarでは&lt;code&gt;consumerProguardFiles&lt;/code&gt;で、ライブラリのProGuard設定を指定できました。それのJar、Javaバージョンとなります。&lt;/p&gt;

&lt;h2 id=&#34;ライブラリ開発者側の設定&#34;&gt;ライブラリ開発者側の設定&lt;/h2&gt;

&lt;p&gt;RetrofitなどのSquare社のライブラリでは、早くもこの機能に対応しているので、それを例にして説明します。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;resources/META-INF/prougard&lt;/code&gt;ディレクトリの中にProGuardの設定ファイルを置きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/tree/master/retrofit/src/main/resources/META-INF/proguard&#34;&gt;square/retrofit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライブラリ側の設定はこれで完了です。&lt;/p&gt;

&lt;h2 id=&#34;使う側の設定&#34;&gt;使う側の設定&lt;/h2&gt;

&lt;p&gt;AGP3.3.0にアップデートするだけで使えます。META-INF/ProGuardはRetrofitの2.5.0から入っているので、まずはMETA-INFが入っていない、2.4.0でビルドをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.4.0&amp;quot;

&amp;gt; ./gradlew installRelease
...
Warning: there were 267 unresolved references to classes or interfaces.
         You may need to add missing library jars or update their versions.
         If your code works fine without the missing classes, you can suppress
         the warnings with &#39;-dontwarn&#39; options.
         (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedclass)
Warning: Exception while processing task java.io.IOException: Please correct the above warnings first.
Thread(Tasks limiter_2): destruction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;失敗しました😂&lt;/p&gt;

&lt;p&gt;次にMETA-INFが入った2.5.0でビルドをします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.5.0&amp;quot;

&amp;gt; ./gradlew installRelease
...

BUILD SUCCESSFUL in 21s
38 actionable tasks: 18 executed, 20 from cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功しました😊&lt;/p&gt;

&lt;p&gt;META-INFファイルをちゃんと読み込めているようです。ProGuardのconfigurationファイルを確認したところ、RetrofitのProGuard設定が入っていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// configuration.txt
...
# Retain service method parameters when optimizing.
-keepclassmembers,allowshrinking,allowobfuscation interface  * {
    @retrofit2.http.*
    &amp;lt;methods&amp;gt;;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;この機能はR8/ProGuard、両方とも対応しているようです。&lt;/p&gt;

&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;

&lt;p&gt;最初、冒頭でR8もAGP3.3.0からと書いたんですが、それは誤りで、AGP3.2.0のR8が導入されたタイミングでした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kafumi__/status/1089816485386747905&#34;&gt;@kafumi__&lt;/a&gt;さんにご指摘いただきました！ありがとうございます😊&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ライブラリがJarであったとしても、ライブラリ作者が対応してくれればProGuardの設定が楽になる!!!

&lt;ul&gt;
&lt;li&gt;現状、有名なライブラリでは、OkHttp、Retrofit、Coroutineなどが対応しています😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;この機能がProGuardでも使えるのを知らなかったので、公式ドキュメントなどのリンクを知っている方がいれば教えてほしいです🙏🙏🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>

&lt;p&gt;FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。&lt;/p&gt;

&lt;p&gt;結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂&lt;/p&gt;

&lt;p&gt;また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。&lt;/p&gt;

&lt;h2 id=&#34;room-in-memory&#34;&gt;Room in memory?&lt;/h2&gt;

&lt;p&gt;Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。&lt;/p&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Room
  .inMemoryDatabaseBuilder(context, MyDatabase::class.java)
  .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in memoryを使う理由としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ディスパッチするアクションを永続化する必要はないだろう&lt;/li&gt;
&lt;li&gt;マイグレーションが必要ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;実装に入っていく&#34;&gt;実装に入っていく&lt;/h2&gt;

&lt;p&gt;では、実装の説明をしていきます。&lt;/p&gt;

&lt;p&gt;まずはActionをRoomのEntityとして定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sealed class AuthorAction

@Entity(tableName = &amp;quot;author1&amp;quot;)
data class Author1(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()

@Entity(tableName = &amp;quot;author2&amp;quot;)
data class Author2(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、&lt;code&gt;@PrimaryKey(autoGenerate = true)&lt;/code&gt;を使っても良いと思います。&lt;/p&gt;

&lt;p&gt;次にDaoを定義します。これはFluxでいうところのDispatcherになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Dao
interface AuthorDispatcher {
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author1)
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author2)

  // Storeに相当する
  @Query(&amp;quot;select * FROM author1 WHERE _id = 0&amp;quot;)
  fun author(): LiveData&amp;lt;Author1?&amp;gt;

  // Storeに相当する
  @Query(
    &amp;quot;&amp;quot;&amp;quot;
    select author1.name as name1, author2.name as name2
    FROM author1
     INNER JOIN author2
    WHERE author1._id = 0 AND author2._id = 0
    &amp;quot;&amp;quot;&amp;quot;
  )
  fun mappedAuthor(): LiveData&amp;lt;MappedAuthor?&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;code&gt;@Insert&lt;/code&gt;でアクションをdispatchメソッドを、&lt;code&gt;@Query&lt;/code&gt;でsubscribeメソッドを実装しています。&lt;/p&gt;

&lt;p&gt;これで、FluxのDispatcherに似た何かをRoomで表現することが出来ます！&lt;/p&gt;

&lt;h2 id=&#34;まとめ-考察&#34;&gt;まとめ/考察&lt;/h2&gt;

&lt;p&gt;RoomでDispatcher的なのを作る方法と、EventBusなどを使ったアプローチの違いは以下になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Storeに書いていたロジックをSQLに任せることが出来る

&lt;ul&gt;
&lt;li&gt;Transactionを上手く使えば、マルチスレッド環境でもそれっぽく動きそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ほげほげDispactherクラスがアプリ内に蔓延する&lt;/li&gt;
&lt;li&gt;コードが冗長😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工夫すれば、もう少しキレイに書けるとは思いますが、ただEventBusや、Coroutineを使ったアプローチには敵わないと思っています。
FluxのDispatcherの代替としては辛いですが、他の用途、例えばRepositoryの実装などには使える余地があると思うので、そういったところで思い出していただけたら幸いです😊&lt;/p&gt;

&lt;p&gt;検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/RoomDispatcherExample&#34;&gt;RoomDispatcherExample&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Daggerの生成コードがR8でどのように変わるかを見る</title>
      <link>https://satoshun.github.io/2019/01/r8-dagger-optimize/</link>
      <pubDate>Sun, 20 Jan 2019 13:55:46 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-dagger-optimize/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事では実践に寄せて、Daggerの生成コードがR8によってどのように変化するかを見ます。&lt;/p&gt;

&lt;p&gt;まずはサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(
  modules = [
    AppModule1::class,
    AppModule2::class
  ]
)
interface AppComponent {
  @Component.Builder
  interface Builder {
    fun build(): AppComponent
  }

  fun inject(activity: MainActivity)
}

@Module
class AppModule1 {
  @Provides
  fun provideService(): AppService {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

@Module
object AppModule2 {
  @JvmStatic
  @Provides
  fun provideService2(): AppService2 {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

---

class MainActivity : AppCompatActivity() {
  @Inject lateinit var appService: AppService
  @Inject lateinit var appService2: AppService2

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val appComponent = DaggerAppComponent.builder().build()
    appComponent.inject(this)

    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンプルなAppComponentを定義して、そこにAppModule1とAppModule2を紐づけています。それを、MainActivityで使うコードになっています。&lt;/p&gt;

&lt;p&gt;これを最適化なしでdex変換して、デコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends AppCompatActivity {
    @Inject
    @NotNull
    public AppService appService;
    @Inject
    @NotNull
    public AppService2 appService2;

    ...

    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        DaggerAppComponent.builder().build().inject(this);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通のコードです。KotlinをJava変換しただけなので、特におかしな部分もありません。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends m {
    public AppService o;
    public AppService2 p;
    ...

    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView((int) R.layout.activity_main);
        Object a = new AppModule1().a();
        a.a(a, &amp;quot;Cannot return null from a non-@Nullable @Provides method&amp;quot;);
        this.o = a;
        this.p = AppModule2_ProvideService2Factory.a();
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何ということでしょう。&lt;code&gt;DaggerAppComponent&lt;/code&gt;が消えました！&lt;/p&gt;

&lt;p&gt;DaggerAppComponentの各メソッドがMainActivity側にインライン展開されることで、完全にDaggerAppComponentを消すことが出来ます。
実際にapkの中身を見て、DaggerAppComponentクラスが存在しないことを確認しました。R8すごい😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Proguardだと、デフォルトのだと上記のサンプルから、&lt;code&gt;DaggerAppComponent&lt;/code&gt;を消すことが出来ませんでした。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8すごい😃😃😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。&lt;/p&gt;

&lt;h2 id=&#34;kotlin-lambda&#34;&gt;Kotlin lambda&lt;/h2&gt;

&lt;p&gt;Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。&lt;/p&gt;

&lt;p&gt;例えば、次のコードを最適化なしでコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun main() {
    lambdaTest1 { println(&amp;quot;Kotlin lambda1&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda2&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda3&amp;quot;) }
    ...
}

private fun lambdaTest1(body: () -&amp;gt; Unit) {
    ...
    body()
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// コンパイル後
public static final void main() {
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE);
    ...
}

final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1();

    LambdaTestKt$main$1() {
        super(0);
    }

    public final void invoke() {
        System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
    }
}

final class LambdaTestKt$main$2 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
final class LambdaTestKt$main$3 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LambdaTestKt$main$1&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt;、&lt;code&gt;$3&lt;/code&gt;が生成されていることが分かります。ラムダを使う箇所を増やすと$2、$3&amp;hellip;とクラスが増えていきます。&lt;/p&gt;

&lt;p&gt;この問題に対し、R8ではLambdaGroupというテクニックを使い最適化をします。&lt;/p&gt;

&lt;p&gt;R8を使って、上記のコードをコンパイルすると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final void main() {
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$0);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$1);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$2);
    ...
}

public final class -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI extends Lambda implements Function0 {
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$0 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(0);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$1 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(1);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$2 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(2);
    public final /* synthetic */ int $id$;

    public -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(int i) {
        this.$id$ = i;
        super(0);
    }

    public final Object invoke() {
        int i = this.$id$;
        if (i == 0) {
            System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 1) {
            System.out.println(&amp;quot;Kotlin lambda2&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 2) {
            System.out.println(&amp;quot;Kotlin lambda3&amp;quot;);
            return Unit.INSTANCE;
        } else {
            throw null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化しない場合では、それぞれのラムダに対して、専用のクラスが1つずつ定義されていました。最適化された後では1つのクラス、LambadGroupにまとまっていることが分かります。
このクラスでは、それぞれのラムダインスタンスにidを持たせることで、どのラムダかを分類することが出来ます。&lt;/p&gt;

&lt;p&gt;この最適化により、クラス数、メソッド数を抑えることが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。&lt;/p&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;https://jakewharton.com/r8-optimization-staticization/&#34;&gt;R8 Optimization: Staticization&lt;/a&gt;にとても影響を受けています。&lt;/p&gt;

&lt;h2 id=&#34;companion-object&#34;&gt;Companion object&lt;/h2&gt;

&lt;p&gt;例えば、次のコードがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CompanionTest {
    companion object {
        fun show(i: Int) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを最適化なしで変換すると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class CompanionTest {
    public static final Companion Companion = new Companion();

    public static final class Companion {
        private Companion() {
        }

        public final void show(int i) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。&lt;/p&gt;

&lt;p&gt;そこでR8による最適化を行うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class CompanionTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無駄な内部クラス（enclosing class）が消えて、staticメソッドに変換されているのが分かります。このshowメソッドはわざわざインスタンスメソッドにする必要がないため、このような最適化が行われます。&lt;/p&gt;

&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;

&lt;p&gt;objectも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object ObjectTest {
    fun show(i: Int) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化なしだと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ObjectTest {
    public static final ObjectTest INSTANCE = new ObjectTest();

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INSTANCEフィールドが生成されていることが分かります。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class ObjectTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companion objectと同様に冗長なインスタンス生成が消えています。
Proguardの場合、インスタンス生成は消えないので、R8の一歩進んだ最適化といえます。（もしかしたらProguardの設定次第でインスタンス生成をしないように出来るかもしれないです。）&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではClass Mergingについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;class-merging&#34;&gt;Class Merging?&lt;/h2&gt;

&lt;p&gt;その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。
Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。&lt;/p&gt;

&lt;p&gt;まずは縦方向のClass Mergingについて説明します。&lt;/p&gt;

&lt;h3 id=&#34;縦方向&#34;&gt;縦方向?&lt;/h3&gt;

&lt;p&gt;縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。&lt;/p&gt;

&lt;p&gt;例えば、次の実装は最適化によって1つにまとめられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface IVertical {
    fun show(i: Int)
}

class Vertical(
    private val a: Int
) : IVertical {
    override fun show(i: Int) {
        println(&amp;quot;start called $i $a&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Vertical {
    ...

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IVertical&lt;/code&gt;インターフェースが見事に消されていることが分かります。&lt;/p&gt;

&lt;p&gt;また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r8.googlesource.com/r8/+/master/src/main/java/com/android/tools/r8/shaking/VerticalClassMerger.java&#34;&gt;R8: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/proguard/blob/master/src/proguard/optimize/peephole/VerticalClassMerger.java&#34;&gt;Proguard: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に横方向のマージを紹介します。&lt;/p&gt;

&lt;h3 id=&#34;横方向&#34;&gt;横方向?&lt;/h3&gt;

&lt;p&gt;Staticメソッドのみを持つクラスを1つにまとめるなどの最適化を行います。&lt;/p&gt;

&lt;p&gt;例えばKotlinの複数のファイルで定義されたトップレベル関数を1つのクラスにまとめてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ShowExt.kt
fun Int.show1(i: Int) {
    ...
}

// ShowExt2.kt
fun Int.show2(i: Int) {
    ...
}

--&amp;gt; Proguard/R8による最適化後 --&amp;gt;

```java
public class ShowExt2Kt {
    public static final void show1(int i) {
        ...
    }
}

    public static final void show2(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つのクラスにまとめられていることが分かります。&lt;/p&gt;

&lt;p&gt;また、実際のAndroidプロジェクトで確認したところ、確かに拡張関数が他のクラスにマージされていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fuga.kt
fun Int.show1() {
    ...
}

// mapping.txtの内容
android.support.constraint.solver.widgets.Analyzer -&amp;gt; a.b.b.a.a.a:
    ...
    void com.github.satoshun.example.FugaKt.show1(int) -&amp;gt; d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこのクラスに移動したかは分からないので、今後の宿題とします。申し訳ありません😫&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;横方向のマージについては内容に自信がないので、もし間違っていたり、補足があれば教えて頂けるととても嬉しいです🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>