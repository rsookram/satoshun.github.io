<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Mon, 28 Jan 2019 00:08:35 UTC</updated>
    
    
    <item>
      <title>R8/Proguard: JarファイルからProGuard設定ファイルを読み込んでくれるようになりました</title>
      <link>https://satoshun.github.io/2019/01/r8-proguard-metainf/</link>
      <pubDate>Mon, 28 Jan 2019 00:08:35 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-proguard-metainf/</guid>
      <description>

&lt;p&gt;AGP3.3.0から、JarファイルにProGuard設定ファイルを組み込めるようになりました。その機能紹介です。
今まで、aarでは&lt;code&gt;consumerProguardFiles&lt;/code&gt;で、ライブラリのProGuard設定を指定できました。それのJar、Javaバージョンとなります。&lt;/p&gt;

&lt;h2 id=&#34;ライブラリ開発者側の設定&#34;&gt;ライブラリ開発者側の設定&lt;/h2&gt;

&lt;p&gt;RetrofitなどのSquare社のライブラリでは、早くもこの機能に対応しているので、それを例にして説明します。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;resources/META-INF/prougard&lt;/code&gt;ディレクトリの中にProGuardの設定ファイルを置きます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit/tree/master/retrofit/src/main/resources/META-INF/proguard&#34;&gt;square/retrofit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ライブラリ側の設定はこれで完了です。&lt;/p&gt;

&lt;h2 id=&#34;使う側の設定&#34;&gt;使う側の設定&lt;/h2&gt;

&lt;p&gt;AGP3.3.0にアップデートするだけで使えます。META-INF/ProGuardはRetrofitの2.5.0から入っているので、まずはMETA-INFが入っていない、2.4.0でビルドをしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.4.0&amp;quot;

&amp;gt; ./gradlew installRelease
...
Warning: there were 267 unresolved references to classes or interfaces.
         You may need to add missing library jars or update their versions.
         If your code works fine without the missing classes, you can suppress
         the warnings with &#39;-dontwarn&#39; options.
         (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedclass)
Warning: Exception while processing task java.io.IOException: Please correct the above warnings first.
Thread(Tasks limiter_2): destruction
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;失敗しました😂&lt;/p&gt;

&lt;p&gt;次にMETA-INFが入った2.5.0でビルドをします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;implementation &amp;quot;com.squareup.retrofit2:retrofit:2.5.0&amp;quot;

&amp;gt; ./gradlew installRelease
...

BUILD SUCCESSFUL in 21s
38 actionable tasks: 18 executed, 20 from cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功しました😊&lt;/p&gt;

&lt;p&gt;META-INFファイルをちゃんと読み込めているようです。ProGuardのconfigurationファイルを確認したところ、RetrofitのProGuard設定が入っていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// configuration.txt
...
# Retain service method parameters when optimizing.
-keepclassmembers,allowshrinking,allowobfuscation interface  * {
    @retrofit2.http.*
    &amp;lt;methods&amp;gt;;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;この機能はR8/ProGuard、両方とも対応しているようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ライブラリがJarであったとしても、ライブラリ作者が対応してくれればProGuardの設定が楽になる!!!

&lt;ul&gt;
&lt;li&gt;現状、有名なライブラリでは、OkHttp、Retrofit、Coroutineなどが対応しています😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;この機能がProGuardでも使えるのを知らなかったので、公式ドキュメントなどのリンクを知っている方がいれば教えてほしいです🙏🙏🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>

&lt;p&gt;FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。&lt;/p&gt;

&lt;p&gt;結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂&lt;/p&gt;

&lt;p&gt;また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。&lt;/p&gt;

&lt;h2 id=&#34;room-in-memory&#34;&gt;Room in memory?&lt;/h2&gt;

&lt;p&gt;Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。&lt;/p&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Room
  .inMemoryDatabaseBuilder(context, MyDatabase::class.java)
  .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in memoryを使う理由としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ディスパッチするアクションを永続化する必要はないだろう&lt;/li&gt;
&lt;li&gt;マイグレーションが必要ない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;実装に入っていく&#34;&gt;実装に入っていく&lt;/h2&gt;

&lt;p&gt;では、実装の説明をしていきます。&lt;/p&gt;

&lt;p&gt;まずはActionをRoomのEntityとして定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sealed class AuthorAction

@Entity(tableName = &amp;quot;author1&amp;quot;)
data class Author1(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()

@Entity(tableName = &amp;quot;author2&amp;quot;)
data class Author2(
  @PrimaryKey val _id: Long = 0, // always 0
  val name: String,
  val age: Int
) : AuthorAction()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、&lt;code&gt;@PrimaryKey(autoGenerate = true)&lt;/code&gt;を使っても良いと思います。&lt;/p&gt;

&lt;p&gt;次にDaoを定義します。これはFluxでいうところのDispatcherになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Dao
interface AuthorDispatcher {
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author1)
  @Insert(onConflict = OnConflictStrategy.REPLACE) fun dispatch(author: Author2)

  // Storeに相当する
  @Query(&amp;quot;select * FROM author1 WHERE _id = 0&amp;quot;)
  fun author(): LiveData&amp;lt;Author1?&amp;gt;

  // Storeに相当する
  @Query(
    &amp;quot;&amp;quot;&amp;quot;
    select author1.name as name1, author2.name as name2
    FROM author1
     INNER JOIN author2
    WHERE author1._id = 0 AND author2._id = 0
    &amp;quot;&amp;quot;&amp;quot;
  )
  fun mappedAuthor(): LiveData&amp;lt;MappedAuthor?&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;code&gt;@Insert&lt;/code&gt;でアクションをdispatchメソッドを、&lt;code&gt;@Query&lt;/code&gt;でsubscribeメソッドを実装しています。&lt;/p&gt;

&lt;p&gt;これで、FluxのDispatcherに似た何かをRoomで表現することが出来ます！&lt;/p&gt;

&lt;h2 id=&#34;まとめ-考察&#34;&gt;まとめ/考察&lt;/h2&gt;

&lt;p&gt;RoomでDispatcher的なのを作る方法と、EventBusなどを使ったアプローチの違いは以下になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Storeに書いていたロジックをSQLに任せることが出来る

&lt;ul&gt;
&lt;li&gt;Transactionを上手く使えば、マルチスレッド環境でもそれっぽく動きそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ほげほげDispactherクラスがアプリ内に蔓延する&lt;/li&gt;
&lt;li&gt;コードが冗長😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工夫すれば、もう少しキレイに書けるとは思いますが、ただEventBusや、Coroutineを使ったアプローチには敵わないと思っています。
FluxのDispatcherの代替としては辛いですが、他の用途、例えばRepositoryの実装などには使える余地があると思うので、そういったところで思い出していただけたら幸いです😊&lt;/p&gt;

&lt;p&gt;検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/RoomDispatcherExample&#34;&gt;RoomDispatcherExample&lt;/a&gt;にあります。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Daggerの生成コードがR8でどのように変わるかを見る</title>
      <link>https://satoshun.github.io/2019/01/r8-dagger-optimize/</link>
      <pubDate>Sun, 20 Jan 2019 13:55:46 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-dagger-optimize/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事では実践に寄せて、Daggerの生成コードがR8によってどのように変化するかを見ます。&lt;/p&gt;

&lt;p&gt;まずはサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(
  modules = [
    AppModule1::class,
    AppModule2::class
  ]
)
interface AppComponent {
  @Component.Builder
  interface Builder {
    fun build(): AppComponent
  }

  fun inject(activity: MainActivity)
}

@Module
class AppModule1 {
  @Provides
  fun provideService(): AppService {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

@Module
object AppModule2 {
  @JvmStatic
  @Provides
  fun provideService2(): AppService2 {
    val retrofit = Retrofit.Builder()
      ...
    return retrofit.create()
  }
}

---

class MainActivity : AppCompatActivity() {
  @Inject lateinit var appService: AppService
  @Inject lateinit var appService2: AppService2

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val appComponent = DaggerAppComponent.builder().build()
    appComponent.inject(this)

    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンプルなAppComponentを定義して、そこにAppModule1とAppModule2を紐づけています。それを、MainActivityで使うコードになっています。&lt;/p&gt;

&lt;p&gt;これを最適化なしでdex変換して、デコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends AppCompatActivity {
    @Inject
    @NotNull
    public AppService appService;
    @Inject
    @NotNull
    public AppService2 appService2;

    ...

    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        DaggerAppComponent.builder().build().inject(this);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通のコードです。KotlinをJava変換しただけなので、特におかしな部分もありません。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class MainActivity extends m {
    public AppService o;
    public AppService2 p;
    ...

    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView((int) R.layout.activity_main);
        Object a = new AppModule1().a();
        a.a(a, &amp;quot;Cannot return null from a non-@Nullable @Provides method&amp;quot;);
        this.o = a;
        this.p = AppModule2_ProvideService2Factory.a();
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何ということでしょう。&lt;code&gt;DaggerAppComponent&lt;/code&gt;が消えました！&lt;/p&gt;

&lt;p&gt;DaggerAppComponentの各メソッドがMainActivity側にインライン展開されることで、完全にDaggerAppComponentを消すことが出来ます。
実際にapkの中身を見て、DaggerAppComponentクラスが存在しないことを確認しました。R8すごい😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Proguardだと、デフォルトのだと上記のサンプルから、&lt;code&gt;DaggerAppComponent&lt;/code&gt;を消すことが出来ませんでした。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8すごい😃😃😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。&lt;/p&gt;

&lt;h2 id=&#34;kotlin-lambda&#34;&gt;Kotlin lambda&lt;/h2&gt;

&lt;p&gt;Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。&lt;/p&gt;

&lt;p&gt;例えば、次のコードを最適化なしでコンパイルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun main() {
    lambdaTest1 { println(&amp;quot;Kotlin lambda1&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda2&amp;quot;) }
    lambdaTest1 { println(&amp;quot;Kotlin lambda3&amp;quot;) }
    ...
}

private fun lambdaTest1(body: () -&amp;gt; Unit) {
    ...
    body()
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// コンパイル後
public static final void main() {
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE);
    LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE);
    ...
}

final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1();

    LambdaTestKt$main$1() {
        super(0);
    }

    public final void invoke() {
        System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
    }
}

final class LambdaTestKt$main$2 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
final class LambdaTestKt$main$3 extends Lambda implements Function0&amp;lt;Unit&amp;gt; {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LambdaTestKt$main$1&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt;、&lt;code&gt;$3&lt;/code&gt;が生成されていることが分かります。ラムダを使う箇所を増やすと$2、$3&amp;hellip;とクラスが増えていきます。&lt;/p&gt;

&lt;p&gt;この問題に対し、R8ではLambdaGroupというテクニックを使い最適化をします。&lt;/p&gt;

&lt;p&gt;R8を使って、上記のコードをコンパイルすると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final void main() {
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$0);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$1);
    LambdaTestKt.lambdaTest1(-$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI.INSTANCE$2);
    ...
}

public final class -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI extends Lambda implements Function0 {
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$0 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(0);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$1 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(1);
    public static final -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI INSTANCE$2 = new -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(2);
    public final /* synthetic */ int $id$;

    public -$$LambdaGroup$ks$BpS7w8o_KOkdSUy0gHGt84S7irI(int i) {
        this.$id$ = i;
        super(0);
    }

    public final Object invoke() {
        int i = this.$id$;
        if (i == 0) {
            System.out.println(&amp;quot;Kotlin lambda1&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 1) {
            System.out.println(&amp;quot;Kotlin lambda2&amp;quot;);
            return Unit.INSTANCE;
        } else if (i == 2) {
            System.out.println(&amp;quot;Kotlin lambda3&amp;quot;);
            return Unit.INSTANCE;
        } else {
            throw null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化しない場合では、それぞれのラムダに対して、専用のクラスが1つずつ定義されていました。最適化された後では1つのクラス、LambadGroupにまとまっていることが分かります。
このクラスでは、それぞれのラムダインスタンスにidを持たせることで、どのラムダかを分類することが出来ます。&lt;/p&gt;

&lt;p&gt;この最適化により、クラス数、メソッド数を抑えることが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。&lt;/p&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;https://jakewharton.com/r8-optimization-staticization/&#34;&gt;R8 Optimization: Staticization&lt;/a&gt;にとても影響を受けています。&lt;/p&gt;

&lt;h2 id=&#34;companion-object&#34;&gt;Companion object&lt;/h2&gt;

&lt;p&gt;例えば、次のコードがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CompanionTest {
    companion object {
        fun show(i: Int) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを最適化なしで変換すると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class CompanionTest {
    public static final Companion Companion = new Companion();

    public static final class Companion {
        private Companion() {
        }

        public final void show(int i) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。&lt;/p&gt;

&lt;p&gt;そこでR8による最適化を行うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class CompanionTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無駄な内部クラス（enclosing class）が消えて、staticメソッドに変換されているのが分かります。このshowメソッドはわざわざインスタンスメソッドにする必要がないため、このような最適化が行われます。&lt;/p&gt;

&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;

&lt;p&gt;objectも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object ObjectTest {
    fun show(i: Int) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化なしだと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ObjectTest {
    public static final ObjectTest INSTANCE = new ObjectTest();

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INSTANCEフィールドが生成されていることが分かります。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class ObjectTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companion objectと同様に冗長なインスタンス生成が消えています。
Proguardの場合、インスタンス生成は消えないので、R8の一歩進んだ最適化といえます。（もしかしたらProguardの設定次第でインスタンス生成をしないように出来るかもしれないです。）&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではClass Mergingについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;class-merging&#34;&gt;Class Merging?&lt;/h2&gt;

&lt;p&gt;その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。
Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。&lt;/p&gt;

&lt;p&gt;まずは縦方向のClass Mergingについて説明します。&lt;/p&gt;

&lt;h3 id=&#34;縦方向&#34;&gt;縦方向?&lt;/h3&gt;

&lt;p&gt;縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。&lt;/p&gt;

&lt;p&gt;例えば、次の実装は最適化によって1つにまとめられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface IVertical {
    fun show(i: Int)
}

class Vertical(
    private val a: Int
) : IVertical {
    override fun show(i: Int) {
        println(&amp;quot;start called $i $a&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Vertical {
    ...

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IVertical&lt;/code&gt;インターフェースが見事に消されていることが分かります。&lt;/p&gt;

&lt;p&gt;また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r8.googlesource.com/r8/+/master/src/main/java/com/android/tools/r8/shaking/VerticalClassMerger.java&#34;&gt;R8: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/proguard/blob/master/src/proguard/optimize/peephole/VerticalClassMerger.java&#34;&gt;Proguard: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に横方向のマージを紹介します。&lt;/p&gt;

&lt;h3 id=&#34;横方向&#34;&gt;横方向?&lt;/h3&gt;

&lt;p&gt;Staticメソッドのみを持つクラスを1つにまとめるなどの最適化を行います。&lt;/p&gt;

&lt;p&gt;例えばKotlinの複数のファイルで定義されたトップレベル関数を1つのクラスにまとめてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ShowExt.kt
fun Int.show1(i: Int) {
    ...
}

// ShowExt2.kt
fun Int.show2(i: Int) {
    ...
}

--&amp;gt; Proguard/R8による最適化後 --&amp;gt;

```java
public class ShowExt2Kt {
    public static final void show1(int i) {
        ...
    }
}

    public static final void show2(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つのクラスにまとめられていることが分かります。&lt;/p&gt;

&lt;p&gt;また、実際のAndroidプロジェクトで確認したところ、確かに拡張関数が他のクラスにマージされていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fuga.kt
fun Int.show1() {
    ...
}

// mapping.txtの内容
android.support.constraint.solver.widgets.Analyzer -&amp;gt; a.b.b.a.a.a:
    ...
    void com.github.satoshun.example.FugaKt.show1(int) -&amp;gt; d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこのクラスに移動したかは分からないので、今後の宿題とします。申し訳ありません😫&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;横方向のマージについては内容に自信がないので、もし間違っていたり、補足があれば教えて頂けるととても嬉しいです🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://medium.com/@keyboardsurfer/dependency-injection-in-a-multi-module-project-1a09511c14b7&#34;&gt;Dependency injection in a multi module project&lt;/a&gt;を見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。&lt;/p&gt;

&lt;p&gt;結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。&lt;/p&gt;

&lt;p&gt;また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。&lt;/p&gt;

&lt;p&gt;検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;satoshun-android-example/DynamicFeatureDaggerExample&lt;/a&gt;にあります😊&lt;/p&gt;

&lt;h2 id=&#34;前提知識&#34;&gt;前提知識&lt;/h2&gt;

&lt;p&gt;通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。
ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLukc_oixbB7pUkUx9lxjErCvxEtip5bPoVMv2VbvfNeX2TM53mk7dHuwOTZvkNFcxUyxXvTQn2Oh42K1XPrUEchO-RfnbYKrbSccI8gTG8Xr8ZBYukeDaAkYdvvNcwTX3TQ090DGwfUIb0Fm00&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLmgSnBpCrCLd1BJImfBKfztBZkoRwvJzVEU3fxCnTNSdvkGNvUQbw9GdHYGS7ZvaMFctOyRbxwk7dFu-RLiGg9nGf0OMHLZvksFcwUPeXDPN5faY6cKYCSIesukBX0EXHqK_BBytJjm1Q1n544k1nIyrA0dW40&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。&lt;/p&gt;

&lt;p&gt;ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。
実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。&lt;/p&gt;

&lt;p&gt;では、実装を始めます。&lt;/p&gt;

&lt;p&gt;最初に、SubActivityをDaggerApplicationのように振る舞わさせるために&lt;code&gt;ModuleRootActivity&lt;/code&gt;クラスを定義します。
それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ModuleRootActivity : AppCompatActivity(),
  HasModuleInjector {
  @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt;

  private lateinit var injector: ModuleActivityInjector

  override fun onCreate(savedInstanceState: Bundle?) {
    injector = moduleComponent.moduleInjector
    injector.activity.inject(this)
    super.onCreate(savedInstanceState)
  }

  protected abstract val moduleComponent: ModuleActivityComponent

  override fun supportFragmentInjector(): AndroidInjector&amp;lt;Fragment&amp;gt; =
    fragmentInjector
}

class ModuleActivityInjector @Inject constructor(
  internal val activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
)

interface ModuleActivityComponent {
  val moduleInjector: ModuleActivityInjector
}

interface HasModuleInjector : HasSupportFragmentInjector

abstract class ModuleChildFragment : Fragment() {
  override fun onAttach(context: Context) {
    AndroidSupportInjection.inject(this)
    super.onAttach(context)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、このbaseクラス群を使い、SubActivityとDagger Componentを実装をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ModuleScope
@Component(
  dependencies = [CoreComponent::class], // 共通で使うComponent
  modules = [
    AndroidSupportInjectionModule::class,
    SubBuilder::class
  ]
)
internal interface SubComponent : ModuleActivityComponent {
  @Component.Builder
  interface Builder {
    fun appComponent(module: CoreComponent): Builder
    fun build(): Sub1Component
  }
}

@Module(
  includes = [SubActivityModule::class]
)
interface SubBuilder

@Module
internal interface SubActivityModule {
  @ContributesAndroidInjector(modules = [SubFragmentsModule::class])
  fun contributeSubActivity(): SubActivity
}

@Module
internal interface SubFragmentsModule {
  @ContributesAndroidInjector
  fun contributeSubFragment(): SubFragment
}

class SubActivity : ModuleRootActivity() {
  @Inject lateinit var ...

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)
    ...
  }

  override val moduleComponent: ModuleActivityComponent
    get() = DaggerSubComponent
      .builder()
      .appComponent(App.coreComponent())
      .build()
}

class SubFragment : ModuleChildFragment() {
  @Inject lateinit var ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ModuleRootActivity&lt;/code&gt;で、Featureモジュール内で使うComponentを保持し、各Fragmentで保持したComponentを参照することで、ActivityをDaggerApplicationのように振る舞わさせる事ができます。ComponentやModuleの定義は従来のDagger Androidの書き方とほぼ一緒です。&lt;/p&gt;

&lt;p&gt;これで、Dynamic Featureモジュール + Dagger Androidを実現することが出来ます😃&lt;/p&gt;

&lt;p&gt;細かい部分はサンプルを見ていただけたらと思います。&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;DynamicFeatureDaggerExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;メモ1-1つのfeature-module内で複数activityがある場合&#34;&gt;メモ1: 1つのFeature Module内で複数Activityがある場合&lt;/h2&gt;

&lt;p&gt;このパターンは考慮出来ていないです😂
おそらく、頑張ってApplicationクラス内でstaticで保持するか、もしくは、CoreComponentでScopedで管理するのが良いと思っています。&lt;/p&gt;

&lt;h2 id=&#34;メモ2-configuration-change対応&#34;&gt;メモ2: Configuration Change対応&lt;/h2&gt;

&lt;p&gt;Feature Root ComponentはActivityではなく、AACのViewModelで保持したほうが良いかも知れないです。&lt;/p&gt;

&lt;h2 id=&#34;メモ3-そもそもdagger-androidを使う必要あるのか&#34;&gt;メモ3: そもそもDagger Androidを使う必要あるのか?&lt;/h2&gt;

&lt;p&gt;Scopeをガンガン使いたい時、すでにDagger Androidを導入している場合は使ってもいいかも。
ただPlaidのように、Dagger Androidを使わないほうがコードが複雑にならなそうなので、使わないほうが基本良いと思います。（今後心変わりする可能性は大いにあります）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、Happy Dagger Life 😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>dexdumpメモ</title>
      <link>https://satoshun.github.io/2019/01/reading_dexdump_result/</link>
      <pubDate>Sat, 05 Jan 2019 02:15:50 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/reading_dexdump_result/</guid>
      <description>&lt;p&gt;Android build-toolsにはdexdumpというdexファイルを逆アセンブルするツールがあります。
逆アセンブルしたファイルを読みたかったのでそれのメモです。&lt;/p&gt;

&lt;p&gt;内容はまとまっていません。自分用のメモレベルの記事になります。&lt;/p&gt;

&lt;p&gt;dexファイルをコマンドから作るにはjavacとd8コマンドを使います。d8コマンドは &lt;a href=&#34;https://r8.googlesource.com/r8&#34;&gt;https://r8.googlesource.com/r8&lt;/a&gt; の手順通りにビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javac *.java // or kotlinc *.kt
java -jar $R8_HOME/build/libs/d8.jar --lib $ANDROID_HOME/platforms/android-28/android.jar --release *.class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d8コマンドで出来たdexファイルをdexdumpで逆アセンブルします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば次のJavaコードを逆アセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Test {
    public void main() {
        show(1, 10.0);
        String[] array = {&amp;quot;&amp;quot;};
        toggle(array);
        fade();
        drag();
        hide();
        click();
        hover();
    }

    public String show(int a, double d) {
        System.out.println(a);
        return &amp;quot;showed&amp;quot;;
    }

    void toggle(String[] args) {
        System.out.println(&amp;quot;toggle&amp;quot;);
    }

    protected void fade() {
        System.out.println(&amp;quot;fade&amp;quot;);
    }

    final protected void drag() {
        System.out.println(&amp;quot;drag&amp;quot;);
    }

    private void hide() {
        System.out.println(&amp;quot;hide&amp;quot;);
    }

    public static void click() {
        System.out.println(&amp;quot;click&amp;quot;);
    }

    static void hover() {
        System.out.println(&amp;quot;hover&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Processing &#39;classes.dex&#39;...
Opened &#39;classes.dex&#39;, DEX version &#39;035&#39;
Class #0            -
  Class descriptor  : &#39;LTest;&#39; // クラス名Test
  Access flags      : 0x0000 () // パッケージプライベート
  Superclass        : &#39;Ljava/lang/Object;&#39; // スーパークラスがObject
  Interfaces        - // インターフェースを持たない
  Static fields     - // Staticフィールドを持たない
  Instance fields   - // インスタンスフィールドを持たない
  Direct methods    -
    #0              : (in LTest;)
      name          : &#39;&amp;lt;init&amp;gt;&#39; // コンストラクタを示す
      type          : &#39;()V&#39; // 引数なし/戻り値なし
      access        : 0x10000 (CONSTRUCTOR)
      code          -
      registers     : 1
      ins           : 1
      outs          : 1
      insns size    : 4 16-bit code units
0001e4:                                        |[0001e4] Test.&amp;lt;init&amp;gt;:()V
0001f4: 7010 0b00 0000                         |0000: invoke-direct {v0}, Ljava/lang/Object;.&amp;lt;init&amp;gt;:()V // method@000b // Objectのsuper
0001fa: 0e00                                   |0003: return-void
      catches       : (none)
      positions     :
        0x0000 line=1
      locals        :
        0x0000 - 0x0004 reg=0 this LTest;

    #1              : (in LTest;)
      name          : &#39;click&#39;
      type          : &#39;()V&#39;
      access        : 0x0009 (PUBLIC STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
0001fc:                                        |[0001fc] Test.click:()V
00020c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000210: 1a01 0f00                              |0002: const-string v1, &amp;quot;click&amp;quot; // string@000f
000214: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00021a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=35
      locals        :

    #2              : (in LTest;)
      name          : &#39;hide&#39;
      type          : &#39;()V&#39;
      access        : 0x0002 (PRIVATE)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00025c:                                        |[00025c] Test.hide:()V
00026c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000270: 1a01 1200                              |0002: const-string v1, &amp;quot;hide&amp;quot; // string@0012
000274: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00027a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=31
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #3              : (in LTest;)
      name          : &#39;hover&#39;
      type          : &#39;()V&#39;
      access        : 0x0008 (STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
00027c:                                        |[00027c] Test.hover:()V
00028c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000290: 1a01 1300                              |0002: const-string v1, &amp;quot;hover&amp;quot; // string@0013
000294: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00029a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=39
      locals        :

  Virtual methods   -
    #0              : (in LTest;)
      name          : &#39;drag&#39;
      type          : &#39;()V&#39;
      access        : 0x0014 (PROTECTED FINAL)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00021c:                                        |[00021c] Test.drag:()V
00022c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000230: 1a01 1000                              |0002: const-string v1, &amp;quot;drag&amp;quot; // string@0010
000234: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00023a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=27
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #1              : (in LTest;)
      name          : &#39;fade&#39;
      type          : &#39;()V&#39;
      access        : 0x0004 (PROTECTED)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00023c:                                        |[00023c] Test.fade:()V
00024c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000250: 1a01 1100                              |0002: const-string v1, &amp;quot;fade&amp;quot; // string@0011
000254: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00025a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=23
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #2              : (in LTest;)
      name          : &#39;main&#39;
      type          : &#39;()V&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 1
      outs          : 4
      insns size    : 32 16-bit code units
00029c:                                        |[00029c] Test.main:()V
0002ac: 1210                                   |0000: const/4 v0, #int 1 // #1
0002ae: 1901 2440                              |0001: const-wide/high16 v1, #long 4621819117588971520 // #4024
0002b2: 6e40 0700 0321                         |0003: invoke-virtual {v3, v0, v1, v2}, LTest;.show:(ID)Ljava/lang/String; // method@0007
0002b8: 2300 0800                              |0006: new-array v0, v0, [Ljava/lang/String; // type@0008
0002bc: 1201                                   |0008: const/4 v1, #int 0 // #0
0002be: 1a02 0000                              |0009: const-string v2, &amp;quot;&amp;quot; // string@0000
0002c2: 4d02 0001                              |000b: aput-object v2, v0, v1
0002c6: 6e20 0800 0300                         |000d: invoke-virtual {v3, v0}, LTest;.toggle:([Ljava/lang/String;)V // method@0008
0002cc: 6e10 0300 0300                         |0010: invoke-virtual {v3}, LTest;.fade:()V // method@0003
0002d2: 6e10 0200 0300                         |0013: invoke-virtual {v3}, LTest;.drag:()V // method@0002
0002d8: 7010 0400 0300                         |0016: invoke-direct {v3}, LTest;.hide:()V // method@0004
0002de: 7100 0100 0000                         |0019: invoke-static {}, LTest;.click:()V // method@0001
0002e4: 7100 0500 0000                         |001c: invoke-static {}, LTest;.hover:()V // method@0005
0002ea: 0e00                                   |001f: return-void
      catches       : (none)
      positions     :
        0x0003 line=3
        0x0006 line=4
        0x000d line=5
        0x0010 line=6
        0x0013 line=7
        0x0016 line=8
        0x0019 line=9
        0x001c line=10
      locals        :
        0x0000 - 0x0020 reg=3 this LTest;

    #3              : (in LTest;)
      name          : &#39;show&#39;
      type          : &#39;(ID)Ljava/lang/String;&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 4
      outs          : 2
      insns size    : 8 16-bit code units
0001c4:                                        |[0001c4] Test.show:(ID)Ljava/lang/String;
0001d4: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
0001d8: 6e20 0900 1200                         |0002: invoke-virtual {v2, v1}, Ljava/io/PrintStream;.println:(I)V // method@0009
0001de: 1a01 1800                              |0005: const-string v1, &amp;quot;showed&amp;quot; // string@0018
0001e2: 1101                                   |0007: return-object v1
      catches       : (none)
      positions     :
        0x0000 line=14
      locals        :
        0x0000 - 0x0008 reg=0 this LTest;

    #4              : (in LTest;)
      name          : &#39;toggle&#39;
      type          : &#39;([Ljava/lang/String;)V&#39;
      access        : 0x0000 ()
      code          -
      registers     : 3
      ins           : 2
      outs          : 2
      insns size    : 8 16-bit code units
0002ec:                                        |[0002ec] Test.toggle:([Ljava/lang/String;)V
0002fc: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000300: 1a00 1900                              |0002: const-string v0, &amp;quot;toggle&amp;quot; // string@0019
000304: 6e20 0a00 0200                         |0004: invoke-virtual {v2, v0}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00030a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=19
      locals        :
        0x0000 - 0x0008 reg=1 this LTest;

  source_file_idx   : 10 (Test.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;finalメソッドのdragがvirtualなのがなぜなのかわからない

&lt;ul&gt;
&lt;li&gt;finalはdirectメソッドなのでは?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>

&lt;p&gt;Androidのトレンドの1つにマルチモジュール構成があります。
マルチモジュールによるメリットとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビルド時間の短縮&lt;/li&gt;
&lt;li&gt;依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。&lt;/p&gt;

&lt;p&gt;この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい&lt;/li&gt;
&lt;li&gt;コード量を減らしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part1では、遷移専用のモジュールを作る方法を考えてみます。&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;遷移専用のモジュールを作る&#34;&gt;遷移専用のモジュールを作る&lt;/h2&gt;

&lt;p&gt;まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。&lt;/p&gt;

&lt;p&gt;例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メインではサブ画面が必要なのでサブモジュールに依存する&lt;/li&gt;
&lt;li&gt;サブではメイン画面が必要なのでメインモジュールに依存する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwecY1CaGcBmH5nSNa5BGBSfCpoZHjOE8WGW5tPpKDAW85vT3QbuAq6K0&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。
直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。&lt;/p&gt;

&lt;p&gt;そこで、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メイン画面に遷移するメインルーターモジュール&lt;/li&gt;
&lt;li&gt;サブ画面に遷移するサブルーターモジュール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのモジュールを作ります。&lt;/p&gt;

&lt;p&gt;メインルーターモジュールでは次の遷移専用インターフェースを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainRouter {
  fun routeToMain(context: Context): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;internal class MainRouterImpl @Inject constructor() : MainRouter {
  override fun routeToMain(context: Context): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---

@Module
internal interface MainActivityModule {
  @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SubActivity : AppCompatActivity() {
  @Inject lateinit var router: MainRouter

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な依存図は次のようになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwebLoUFcrO-RzpnksWyaOGgDKLGYMGTJO8If09iv9bnSN41AGRUqGBV63c8oZ6y7LG0o3Kc12K80ge7B8JKl1HWG0000&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで、相互に遷移する画面だとしても循環参照になることなく解決することが出来ます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;いちいちルーターモジュールを作るのがめんどうなのであれば、共通のRouterインターフェースを作る方法もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Router&amp;lt;T&amp;gt; {
  fun route(context: Context, params: T): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;---実装

internal class MainRouter2Impl @Inject constructor() : Router&amp;lt;Unit&amp;gt; {
  override fun route(context: Context, params: Unit): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---Daggerの設定

@Module
internal interface MainActivityModule {
  @Named(&amp;quot;main&amp;quot;)
  @Binds fun bindMain2Router(impl: MainRouter2Impl): Router&amp;lt;Unit&amp;gt;
}

---使用側

class SubActivity : AppCompatActivity() {
  @field:[Inject Named(&amp;quot;main&amp;quot;)] lateinit var router: Router&amp;lt;Unit&amp;gt;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DaggerのNamedアノテーションと組み合わせることでいい感じに共通Routerを作ることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;相互に行き来したい画面があったときに、遷移専用のモジュールを作ることで循環参照を防ぐことが出来る&lt;/li&gt;
&lt;li&gt;基本的に画面を含んだモジュールは遷移したいときがほとんどだと思うので、遷移専用のモジュールを作ることで無駄な依存を作ることを防ぐことが出来る&lt;/li&gt;
&lt;li&gt;遷移用のモジュールが増える😂😂😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part2ではDeeplinkやnavigationを絡めた遷移の方法について考えてみたいと思います😃&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: コーディングを支える技術</title>
      <link>https://satoshun.github.io/2018/12/coding_tech/</link>
      <pubDate>Fri, 28 Dec 2018 05:27:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coding_tech/</guid>
      <description>&lt;p&gt;「コーディングを支える技術」を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;比較、歴史から学ぶ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;その機能はなにかの問題を解決するために導入されている

&lt;ul&gt;
&lt;li&gt;歴史から紐解くことでなぜそれが必要かが理解できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語によってどの問題を解決したいのかが違う

&lt;ul&gt;
&lt;li&gt;Python: 同じようなコードになるような言語&lt;/li&gt;
&lt;li&gt;C++: 高速に動作することを目指している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;エラー処理の進化
- globalなエラーハンドリングはgotoと変わらない
- try catch finallyのように構造化されたエラー処理が誕生した
    - Javaでは検査型例外、必ずerrorを処理しなければいけない設計&lt;/p&gt;

&lt;p&gt;アドレスを覚えるのは人間には大変&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人間はメソッド、変数を介することでアドレスを忘れることが出来た

&lt;ul&gt;
&lt;li&gt;結果、メソッド名、変数名をいかにしてわかりやすくするかが重要になってきた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本的には何をするかというよりかは、何をさせないかで進化している&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスによるポリモーフィズム

&lt;ul&gt;
&lt;li&gt;関数ポインタを直接触らないように&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gotoの禁止

&lt;ul&gt;
&lt;li&gt;構造化、モジュール化できなくなるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方</title>
      <link>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</link>
      <pubDate>Tue, 25 Dec 2018 03:00:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</guid>
      <description>&lt;p&gt;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;継承とコンポジションはトレードオフ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;継承は自動的にaメッセージを委譲する

&lt;ul&gt;
&lt;li&gt;便利だが依存関係は強い&lt;/li&gt;
&lt;li&gt;親クラスが変更されたときに、自動的に子クラスにも影響があることを意味する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;継承は階層構造を生み出す

&lt;ul&gt;
&lt;li&gt;ポリモーフィズムを実現する&lt;/li&gt;
&lt;li&gt;これまた便利だが依存関係は強い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンポジションは自動的に委譲しない

&lt;ul&gt;
&lt;li&gt;必要に応じて集約クラスで操る必要がある&lt;/li&gt;
&lt;li&gt;依存は継承より少ない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単一責任について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あたりまえだけど守らないといけない

&lt;ul&gt;
&lt;li&gt;無駄な責務があると再利用できない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;達成することで再利用可能な素晴らしいクラスが出来る&lt;/li&gt;
&lt;li&gt;責任の依存先が不明なときは一旦privateとかに切り出しておいて未来に託す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ダックタイピング&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ダックにより、具体的なGearクラスからロールへのマインドシフトが出来る&lt;/li&gt;
&lt;li&gt;ロールを満たすことにより要件を満たす&lt;/li&gt;
&lt;li&gt;実装には依存しない、メッセージを送るだけで良い世界はOOPの真骨頂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依存関係について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;依存関係の向きを考えるのは大切

&lt;ul&gt;
&lt;li&gt;例えばコンストラクタ内で依存するのと、インスタンスメソッドだと距離が違う。コンストラクタ内で依存したほうが良い

&lt;ul&gt;
&lt;li&gt;さらに進めるとDI，コンストラクタの外から注入する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依存関係逆転の法則

&lt;ul&gt;
&lt;li&gt;低レイヤーに依存するのではなく、インターフェースに依存しておいて、あとから実装を注入することで達成

&lt;ul&gt;
&lt;li&gt;domain層などの他の層に依存したくない層で有効&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柔軟なインターフェース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトを信じるようなインターフェース

&lt;ul&gt;
&lt;li&gt;どのようにするかではなく、何をするかをメソッド名にする。宣言的に&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安定していなければいけない&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>

&lt;p&gt;Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、&lt;code&gt;ContinuationInterceptor&lt;/code&gt;を使えば上手くいきそうです。&lt;/p&gt;

&lt;h2 id=&#34;continuationinterceptorとは&#34;&gt;ContinuationInterceptorとは?&lt;/h2&gt;

&lt;p&gt;ContinuationInterceptorは次のようなインターフェースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * Marks coroutine context element that intercepts coroutine continuations.
 * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and
 * intercepts all coroutine continuations with [interceptContinuation] invocations.
 */
@SinceKotlin(&amp;quot;1.3&amp;quot;)
public interface ContinuationInterceptor : CoroutineContext.Element {
  public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;
  public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;)
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;interceptContinuation&lt;/code&gt;からContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class LifecycleContinuationInterceptor(
  private val lifecycle: Lifecycle
) : ContinuationInterceptor {
  override val key: CoroutineContext.Key&amp;lt;*&amp;gt;
    get() = ContinuationInterceptor

  override fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; {
    // ContinuationからJobを取得
    val job = continuation.context[Job]
    if (job != null) {
      lifecycle.addJob(job)
    }
    return continuation
  }
}

fun LifecycleOwner.addJob(job: Job) {
  lifecycle.addJob(job)
}

fun Lifecycle.addJob(job: Job) {
  val state = this.currentState
  val event = when (state) {
      ...
  }
  val observer = LifecycleJobObserver(job, event, this)
  this.addObserver(observer)
  job.invokeOnCompletion(observer)
}

private class LifecycleJobObserver(
  private val job: Job,
  private val event: Lifecycle.Event,
  private val lifecycle: Lifecycle
) : LifecycleObserver, CompletionHandler {
  @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
  fun onEvent(owner: LifecycleOwner, event: Lifecycle.Event) {
    if (event == this.event) {
      owner.lifecycle.removeObserver(this)
      job.cancel()
    }
  }

  override fun invoke(cause: Throwable?) {
    lifecycle.removeObserver(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Android Lifecycleと協調して動くContinuationInterceptorが出来ました。&lt;/p&gt;

&lt;p&gt;フルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample/blob/master/autodispose/src/main/java/com/github/satoshun/coroutine/autodispose/lifecycle/LifecycleContinuationInterceptor.kt&#34;&gt;ここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseActivity : AppCompatActivity(),
  CoroutineScope {

  private val job = Job()
  override val coroutineContext get() = job +
      Dispatchers.Main +
      LifecycleContinuationInterceptor(this) // ここでInterceptorを登録
}

class MainActivity : BaseActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // onCreateでlaunchしているので、onDestroyで自動的にキャンセルされる
    launch {
      ...
    }
  }

  override fun onResume() {
    super.onResume()

    // onResumeでlaunchしているので、onPauseで自動的にキャンセルされる
    launch {
      ...
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;a href=&#34;https://github.com/uber/AutoDispose&#34;&gt;Rx-AutoDispose&lt;/a&gt;のように実行したタイミングに応じて、キャンセルする場所を自動的に登録してくれます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もっと良い書き方が出来るか模索しているので、より適したAPI等を知っている人がいれば教えてくれると嬉しいです😊😊😊&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サンプルコードです😃&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample&#34;&gt;satoshun-android-example/AutoDisposeExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>

&lt;p&gt;この記事ではFragmentでLiveDataにObserverを登録するときは&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;を使うと良いという話をします。&lt;/p&gt;

&lt;p&gt;まず、Fragmentのおおまかなライフサイクルは次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onAttach&lt;/li&gt;
&lt;li&gt;onCreate

&lt;ul&gt;
&lt;li&gt;onCreateView&lt;/li&gt;
&lt;li&gt;onViewCreated

&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestoryView&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestroy&lt;/li&gt;
&lt;li&gt;onDetach&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここで重要なのは、&lt;code&gt;onDestroy&lt;/code&gt;が呼ばれることなく、複数回&lt;code&gt;onCreateView&lt;/code&gt;が呼ばれる可能性がある点です。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っている可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.data.observe(this, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。
このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。
しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。&lt;/p&gt;

&lt;p&gt;前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。
よって、FragmentにはView用のLifecycleが用意されています。それが、&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;前述のコードは次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // ViewのLifecycleOwnerを渡す
        viewModel.data.observe(viewLifecycleOwner, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！&lt;/p&gt;

&lt;h2 id=&#34;補足1&#34;&gt;補足1&lt;/h2&gt;

&lt;p&gt;Observerが開放されるタイミングはonDestroyがコールされるタイミングとは別にもう1つあります。
それは、Observerへの参照がなくなったタイミングです。内部的にObserverはWeakReferenceで保持されており、参照が無くなったタイミングでGCされます。&lt;/p&gt;

&lt;h2 id=&#34;補足2&#34;&gt;補足2&lt;/h2&gt;

&lt;p&gt;Observerの重複登録問題はattach/detachを繰り返す場合におこります。
サンプルコードは次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;while (true) {
    delay(3000)
    supportFragmentManager.commitNow {
        if (fragment.isDetached) attach(fragment)
        else detach(fragment)
　  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>

&lt;p&gt;この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃&lt;/p&gt;

&lt;h2 id=&#34;基本編&#34;&gt;基本編&lt;/h2&gt;

&lt;p&gt;一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成は&lt;code&gt;ViewModelProvider&lt;/code&gt;を介して行う必要があるためです。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel @Inject constructor(...): ViewModel()

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideMainViewModel(...) : MainViewModel {
        // ViewModelProviderを使ってインスタンスを生成する
        return ViewModelProviders.of(...).get(MainViewModel::class.java)
    }
}

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、ViewModelを直接注入せずに、&lt;code&gt;ViewModelProvider.Factory&lt;/code&gt;を注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。
このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()
or
class MainViewModel @Inject constructor(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideViewModelFactory(...) : ViewModelProvider.Factory {
        // ここでMainViewModelを生成するFactoryを定義する
        return object: ViewModelProvider.Factory {
            ...
        }
    }
}

class MainActivity : AppCompatActivity() {
    // ViewModelではなく、Factoryを注入するのがポイント
    @Inject lateinit var factory: ViewModelProvider.Factory

    // MainViewModelインスタンスの生成はActivity側で行う
    // activity-ktxで定義されている拡張関数を使う
    private val viewModel: MainViewModel by viewModels { factory }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;activity-ktxに定義されている&lt;code&gt;viewModels&lt;/code&gt;拡張関数を使ってMainViewModelインスタンスを生成します。これでViewModelのライフサイクルを保ちつつ、Daggerで依存を解決することが出来ます。&lt;/p&gt;

&lt;p&gt;次に、この2パターンのどちらの書き方がいいかを考えていきます。&lt;/p&gt;

&lt;h2 id=&#34;実例編&#34;&gt;実例編&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使うパターンと、Factoryを使うパターンは良いところ、悪いところがそれぞれあるので、好きな方を選べばいいと思います。&lt;/p&gt;

&lt;p&gt;両アプローチともに、ソースコード、ノウハウが出ているので参考リンクを張っておきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nickbutcher/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/dagger/DribbbleModule.kt#L43&#34;&gt;plaid&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Provides&lt;/code&gt;を使い、ViewModelを直接注入するパターン&lt;/li&gt;
&lt;li&gt;ViewModelごとにFactoryクラスをそれぞれ定義する必要があるので記述量が多い&lt;/li&gt;
&lt;li&gt;ViewModelの依存関係が解決できなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入出来るので使い側からすると間違った使い方は出来ない（はず）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@marco_cattaneo/android-viewmodel-and-factoryprovider-good-way-to-manage-it-with-dagger-2-d9e20a07084c&#34;&gt;Android ViewModel and FactoryProvider: good way to manage it with Dagger Multibindings&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Daggerのmultibindingsを使い、ViewModel Factoryを注入するパターン&lt;/li&gt;
&lt;li&gt;最初に仕組みを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;multibindingsを使っているのでランタイム時に落ちる可能性がある

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動かない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その場合ViewModelProviderを介さずインスタンス生成するので正しくない

&lt;ul&gt;
&lt;li&gt;間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ActivityKtxDaggerExample/tree/master/app/src/main/java/com/github/satoshun/example/sample&#34;&gt;Activity-Ktx + Dagger Example&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Factory用のカスタムクラスを定義し、ViewModel Factoryを注入するパターン

&lt;ul&gt;
&lt;li&gt;僕が作ったサンプルコードです😃　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最初に汎用クラスを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その場合ViewModelProviderを介さずインスタンス生成するので正しくない

&lt;ul&gt;
&lt;li&gt;間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;個人的には一番最後の自分のパターンを押したいところですが、上記のパターンはそれぞれメリット/デメリットがあると思うので、プロジェクトによって使い分けるのがよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一番プロジェクトに適したパターンを適用するのが良いと思います😃&lt;/li&gt;
&lt;li&gt;DaggerでViewModelサポートの&lt;a href=&#34;https://github.com/google/dagger/issues/1271&#34;&gt;Issue&lt;/a&gt;が立っており、DaggerがViewModelをサポートする計画があります

&lt;ul&gt;
&lt;li&gt;なので前述のパターンはいつか過去のものとなる可能性が高いです。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>

&lt;p&gt;&lt;code&gt;JitPack&lt;/code&gt;からライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。
詳しくは次のリンクを参照してください。&lt;a href=&#34;https://blog.autsoft.hu/a-confusing-dependency/&#34;&gt;A Confusing Dependency&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に &lt;a href=&#34;https://docs.gradle.org/5.1-rc-1/userguide/declaring_repositories.html#sec::matching_repositories_to_dependencies&#34;&gt;Matching repositories to dependencies&lt;/a&gt; が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）&lt;/p&gt;

&lt;p&gt;まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、&lt;code&gt;cloudflare&lt;/code&gt;のSDKを依存関係に入れることを目指します。
また、今回の検証にはGradle 5.1-rc-1を使いました。&lt;a href=&#34;https://github.com/satoshun-android-example/GradleDependencyMatchingExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは従来の書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
        }
    }
}

---

// projectのbuild.gradle
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと全てのライブラリに対して、repositoriesで指定した&lt;code&gt;https://storage.googleapis.com/cloudflare-maven/public/&lt;/code&gt;へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。&lt;/p&gt;

&lt;p&gt;次に新機能を使った書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
            content {
                // group idがcom.cloudflareのライブラリだけこのURLが有効になる
                includeGroup &amp;quot;com.cloudflare&amp;quot;
            }
        }
    }
}

---

// projectのbuild.gradleは一緒
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しくcontentブロックが追加されました。ここで、このURLがどのライブラリで有効になって欲しいかを記述することが出来ます。今回のURLは&lt;code&gt;com.cloudflare:cloudflare-mobile-sdk&lt;/code&gt;でのみ有効になって欲しいので、&lt;code&gt;includeGroup &amp;quot;com.cloudflare&amp;quot;&lt;/code&gt;とgroup id指定することで達成できます。これでcloudflareのライブラリに対してダウンロード制限をかけられます!!&lt;/p&gt;

&lt;p&gt;また今回の事件の場合、JCenterに悪意のあるライブラリがアップロードされたのが問題なので、JCenterからダウンロードしたいライブラリのgroup idを&lt;code&gt;includeGroup&lt;/code&gt;で指定してあげれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {
    ...
    jcenter().mavenContent {
        includeGroup &amp;quot;org.jetbrains.kotlin&amp;quot;
        includeGroup &amp;quot;org.jetbrains.kotlinx&amp;quot;
        includeGroup &amp;quot;com.google.dagger&amp;quot;
        includeGroup &amp;quot;org.jetbrains&amp;quot;
        includeGroup &amp;quot;javax.inject&amp;quot;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、JCenterからダウンロードするライブラリに制限をかけられます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AndroidだとGradle5系を使えるのがAndroid Gradle Plugin3.4からになると思うので、まだ先は長い😂&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>