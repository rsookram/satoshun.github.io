<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Fri, 07 Sep 2018 00:00:00 UTC</updated>
    
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>

&lt;p&gt;みなさんこんにちは&lt;/p&gt;

&lt;p&gt;今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として&lt;code&gt;@Inject lateinit var&lt;/code&gt; になってしまうところがあると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    @Inject lateinit var hoge: Hoge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをなんとか出来ないかなと思って考えてみました。&lt;/p&gt;

&lt;p&gt;結論から言うと最終形はこのようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;IntoMap&lt;/code&gt;を使って実装することにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IntoMap&lt;/code&gt;とはその名の通りMapにバインドするためのアノテーションです。
詳しくは&lt;a href=&#34;https://google.github.io/dagger/multibindings.html&#34;&gt;ドキュメント&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;サンプルコードで説明していきます。&lt;/p&gt;

&lt;p&gt;まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module
interface HogeModule {
    @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any
    @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any
}

class Hoge1 @Inject constructor()
class Hoge2 @Inject constructor()

@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
@MapKey
annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。&lt;/p&gt;

&lt;p&gt;作ったModuleをComponentに組み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(modules = [HogeModule::class])
interface AppComponent {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ApplicationでAppComponentを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class App : Application() {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt; by lazy {
    DaggerAppComponent.builder().build().values
    }

    inline fun &amp;lt;reified T&amp;gt; get(): T = values[T::class.java]!!.get() as T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、Activity用に拡張関数を定義して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T&amp;gt; Activity.inject() = lazy { get&amp;lt;T&amp;gt;() }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成です!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : AppCompatActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このアプローチの問題点は、というか問題点しかないんですけど、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ランタイムで落ちる可能性がある

&lt;ul&gt;
&lt;li&gt;Daggerの良さであるアノテーション時のチェックが消え去る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ScopeとかSubcomponentとかの対応方法が良く分かんない

&lt;ul&gt;
&lt;li&gt;まあこれは考えていないだけなので、もしかしたらいい方法があるかもしれない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いわゆるService Locatorパターンになってしまい微妙&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;サンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/SimpleDaggerExample&#34;&gt;https://github.com/satoshun-android-example/SimpleDaggerExample&lt;/a&gt; にあります。よかったら見てください😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>

&lt;p&gt;RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これは&lt;code&gt;Message#setAsynchronous&lt;/code&gt;を使うことで、UIのパフォーマンス向上を狙った機能です。
下のリンクに詳細な内容が書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@sweers/rxandroids-new-async-api-4ab5b3ad3e93&#34;&gt;RxAndroid’s New Async API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。&lt;/p&gt;

&lt;p&gt;検証に使用したサンプルプロジェクトは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトをかいつまんで説明します。&lt;/p&gt;

&lt;p&gt;まず2つのスケジューラを作成し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false)
private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// asyncがfalseの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(mainScheduler)
    .subscribe(...)

// asyncがtrueの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(asyncMainScheduler)
    .subscribe(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フルコードは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;結果は、以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;// API27 エミュレータ
main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和
main=130857ms, async=126582ms
main=131401ms, async=126909ms
main=130763ms, async=126504ms
main=132758ms, async=127972ms

// API21 エミュレータ
main=129869ms, async=125795ms
main=130050ms, async=125888ms
main=129935ms, async=125853ms
main=129908ms, async=125838ms
main=129927ms, async=125824ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。&lt;/p&gt;

&lt;p&gt;ただ注意点として、この機能は副作用がある可能性があります(なのでデフォルトではasyncはfasle)。ただ、Uberで1年間、プロダクションで運用したところ、特に大きな問題は起きなかったらしいので  &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/pull/416&#34;&gt;https://github.com/ReactiveX/RxAndroid/pull/416&lt;/a&gt; 、ほぼ安全と考えて良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;サンプルコードで検証した結果、async=trueでパフォーマンスの向上が得られそう&lt;/li&gt;
&lt;li&gt;導入は以下のコードを追加するだけなので、とても簡単&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;RxAndroidPlugins.setInitMainThreadSchedulerHandler {
    AndroidSchedulers.from(Looper.getMainLooper(), true)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>

&lt;p&gt;Dagge 2.17でfastInitオプションが追加されました。
&lt;a href=&#34;https://google.github.io/dagger/compiler-options&#34;&gt;https://google.github.io/dagger/compiler-options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。&lt;/p&gt;

&lt;p&gt;確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。&lt;/p&gt;

&lt;h2 id=&#34;確認に使用したシェルスクリプト&#34;&gt;確認に使用したシェルスクリプト&lt;/h2&gt;

&lt;p&gt;adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for i in {0..10}
do
    adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt
    sleep 10
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記を参考にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/performance/vitals/launch-time&#34;&gt;https://developer.android.com/topic/performance/vitals/launch-time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fastinit有効の場合&#34;&gt;fastInit有効の場合&lt;/h2&gt;

&lt;p&gt;下記をbuild.gradleに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    javacOptions {
        option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1609ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fastinit無効の場合&#34;&gt;fastInit無効の場合&lt;/h2&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1607ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ほぼ変わらない数字が出てきてしまいました。悲しい。
Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。&lt;/p&gt;

&lt;p&gt;芳しくない結果になった推測として&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;担当アプリのDaggerの書き方が正しくないからこの結果になった?

&lt;ul&gt;
&lt;li&gt;要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;確認に使用したコマンドが良くないのかも?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8/Proguardをちゃんと使う&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。&lt;/p&gt;

&lt;p&gt;実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。&lt;/p&gt;

&lt;p&gt;まずは、R8無しで調べてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然メソッドカウントが1増えています。&lt;/p&gt;

&lt;p&gt;次に、inlineを付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらもメソッドカウントが1増えました。
show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Metadata(
    mv = {1, 1, 10},
    bv = {1, 0, 2},
    k = 2,
    d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;},
    d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;}
)
public final class MainActivityKt {
    public static final void hoge() {
        String var1 = &amp;quot;hogehoge&amp;quot;;
        System.out.println(var1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、ここで重要なのは、inlineをつけたメソッドはインライン化されるため、上記のメソッドは生成されるけど、実際にはコールされない点です。
コールされない、参照がないのでR8で削除することができます。&lt;/p&gt;

&lt;p&gt;実際にR8/Proguardを有効にしてBuild APK → Analyze APKで確認したところ、inlineをつけた場合はメソッドカウントが増えていないことが確認できました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;InlineメソッドはR8/Proguardと組み合わせればメソッドカウントを減らす効果がある

&lt;ul&gt;
&lt;li&gt;とはいえ、5.0(ART)からはruntimeからmultidexをサポートしているので、昔ほどメソッドカウントを意識する必要はないと思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>

&lt;p&gt;ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。
この記事では&lt;a href=&#34;https://developer.android.com/reference/android/widget/Space&#34;&gt;Space&lt;/a&gt;を使ったネガティブマージンの実現について説明します。&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;ネガティブマージンと同等の大きさを持った&lt;code&gt;Space&lt;/code&gt;を定義して、そこにConstraintを設定するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:clipToPadding=&amp;quot;false&amp;quot;
    android:padding=&amp;quot;80dp&amp;quot;&amp;gt;

  &amp;lt;Space
      android:id=&amp;quot;@+id/negative&amp;quot;
      android:layout_width=&amp;quot;15dp&amp;quot;
      android:layout_height=&amp;quot;15dp&amp;quot;
      app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;ImageView
      android:id=&amp;quot;@+id/icon&amp;quot;
      android:layout_width=&amp;quot;30dp&amp;quot;
      android:layout_height=&amp;quot;30dp&amp;quot;
      android:contentDescription=&amp;quot;icon&amp;quot;
      app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot;
      app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot;
      tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/LQrkHsAeTBvqlZWuw1Ccpm_dvrnCsdK7aH2rMB6HYakF_jv3q6Zf_-QBtfOo1eD0EjLBOjxy11nx2TAlZstr354XRiSXt7HUxENJXji8ZxWNxeJUTe8g9jIstSO1PRMsw7f8O5xuCakktrJLSUPLk01CI1N6OJ9MGMvsSbSDO6o4t7oeipkV9f7klqmzdxtoxESyDzoEI5SfeMOxynhmTGLwv6RnaASEOzVyL2xEW8eq63erAiu6ptdwl-_rQkxAnAIhYpSuPZjweCPBzf3GiMJi5gx_Ciz348GmoSaTIhuGM6grHd181fBGkZQkbvgg5ggrk5pLlja1N4eZA54n5rgzKs5gT36fA8K_ZFrAQI0H50cvAbesIeDVb05MZ2pP592Kwb8moTt6xp0TTFYrJf-c-MVljio-JvAKuUC0fPWPpdgMyxkJHW4AzK9l-Yo4f2-dUdfEf06J6ktMOsld0Yzsyu07Hki6MSGeBjU3bJ3R0vDi-W6SBUNmcDzJu5kC-2ItGmq4sN8fq06XJMSwVTmfDAyfHOluWHOTlL5LV3YVvYZxxgGJ6_ldqdD2HZ0ZW8wuNpfrHTxGLYCHR5EN5ouY5ILx-snrNAfQPQ9Z9Ph0U_4UeCMlODslXyRpueecgOSBJUhwc47xrQ04b-xOJz_01EWEA61x=w1452-h720-no&#34; alt=&#34;constraintlayout-image&#34; width=&#34;600px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;簡単に説明すると、&lt;code&gt;Space&lt;/code&gt;に15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。
上記の例だと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginStart=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginTop=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と同等の振る舞いをしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ConstraintLayoutではネイティブでネガティブマージンに対応していないため、&lt;code&gt;Space&lt;/code&gt;を使った、ややテクニカルな方法で実現するのが良いと思われます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>&lt;p&gt;Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-aliases.html&#34;&gt;https://kotlinlang.org/docs/reference/type-aliases.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias MyHandler = (Int, String, Any) -&amp;gt; Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにtypealiasは、アノテーションをつけることも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JvmSuppressWildcards&lt;/code&gt;はDagger(&lt;a href=&#34;https://github.com/google/dagger/issues/668&#34;&gt;参考リンク&lt;/a&gt;)やretrofit(&lt;a href=&#34;https://github.com/square/retrofit/issues/1805&#34;&gt;参考リンク&lt;/a&gt;)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/google/dagger&#34;&gt;Dagger&lt;/a&gt;を使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。
Androidでは、すべてのActivityで共通のインスタンスを使うには &lt;code&gt;Singleton&lt;/code&gt;スコープとAppComponentを組み合わせて使う方法がよく知られています。
しかし、&lt;strong&gt;特定&lt;/strong&gt;のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。Singletonだと&lt;strong&gt;すべて&lt;/strong&gt;のActivity間で共通のインスタンスが使えてしまいます。&lt;/p&gt;

&lt;p&gt;この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。
また、基本的なDaggerの使い方は知っている前提で説明していきます。&lt;/p&gt;

&lt;p&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;になります。
コードを見ると理解がより深まると思うので、ぜひご覧になってください😊&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では説明していきます。今回のサンプルコードの目指すところは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserScopeを定義し、MainActivity、UserScopedActivityで同一の&lt;code&gt;UserManager&lt;/code&gt;インスタンスを使用する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;まず最初にUserScopeを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Scope
@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
annotation class UserScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にUserSubcomponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UserScope
@Subcomponent
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは、UserSubcomponentに&lt;code&gt;UserScope&lt;/code&gt;スコープを持たせています。
このように書くことで、SubcomponentとScopeを結びつけることが出来ます。&lt;/p&gt;

&lt;p&gt;次にAppComponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  // AppComponentとUserSubcomponentを結びつける
  val userComponentBuilder: UserSubcomponent.Builder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは&lt;code&gt;AppComponent&lt;/code&gt;に、&lt;code&gt;val userComponentBuilder: UserSubcomponent.Builder&lt;/code&gt;を定義することです。
こうすることで、&lt;code&gt;AppComponent&lt;/code&gt;に&lt;code&gt;UserSubcomponent&lt;/code&gt;を結び付けることが出来ます。&lt;/p&gt;

&lt;p&gt;これで基本的な部分の定義は完了しました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次に、各ActivityをComponentに結びつけていきます。
サンプルではMainActivity、UserScopedActivityとNoUserScopedActivityの3つのActivityを定義しており、
それぞれのActivityは以下のように振る舞わせたいとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mainactivity-userscopedactivityをusersubcomponentに従わせる&#34;&gt;MainActivity、UserScopedActivityをUserSubcomponentに従わせる&lt;/h2&gt;

&lt;p&gt;MainActivity、UserScopedActivityを&lt;code&gt;UserSubcomponent&lt;/code&gt;に定義することで、MainActivity、UserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従わせることが出来ます。
なぜなら、&lt;code&gt;UserSubcomponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いているためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserSubcomponent.kt
@UserScope
@Subcomponent(modules = [
  MainActivityModule::class,
  UserScopedActivityModule::class
])
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}

// MainActivityModule.kt
@Module
interface MainActivityModule {
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nouserscopedactivityはuserscopeに従わない&#34;&gt;NoUserScopedActivityはUserScopeに従わない&lt;/h2&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;AppComponent&lt;/code&gt;に定義することで、NoUserScopedActivityで&lt;code&gt;UserScope&lt;/code&gt;を使っていたらコンパイルエラーにすることが出来ます。
&lt;code&gt;AppComponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いていないためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// AppComponent.kt
@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class,
      NoUserScopedActivityModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  val userComponentBuilder: UserSubcomponent.Builder
}

// NoUserScopedActivityModule.kt
@Module
interface NoUserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeNoUserScopedActivity(): NoUserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、定義は完了です。実際に正しく動くかを確認してみます。
適当に&lt;code&gt;UserScope&lt;/code&gt;に従う&lt;code&gt;UserManager&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserManager.kt
@UserScope
class UserManager @Inject constructor() {
  var value = 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;UserScope&lt;/code&gt;に従うので、MainActivity、UserScopedActivityには期待通り同一インスタンスが&lt;code&gt;Inject&lt;/code&gt;できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivity.kt
class MainActivity : AppCompatActivity() {

  // ok
  @Inject lateinit var userManager: UserManager

  ...
}
// UserScopedActivity.kt
class UserScopedActivity : AppCompatActivity() {

  // ok: MainActivityと同じインスタンスが注入される
  @Inject lateinit var userManager: UserManager

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、NoUserScopedActivityに&lt;code&gt;Inject&lt;/code&gt;しようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// NoUserScopedActivity.kt
class NoUserScopedActivity : AppCompatActivity() {

  //  下のコメントアウトを取るとコンパイルエラー
  //  @Inject lateinit var userManager: UserManager
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従う形で定義してないためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が達成できました。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;そもそも、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;定義時に、&lt;code&gt;UserScope&lt;/code&gt;スコープを付与してあげればいいんじゃないかと思うかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivityModule.kt
@Module
interface MainActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このやり方だと、今回のケースには不都合です。&lt;/p&gt;

&lt;p&gt;MainActivity、UserScopedActivityは&lt;code&gt;UserScope&lt;/code&gt;に従うのでコンパイルは通ります。
しかし、MainActivity、UserScopedActivityで同一インスタンスを使うことは出来ません。&lt;/p&gt;

&lt;p&gt;何故かと言うと、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;はSubcomponentを作るシンタックスシュガーのようなものですが、
&lt;code&gt;MainActivityModule&lt;/code&gt;と&lt;code&gt;UserScopedActivityModule&lt;/code&gt;はそれぞれ独立したSubcomponentを作るので、独立したComponent間で同一インスタンスを使うことが出来ないためです。&lt;/p&gt;

&lt;p&gt;今回のように、&lt;code&gt;UserSubcomponent&lt;/code&gt;を定義して、そのComponentをベースに所属させる必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;特定のActivityのみで共通のインスタンスを使いたいときは、結構めんどう

&lt;ul&gt;
&lt;li&gt;冗長な気がするので、もっといい方法があったら教えてください😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;がどういう動作をするのかを知っておくと、いざというときに便利&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>

&lt;p&gt;Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。
ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。&lt;/p&gt;

&lt;p&gt;このライブラリの機能に、&lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#Safe-args&#34;&gt;safeargs&lt;/a&gt;というものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。&lt;/p&gt;

&lt;h2 id=&#34;safeargsを使ってみる&#34;&gt;safeargsを使ってみる&lt;/h2&gt;

&lt;p&gt;一般的にFragmentに適当な値を渡すときは&lt;code&gt;Bundle&lt;/code&gt;を通して渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
val bundle = Bundle()
bundle.putInt(&amp;quot;step&amp;quot;, 10)

// 呼び出され側
val step = arguments?.getInt(&amp;quot;step&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&lt;code&gt;&amp;quot;step2&amp;quot;&lt;/code&gt;にしてしまうと、ランタイムエラーになります。&lt;/p&gt;

&lt;p&gt;これを解決にするためにNavigationではsafe argsという機能を提供しています。
これは、DataBindingのように、クラスを生成することでtypesafeを実現します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
            xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
            xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt;
  &amp;lt;fragment
      android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot;
      android:label=&amp;quot;Hoge&amp;quot;&amp;gt;

    &amp;lt;argument
        android:name=&amp;quot;step&amp;quot;
        app:type=&amp;quot;integer&amp;quot;
        android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt;
  &amp;lt;/fragment&amp;gt;
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とnavigationを記述すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HogeFragmentArgs {
  private int step = 1;

  private HogeFragmentArgs() {
  }

  public static HogeFragmentArgs fromBundle(Bundle bundle) {
    HogeFragmentArgs result = new HogeFragmentArgs();
    if (bundle.containsKey(&amp;quot;step&amp;quot;)) {
      result.step = bundle.getInt(&amp;quot;step&amp;quot;);
    }
    return result;
  }

  public int getStep() {
    return step;
  }

  public Bundle toBundle() {
    Bundle __outBundle = new Bundle();
    __outBundle.putInt(&amp;quot;step&amp;quot;, this.step);
    return __outBundle;
  }

  public static class Builder {
    private int step = 1;

    public Builder(HogeFragmentArgs original) {
      this.step = original.step;
    }

    public Builder() {
    }

    public HogeFragmentArgs build() {
      HogeFragmentArgs result = new HogeFragmentArgs();
      result.step = this.step;
      return result;
    }

    public Builder setStep(int step) {
      this.step = step;
      return this;
    }

    public int getStep() {
      return step;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のクラスが生成されます。これを使うことでtypesafeを実現出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
HogeFragmentArgs.Builder()
    .setStep(10)
    .build()
    .toBunble()

// 呼び出され側
val args = HogeFragmentArgs.fromBundle(arguments)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Navigationは大きいライブラリなので、とりあえずの練習でsafe argsの機能だけつまみ食いするのは、
個人的には良さそうだと思っています。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlecodelabs/android-navigation&#34;&gt;https://github.com/googlecodelabs/android-navigation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>

&lt;p&gt;LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。
適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。&lt;/p&gt;

&lt;p&gt;定義は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; {
  // skip用の初期値を入れておく
  return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null }
}

fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) {
  // 最初の値は常にskipすることで、キャッシュを無視する
  val firstIgnore = AtomicBoolean(true)
  this.observe(owner, Observer {
    if (firstIgnore.getAndSet(false)) return@Observer
    observer(it)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使う時はこんな感じで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// TestViewModel.kt
class TestViewModel: ViewModel() {
  val errorEvent = singleLiveData&amp;lt;String&amp;gt;()
}

// TestActivity.kt
testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java)
testViewModel.errorEvent.observeSingle(activity) {
  Log.d(&amp;quot;one&amp;quot;, it.toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メリットはサブクラスを作らずに済むところです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&#34;&gt;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&#34;&gt;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description>

&lt;p&gt;CoroutineBindingライブラリを作ったのでその紹介です。
&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android開発でCoroutineの流れが来ていると思っていて、&lt;a href=&#34;https://github.com/JakeWharton/RxBinding&#34;&gt;RxBinding&lt;/a&gt;のような感じで、
CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;例えばclickのイベントを受け取りたいとします。
CoroutineBindingでは以下のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root)
launch(UI) {
    for (click in root.clicks()) {
       Log.d(&amp;quot;clicked&amp;quot;, click.toString())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RxBindingのように使うことが出来ます!
他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt; 何かあればissueや、PRを貰えると嬉しいです&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>&lt;p&gt;Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。&lt;/p&gt;

&lt;p&gt;まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。
振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。&lt;/p&gt;

&lt;p&gt;型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;to be continued.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description>

&lt;p&gt;ポエムです。&lt;/p&gt;

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;p&gt;基本的にローカルで明示的に型を宣言するのは好ましくない&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userName = dataSource.getUserName()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。&lt;/p&gt;

&lt;p&gt;Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。&lt;/p&gt;

&lt;p&gt;理由としては、Data Bindingの生成が失敗すると、&lt;code&gt;MainActivityBinding&lt;/code&gt;みたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。
デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)&lt;/p&gt;

&lt;h2 id=&#34;解決法&#34;&gt;解決法&lt;/h2&gt;

&lt;p&gt;全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;kapt {
    javacOptions {
        option(&amp;quot;-Xmaxerrs&amp;quot;, 5000)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。&lt;/p&gt;

&lt;p&gt;これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。&lt;/p&gt;

&lt;p&gt;before(一部ログ修正しています)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;...
// 長いエラーログ
...
...
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
e: ActivityMainBinding.java:91: error: cannot find symbol
      @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) {
                                                                ^
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
e: ActivityMainBinding.java:102: error: cannot find symbol
      @Nullable DataBindingComponent component) {
                ^
  symbol:   class DataBindingComponent
  location: class ActivityMainBinding
:app:kaptProductDebugKotlin FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;after&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;...
// 長いエラーログ
...
...
e: :96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                ^
e::96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                     ^
e: :96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                           ^
e: .java:96: error: incompatible types: possible lossy conversion from long to int
    @android.support.annotation.IntDef(value = {-1L, 500L, 20002L, 20004L})
                                                                   ^
:app:kaptProductDebugKotlin FAILED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beforeではDataBindingの参照エラーしか出ていないんですが、afterではIntDefでのエラーログが出ていることが分かります。
これが本当に欲しかったエラーログで、これを修正することで無事解決することが出来ました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Data Binding便利だけどやっぱつれぇわ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>

&lt;p&gt;ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。&lt;/p&gt;

&lt;p&gt;例えば以下のようなActivityがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : Activity() {
    ...
    ...

    private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを見た時、「なんで &lt;code&gt;loginCount &amp;lt;= 100&lt;/code&gt;にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : Activity() {
    private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() {
         // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。&lt;/p&gt;

&lt;p&gt;ただ、自分の考えでは上記のコードは根本的に間違っていると思っていて、そもそもActivityでコメントが必要なほど複雑なことをしているのが問題だと思います。
なんでActivityで複雑なことをしてはいけないかというと、ActivtyはContextにアクセスできたりと、なんでも出来るからです。なんでも出来る層でいろいろやってしまうと、
いわゆるfat activity問題が起こってしまいます。&lt;/p&gt;

&lt;p&gt;なので上記のコードだと、例えばUserモデル(データ)クラスのようなものを作ってそこにロジックを書いて、必要に応じてコメントを付加するのが良いと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class User(private val loginCount: Int, private val firstAccess: Boolean) {
    private fun isHeavyUser() : Boolean() {
         // 100回以上ログインした場合は超heavy userなので100以上はheavy userではない
        return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100)
    }

    private fun hyperHeavyUser(): Boolean() { /** */ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人間に理解し難いビジネスロジックのコメントは、モデルクラス(世の中的にはドメインモデルとか言われているのカナ?)に書くのが良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Activityにコメントを書きたくなったら、クラスを分割したほうが良い&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;とはいえActivityにコメントを書く正しいケースもあると思うので、そこらへんは柔軟にオナシャス&lt;/li&gt;
&lt;li&gt;コメントはコードと違い、コンピュータがコンパイルして正当性を確かめてくれるわけでないので、正しく運用するのがコードより難しいと思う&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: Androidアプリ設計パターン入門</title>
      <link>https://satoshun.github.io/2018/03/android-architecture-started/</link>
      <pubDate>Fri, 02 Mar 2018 00:28:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/03/android-architecture-started/</guid>
      <description>

&lt;p&gt;Androidアプリ設計パターン入門を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://peaks.cc/books/architecture_patterns&#34;&gt;https://peaks.cc/books/architecture_patterns&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MVP

&lt;ul&gt;
&lt;li&gt;PresenterがViewとModelへの仲介役なので、Presenterはどうしてもfatになりそう

&lt;ul&gt;
&lt;li&gt;PresenterでView、Modelが何を出来るかを知らなければならない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Contractみたいなインタフェースを切るのは好き

&lt;ul&gt;
&lt;li&gt;それを見ただけで何をそのページでやっているのかが掴めるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PresenterはContextを知らなく良い、Pure Javaなのでテスタブルだし綺麗になりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MVVM

&lt;ul&gt;
&lt;li&gt;個人的にはMVPより好き

&lt;ul&gt;
&lt;li&gt;ViewModelがViewの参照を持たなくて良いので少しスッキリする

&lt;ul&gt;
&lt;li&gt;ただViewへの参照がないだけで、LiveDataなりObservableFieldに値を書き出すので実質的にはViewがどんなことをしたいか知っているから同等といえば同等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Viewへの参照を持たないので、AACのViewModelへの適合性は高いと思う

&lt;ul&gt;
&lt;li&gt;DataBindingのObservableFieldとかを使わない前提。使うとViewへの参照を持ってメモリリークしちゃう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Flux

&lt;ul&gt;
&lt;li&gt;単一方向データフローは凄い良いと思う

&lt;ul&gt;
&lt;li&gt;単一方向はFluxだけに限らないけど、Fluxを象徴する1つの特徴&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelとかPresenterって処理が集中する傾向にあると感じていて、FluxだとStore、ActionCreatorって形で切り出せるから良い&lt;/li&gt;
&lt;li&gt;FluxもAACとの相性は良いと思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;負債の話

&lt;ul&gt;
&lt;li&gt;負債に対する解決策の1つとしてReact Nativeを出すのは発想として凄いと思ったし、そういう解決方法もあるのかと思った&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;メモ

&lt;ul&gt;
&lt;li&gt;データ層の抽象化に関してはRepository的なものを作るで良さそう&lt;/li&gt;
&lt;li&gt;データ側はRx、UI側に反映する時はLiveDataが良さそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>