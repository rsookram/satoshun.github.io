<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2018 Sato Shun</copyright>
    <updated>Tue, 16 Oct 2018 00:00:00 UTC</updated>
    
    
    <item>
      <title>Kotlinで3つの関数のパラメータを省略する</title>
      <link>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</guid>
      <description>

&lt;p&gt;Kotlinでは拡張関数が定義されており、拡張関数を使うことで1つ関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun hoge(a: String) {
  println(a)
}

-&amp;gt;

fun String.hoge() {
  println(this)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、インターフェース（クラス）内で拡張関数を定義することで、さらに1つの関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface User

fun hoge(a: String, b: User) {
  println(a)
  println(b)
}

-&amp;gt;

interface User {
  fun String.hoge() {
    println(this)
    println(this@User)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、reified type parameterを使うことで、関数のパラメータを省略できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; hoge(a: String, b: User, c: Class&amp;lt;T&amp;gt;) {
  println(a)
  println(b)
  println(c)
}

-&amp;gt;

class User {
  inline fun &amp;lt;reified T&amp;gt; String.hoge() {
    println(this)
    println(this@User)
    println(T::class)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interfaceだと、inline関数が使えないのでクラスで定義してあります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kotlinの拡張関数、reified便利😊&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description>

&lt;p&gt;ふとAACの&lt;a href=&#34;https://developer.android.com/reference/androidx/lifecycle/ViewModel&#34;&gt;ViewModel&lt;/a&gt;のonClearedメソッドをテストしたくなったので、 2つのやりかたを紹介します。&lt;/p&gt;

&lt;p&gt;環境は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;junit:junit:4.12&amp;quot;
&amp;quot;androidx.test:rules:1.1.0-beta02&amp;quot;
&amp;quot;androidx.test:runner:1.1.0-beta02&amp;quot;
&amp;quot;androidx.test.ext:junit:1.0.0-beta02&amp;quot;
&amp;quot;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;quot;
&amp;quot;org.robolectric:robolectric:4.0-beta-1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;になります。&lt;/p&gt;

&lt;p&gt;また、サンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/architectures/BaseViewModelTest.kt&#34;&gt;GitHub&lt;/a&gt;にあるので、参考してください😊&lt;/p&gt;

&lt;h3 id=&#34;1-viewmodelstore-を使う&#34;&gt;1. &lt;code&gt;ViewModelStore&lt;/code&gt;を使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ViewModelProviders.of(activity).get(class)&lt;/code&gt;からViewModelを取得したときに、取得したViewModelは&lt;a href=&#34;https://developer.android.com/reference/androidx/lifecycle/ViewModelStore&#34;&gt;ViewModelStore&lt;/a&gt;にキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(AndroidJUnit4::class)
class BaseViewModelTest {
  @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java)

  @Test
  fun `dispose a coroutine when finished lifecycle of ViewModel`() {
    activityRule.activity.viewModelStore.clear() // ViewModelが開放される
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このテストはコード的には簡単ですが、ViewModelStoreがViewModelのライフサイクルを管理しているということを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。&lt;/p&gt;

&lt;p&gt;なので、素直にonDestroyをコールするテストも書いてみます。&lt;/p&gt;

&lt;h3 id=&#34;2-instrumentation-callactivityondestroy-を使う&#34;&gt;2. &lt;code&gt;Instrumentation.callActivityOnDestroy&lt;/code&gt;を使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Instrumentation&lt;/code&gt;クラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。
&lt;code&gt;Instrumentation&lt;/code&gt;は&lt;code&gt;InstrumentationRegistry&lt;/code&gt;クラスから取得することができ、次のように書くことで、&lt;code&gt;onDestroy&lt;/code&gt;をコールすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Test
fun `dispose a coroutine when finished lifecycle of ViewModel 2`() {
  // onDestroyがコールされViewModelが開放される
  InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Unitテストで&lt;code&gt;ViewModel.onCleared&lt;/code&gt;のテストをすることが出来ます。&lt;/p&gt;

&lt;p&gt;以上です。Happy Testing☆彡&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/architectures/BaseViewModelTest.kt&#34;&gt;サンプルコード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>&lt;p&gt;（この記事は1.3-M2を使っています。）&lt;/p&gt;

&lt;p&gt;Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。&lt;/p&gt;

&lt;p&gt;例えば、次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline class UserId(val id: String) {
    val url get() = &amp;quot;http://$id&amp;quot;
}

val userId = UserId(&amp;quot;user-dayo&amp;quot;)
println(userId.url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは一見、UserIdクラスが生成されそうです。しかし、コンパイルされたコードではUserIdクラスは生成されません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final class UserId$Erased {
    ...

    @NotNull
    public static final String getUrl(String $this) {
        return &amp;quot;http://&amp;quot; + $this;
    }

    ...
}

String userId = &amp;quot;user-dayo&amp;quot;;
String var1 = UserId$Erased.getUrl(userId);
System.out.println(var1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成された&lt;code&gt;UserId$Erased&lt;/code&gt;クラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。&lt;/p&gt;

&lt;p&gt;ここからが本題です。
Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。&lt;/p&gt;

&lt;p&gt;例えば、次のコードがあったとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class Response(
    @SerializedName(&amp;quot;user_id&amp;quot;) val userId: String,
    @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: String
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはuserIdとfriendIdをStringで受け取っており、このStringが何のStringかの情報が欠落しています。型による分類が出来てない状態です。&lt;/p&gt;

&lt;p&gt;これにInline classesを使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline class UserId(private val id: String) {
    val url get() = &amp;quot;http://my/$id&amp;quot;
}

inline class FriendId(private val id: String) {
    val url get() = &amp;quot;http://friend/$id&amp;quot;
}

data class Response(
    @SerializedName(&amp;quot;user_id&amp;quot;) val userId: UserId,
    @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: FriendId
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserIdとFriendIdクラスで受け取ることが出来ます。Inline classesがコンパイルされると、wrapされた値の型が展開されるためです。UserId、FriendIdのwrapされた値はStringなので、コンパイル後はStringが展開され、Stringでdeserialize/serializeされます。しかし、コンパイルされる前までは型安全の恩恵を受け取ることが出来ます。&lt;/p&gt;

&lt;p&gt;Inline classesを使えば、Adapterを作成することなく、カスタムのクラスで受け取れるため非常に便利です(・o・)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>

&lt;p&gt;みなさんこんにちは&lt;/p&gt;

&lt;p&gt;今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として&lt;code&gt;@Inject lateinit var&lt;/code&gt; になってしまうところがあると思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    @Inject lateinit var hoge: Hoge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをなんとか出来ないかなと思って考えてみました。&lt;/p&gt;

&lt;p&gt;結論から言うと最終形はこのようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。&lt;/p&gt;

&lt;p&gt;今回は&lt;code&gt;IntoMap&lt;/code&gt;を使って実装することにしました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IntoMap&lt;/code&gt;とはその名の通りMapにバインドするためのアノテーションです。
詳しくは&lt;a href=&#34;https://google.github.io/dagger/multibindings.html&#34;&gt;ドキュメント&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;サンプルコードで説明していきます。&lt;/p&gt;

&lt;p&gt;まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module
interface HogeModule {
    @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any
    @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any
}

class Hoge1 @Inject constructor()
class Hoge2 @Inject constructor()

@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
@MapKey
annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。&lt;/p&gt;

&lt;p&gt;作ったModuleをComponentに組み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(modules = [HogeModule::class])
interface AppComponent {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ApplicationでAppComponentを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class App : Application() {
    val values: Map&amp;lt;Class&amp;lt;out Any&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;Any&amp;gt;&amp;gt; by lazy {
    DaggerAppComponent.builder().build().values
    }

    inline fun &amp;lt;reified T&amp;gt; get(): T = values[T::class.java]!!.get() as T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、Activity用に拡張関数を定義して、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T&amp;gt; Activity.inject() = lazy { get&amp;lt;T&amp;gt;() }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成です!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class HogeActivity : AppCompatActivity {
    private val hoge: Hoge by inject()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;このアプローチの問題点は、というか問題点しかないんですけど、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ランタイムで落ちる可能性がある

&lt;ul&gt;
&lt;li&gt;Daggerの良さであるアノテーション時のチェックが消え去る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ScopeとかSubcomponentとかの対応方法が良く分かんない

&lt;ul&gt;
&lt;li&gt;まあこれは考えていないだけなので、もしかしたらいい方法があるかもしれない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いわゆるService Locatorパターンになってしまい微妙&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;サンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/SimpleDaggerExample&#34;&gt;https://github.com/satoshun-android-example/SimpleDaggerExample&lt;/a&gt; にあります。よかったら見てください😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>

&lt;p&gt;RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これは&lt;code&gt;Message#setAsynchronous&lt;/code&gt;を使うことで、UIのパフォーマンス向上を狙った機能です。
下のリンクに詳細な内容が書かれています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@sweers/rxandroids-new-async-api-4ab5b3ad3e93&#34;&gt;RxAndroid’s New Async API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。&lt;/p&gt;

&lt;p&gt;検証に使用したサンプルプロジェクトは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトをかいつまんで説明します。&lt;/p&gt;

&lt;p&gt;まず2つのスケジューラを作成し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false)
private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// asyncがfalseの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(mainScheduler)
    .subscribe(...)

// asyncがtrueの場合
Observable
    .fromCallable { System.currentTimeMillis() }
    .delay(index, TimeUnit.MILLISECONDS)
    .observeOn(asyncMainScheduler)
    .subscribe(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フルコードは以下になります。
&lt;a href=&#34;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&#34;&gt;https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;結果は、以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;// API27 エミュレータ
main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和
main=130857ms, async=126582ms
main=131401ms, async=126909ms
main=130763ms, async=126504ms
main=132758ms, async=127972ms

// API21 エミュレータ
main=129869ms, async=125795ms
main=130050ms, async=125888ms
main=129935ms, async=125853ms
main=129908ms, async=125838ms
main=129927ms, async=125824ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。&lt;/p&gt;

&lt;p&gt;ただ注意点として、この機能は副作用がある可能性があります(なのでデフォルトではasyncはfasle)。ただ、Uberで1年間、プロダクションで運用したところ、特に大きな問題は起きなかったらしいので  &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/pull/416&#34;&gt;https://github.com/ReactiveX/RxAndroid/pull/416&lt;/a&gt; 、ほぼ安全と考えて良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;サンプルコードで検証した結果、async=trueでパフォーマンスの向上が得られそう&lt;/li&gt;
&lt;li&gt;導入は以下のコードを追加するだけなので、とても簡単&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;RxAndroidPlugins.setInitMainThreadSchedulerHandler {
    AndroidSchedulers.from(Looper.getMainLooper(), true)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>

&lt;p&gt;Dagge 2.17でfastInitオプションが追加されました。
&lt;a href=&#34;https://google.github.io/dagger/compiler-options&#34;&gt;https://google.github.io/dagger/compiler-options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。&lt;/p&gt;

&lt;p&gt;確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。&lt;/p&gt;

&lt;h2 id=&#34;確認に使用したシェルスクリプト&#34;&gt;確認に使用したシェルスクリプト&lt;/h2&gt;

&lt;p&gt;adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for i in {0..10}
do
    adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt
    sleep 10
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記を参考にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/performance/vitals/launch-time&#34;&gt;https://developer.android.com/topic/performance/vitals/launch-time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fastinit有効の場合&#34;&gt;fastInit有効の場合&lt;/h2&gt;

&lt;p&gt;下記をbuild.gradleに追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    javacOptions {
        option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1609ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fastinit無効の場合&#34;&gt;fastInit無効の場合&lt;/h2&gt;

&lt;p&gt;結果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;平均: 1607ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ほぼ変わらない数字が出てきてしまいました。悲しい。
Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。&lt;/p&gt;

&lt;p&gt;芳しくない結果になった推測として&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;担当アプリのDaggerの書き方が正しくないからこの結果になった?

&lt;ul&gt;
&lt;li&gt;要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;確認に使用したコマンドが良くないのかも?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R8/Proguardをちゃんと使う&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。&lt;/p&gt;

&lt;p&gt;実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。&lt;/p&gt;

&lt;p&gt;まずは、R8無しで調べてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然メソッドカウントが1増えています。&lt;/p&gt;

&lt;p&gt;次に、inlineを付けてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun hoge() {
    println(&amp;quot;hogehoge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらもメソッドカウントが1増えました。
show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Metadata(
    mv = {1, 1, 10},
    bv = {1, 0, 2},
    k = 2,
    d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;},
    d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;}
)
public final class MainActivityKt {
    public static final void hoge() {
        String var1 = &amp;quot;hogehoge&amp;quot;;
        System.out.println(var1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、ここで重要なのは、inlineをつけたメソッドはインライン化されるため、上記のメソッドは生成されるけど、実際にはコールされない点です。
コールされない、参照がないのでR8で削除することができます。&lt;/p&gt;

&lt;p&gt;実際にR8/Proguardを有効にしてBuild APK → Analyze APKで確認したところ、inlineをつけた場合はメソッドカウントが増えていないことが確認できました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;InlineメソッドはR8/Proguardと組み合わせればメソッドカウントを減らす効果がある

&lt;ul&gt;
&lt;li&gt;とはいえ、5.0(ART)からはruntimeからmultidexをサポートしているので、昔ほどメソッドカウントを意識する必要はないと思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>

&lt;p&gt;ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。
この記事では&lt;a href=&#34;https://developer.android.com/reference/android/widget/Space&#34;&gt;Space&lt;/a&gt;を使ったネガティブマージンの実現について説明します。&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;ネガティブマージンと同等の大きさを持った&lt;code&gt;Space&lt;/code&gt;を定義して、そこにConstraintを設定するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:clipToPadding=&amp;quot;false&amp;quot;
    android:padding=&amp;quot;80dp&amp;quot;&amp;gt;

  &amp;lt;Space
      android:id=&amp;quot;@+id/negative&amp;quot;
      android:layout_width=&amp;quot;15dp&amp;quot;
      android:layout_height=&amp;quot;15dp&amp;quot;
      app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;ImageView
      android:id=&amp;quot;@+id/icon&amp;quot;
      android:layout_width=&amp;quot;30dp&amp;quot;
      android:layout_height=&amp;quot;30dp&amp;quot;
      android:contentDescription=&amp;quot;icon&amp;quot;
      app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot;
      app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot;
      tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/LQrkHsAeTBvqlZWuw1Ccpm_dvrnCsdK7aH2rMB6HYakF_jv3q6Zf_-QBtfOo1eD0EjLBOjxy11nx2TAlZstr354XRiSXt7HUxENJXji8ZxWNxeJUTe8g9jIstSO1PRMsw7f8O5xuCakktrJLSUPLk01CI1N6OJ9MGMvsSbSDO6o4t7oeipkV9f7klqmzdxtoxESyDzoEI5SfeMOxynhmTGLwv6RnaASEOzVyL2xEW8eq63erAiu6ptdwl-_rQkxAnAIhYpSuPZjweCPBzf3GiMJi5gx_Ciz348GmoSaTIhuGM6grHd181fBGkZQkbvgg5ggrk5pLlja1N4eZA54n5rgzKs5gT36fA8K_ZFrAQI0H50cvAbesIeDVb05MZ2pP592Kwb8moTt6xp0TTFYrJf-c-MVljio-JvAKuUC0fPWPpdgMyxkJHW4AzK9l-Yo4f2-dUdfEf06J6ktMOsld0Yzsyu07Hki6MSGeBjU3bJ3R0vDi-W6SBUNmcDzJu5kC-2ItGmq4sN8fq06XJMSwVTmfDAyfHOluWHOTlL5LV3YVvYZxxgGJ6_ldqdD2HZ0ZW8wuNpfrHTxGLYCHR5EN5ouY5ILx-snrNAfQPQ9Z9Ph0U_4UeCMlODslXyRpueecgOSBJUhwc47xrQ04b-xOJz_01EWEA61x=w1452-h720-no&#34; alt=&#34;constraintlayout-image&#34; width=&#34;600px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;簡単に説明すると、&lt;code&gt;Space&lt;/code&gt;に15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。
上記の例だと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginStart=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:layout_marginTop=&amp;quot;-15px&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と同等の振る舞いをしています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ConstraintLayoutではネイティブでネガティブマージンに対応していないため、&lt;code&gt;Space&lt;/code&gt;を使った、ややテクニカルな方法で実現するのが良いと思われます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>&lt;p&gt;Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-aliases.html&#34;&gt;https://kotlinlang.org/docs/reference/type-aliases.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias MyHandler = (Int, String, Any) -&amp;gt; Unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにtypealiasは、アノテーションをつけることも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JvmSuppressWildcards&lt;/code&gt;はDagger(&lt;a href=&#34;https://github.com/google/dagger/issues/668&#34;&gt;参考リンク&lt;/a&gt;)やretrofit(&lt;a href=&#34;https://github.com/square/retrofit/issues/1805&#34;&gt;参考リンク&lt;/a&gt;)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/google/dagger&#34;&gt;Dagger&lt;/a&gt;を使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。
Androidでは、すべてのActivityで共通のインスタンスを使うには &lt;code&gt;Singleton&lt;/code&gt;スコープとAppComponentを組み合わせて使う方法がよく知られています。
しかし、&lt;strong&gt;特定&lt;/strong&gt;のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。Singletonだと&lt;strong&gt;すべて&lt;/strong&gt;のActivity間で共通のインスタンスが使えてしまいます。&lt;/p&gt;

&lt;p&gt;この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。
また、基本的なDaggerの使い方は知っている前提で説明していきます。&lt;/p&gt;

&lt;p&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;になります。
コードを見ると理解がより深まると思うので、ぜひご覧になってください😊&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では説明していきます。今回のサンプルコードの目指すところは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserScopeを定義し、MainActivity、UserScopedActivityで同一の&lt;code&gt;UserManager&lt;/code&gt;インスタンスを使用する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;p&gt;まず最初にUserScopeを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Scope
@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
annotation class UserScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にUserSubcomponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@UserScope
@Subcomponent
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは、UserSubcomponentに&lt;code&gt;UserScope&lt;/code&gt;スコープを持たせています。
このように書くことで、SubcomponentとScopeを結びつけることが出来ます。&lt;/p&gt;

&lt;p&gt;次にAppComponentを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  // AppComponentとUserSubcomponentを結びつける
  val userComponentBuilder: UserSubcomponent.Builder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでのポイントは&lt;code&gt;AppComponent&lt;/code&gt;に、&lt;code&gt;val userComponentBuilder: UserSubcomponent.Builder&lt;/code&gt;を定義することです。
こうすることで、&lt;code&gt;AppComponent&lt;/code&gt;に&lt;code&gt;UserSubcomponent&lt;/code&gt;を結び付けることが出来ます。&lt;/p&gt;

&lt;p&gt;これで基本的な部分の定義は完了しました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次に、各ActivityをComponentに結びつけていきます。
サンプルではMainActivity、UserScopedActivityとNoUserScopedActivityの3つのActivityを定義しており、
それぞれのActivityは以下のように振る舞わせたいとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mainactivity-userscopedactivityをusersubcomponentに従わせる&#34;&gt;MainActivity、UserScopedActivityをUserSubcomponentに従わせる&lt;/h2&gt;

&lt;p&gt;MainActivity、UserScopedActivityを&lt;code&gt;UserSubcomponent&lt;/code&gt;に定義することで、MainActivity、UserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従わせることが出来ます。
なぜなら、&lt;code&gt;UserSubcomponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いているためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserSubcomponent.kt
@UserScope
@Subcomponent(modules = [
  MainActivityModule::class,
  UserScopedActivityModule::class
])
interface UserSubcomponent {
  @Subcomponent.Builder
  interface Builder {
    fun build(): UserSubcomponent
  }

  val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
}

// MainActivityModule.kt
@Module
interface MainActivityModule {
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nouserscopedactivityはuserscopeに従わない&#34;&gt;NoUserScopedActivityはUserScopeに従わない&lt;/h2&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;AppComponent&lt;/code&gt;に定義することで、NoUserScopedActivityで&lt;code&gt;UserScope&lt;/code&gt;を使っていたらコンパイルエラーにすることが出来ます。
&lt;code&gt;AppComponent&lt;/code&gt;は&lt;code&gt;UserScope&lt;/code&gt;に紐付いていないためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// AppComponent.kt
@Singleton
@Component(
    modules = [
      AndroidSupportInjectionModule::class,
      NoUserScopedActivityModule::class
    ]
)
interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; {
  @Component.Builder
  interface Builder {
    @BindsInstance
    fun application(application: App): Builder

    fun build(): AppComponent
  }

  override fun inject(app: App)

  val userComponentBuilder: UserSubcomponent.Builder
}

// NoUserScopedActivityModule.kt
@Module
interface NoUserScopedActivityModule {
  @ContributesAndroidInjector
  fun contributeNoUserScopedActivity(): NoUserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、定義は完了です。実際に正しく動くかを確認してみます。
適当に&lt;code&gt;UserScope&lt;/code&gt;に従う&lt;code&gt;UserManager&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// UserManager.kt
@UserScope
class UserManager @Inject constructor() {
  var value = 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;UserScope&lt;/code&gt;に従うので、MainActivity、UserScopedActivityには期待通り同一インスタンスが&lt;code&gt;Inject&lt;/code&gt;できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivity.kt
class MainActivity : AppCompatActivity() {

  // ok
  @Inject lateinit var userManager: UserManager

  ...
}
// UserScopedActivity.kt
class UserScopedActivity : AppCompatActivity() {

  // ok: MainActivityと同じインスタンスが注入される
  @Inject lateinit var userManager: UserManager

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、NoUserScopedActivityに&lt;code&gt;Inject&lt;/code&gt;しようとするとコンパイルエラーになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// NoUserScopedActivity.kt
class NoUserScopedActivity : AppCompatActivity() {

  //  下のコメントアウトを取るとコンパイルエラー
  //  @Inject lateinit var userManager: UserManager
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NoUserScopedActivityを&lt;code&gt;UserScope&lt;/code&gt;に従う形で定義してないためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MainActivity、UserScopedActivityはUserScopeに従い、インスタンスを共通で使いたい&lt;/li&gt;
&lt;li&gt;NoUserScopedActivityはUserScopeに従わない、コンパイルエラーにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が達成できました。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;そもそも、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;定義時に、&lt;code&gt;UserScope&lt;/code&gt;スコープを付与してあげればいいんじゃないかと思うかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// MainActivityModule.kt
@Module
interface MainActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeMainActivity(): MainActivity
}

// UserScopedActivityModule.kt
@Module
interface UserScopedActivityModule {
  @UserScope
  @ContributesAndroidInjector
  fun contributeUserScopedActivity(): UserScopedActivity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このやり方だと、今回のケースには不都合です。&lt;/p&gt;

&lt;p&gt;MainActivity、UserScopedActivityは&lt;code&gt;UserScope&lt;/code&gt;に従うのでコンパイルは通ります。
しかし、MainActivity、UserScopedActivityで同一インスタンスを使うことは出来ません。&lt;/p&gt;

&lt;p&gt;何故かと言うと、&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;はSubcomponentを作るシンタックスシュガーのようなものですが、
&lt;code&gt;MainActivityModule&lt;/code&gt;と&lt;code&gt;UserScopedActivityModule&lt;/code&gt;はそれぞれ独立したSubcomponentを作るので、独立したComponent間で同一インスタンスを使うことが出来ないためです。&lt;/p&gt;

&lt;p&gt;今回のように、&lt;code&gt;UserSubcomponent&lt;/code&gt;を定義して、そのComponentをベースに所属させる必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;特定のActivityのみで共通のインスタンスを使いたいときは、結構めんどう

&lt;ul&gt;
&lt;li&gt;冗長な気がするので、もっといい方法があったら教えてください😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContributesAndroidInjector&lt;/code&gt;がどういう動作をするのかを知っておくと、いざというときに便利&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-example/DaggerScopeExample&#34;&gt;こちら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>

&lt;p&gt;Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。
ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。&lt;/p&gt;

&lt;p&gt;このライブラリの機能に、&lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#Safe-args&#34;&gt;safeargs&lt;/a&gt;というものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。&lt;/p&gt;

&lt;h2 id=&#34;safeargsを使ってみる&#34;&gt;safeargsを使ってみる&lt;/h2&gt;

&lt;p&gt;一般的にFragmentに適当な値を渡すときは&lt;code&gt;Bundle&lt;/code&gt;を通して渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
val bundle = Bundle()
bundle.putInt(&amp;quot;step&amp;quot;, 10)

// 呼び出され側
val step = arguments?.getInt(&amp;quot;step&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&lt;code&gt;&amp;quot;step2&amp;quot;&lt;/code&gt;にしてしまうと、ランタイムエラーになります。&lt;/p&gt;

&lt;p&gt;これを解決にするためにNavigationではsafe argsという機能を提供しています。
これは、DataBindingのように、クラスを生成することでtypesafeを実現します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
            xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
            xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt;
  &amp;lt;fragment
      android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot;
      android:label=&amp;quot;Hoge&amp;quot;&amp;gt;

    &amp;lt;argument
        android:name=&amp;quot;step&amp;quot;
        app:type=&amp;quot;integer&amp;quot;
        android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt;
  &amp;lt;/fragment&amp;gt;
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とnavigationを記述すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HogeFragmentArgs {
  private int step = 1;

  private HogeFragmentArgs() {
  }

  public static HogeFragmentArgs fromBundle(Bundle bundle) {
    HogeFragmentArgs result = new HogeFragmentArgs();
    if (bundle.containsKey(&amp;quot;step&amp;quot;)) {
      result.step = bundle.getInt(&amp;quot;step&amp;quot;);
    }
    return result;
  }

  public int getStep() {
    return step;
  }

  public Bundle toBundle() {
    Bundle __outBundle = new Bundle();
    __outBundle.putInt(&amp;quot;step&amp;quot;, this.step);
    return __outBundle;
  }

  public static class Builder {
    private int step = 1;

    public Builder(HogeFragmentArgs original) {
      this.step = original.step;
    }

    public Builder() {
    }

    public HogeFragmentArgs build() {
      HogeFragmentArgs result = new HogeFragmentArgs();
      result.step = this.step;
      return result;
    }

    public Builder setStep(int step) {
      this.step = step;
      return this;
    }

    public int getStep() {
      return step;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のクラスが生成されます。これを使うことでtypesafeを実現出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 呼び出し側
HogeFragmentArgs.Builder()
    .setStep(10)
    .build()
    .toBunble()

// 呼び出され側
val args = HogeFragmentArgs.fromBundle(arguments)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Navigationは大きいライブラリなので、とりあえずの練習でsafe argsの機能だけつまみ食いするのは、
個人的には良さそうだと思っています。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlecodelabs/android-navigation&#34;&gt;https://github.com/googlecodelabs/android-navigation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>

&lt;p&gt;LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。
適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。&lt;/p&gt;

&lt;p&gt;定義は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; {
  // skip用の初期値を入れておく
  return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null }
}

fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) {
  // 最初の値は常にskipすることで、キャッシュを無視する
  val firstIgnore = AtomicBoolean(true)
  this.observe(owner, Observer {
    if (firstIgnore.getAndSet(false)) return@Observer
    observer(it)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使う時はこんな感じで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// TestViewModel.kt
class TestViewModel: ViewModel() {
  val errorEvent = singleLiveData&amp;lt;String&amp;gt;()
}

// TestActivity.kt
testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java)
testViewModel.errorEvent.observeSingle(activity) {
  Log.d(&amp;quot;one&amp;quot;, it.toString())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メリットはサブクラスを作らずに済むところです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&#34;&gt;https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&#34;&gt;https://medium.com/@star_zero/singleliveevent-livedata-with-multi-observers-384e17c60a16&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description>

&lt;p&gt;CoroutineBindingライブラリを作ったのでその紹介です。
&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android開発でCoroutineの流れが来ていると思っていて、&lt;a href=&#34;https://github.com/JakeWharton/RxBinding&#34;&gt;RxBinding&lt;/a&gt;のような感じで、
CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;例えばclickのイベントを受け取りたいとします。
CoroutineBindingでは以下のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root)
launch(UI) {
    for (click in root.clicks()) {
       Log.d(&amp;quot;clicked&amp;quot;, click.toString())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RxBindingのように使うことが出来ます!
他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/satoshun/CoroutineBinding&#34;&gt;https://github.com/satoshun/CoroutineBinding&lt;/a&gt; 何かあればissueや、PRを貰えると嬉しいです&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>&lt;p&gt;Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。&lt;/p&gt;

&lt;p&gt;まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。
振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。&lt;/p&gt;

&lt;p&gt;型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。&lt;/p&gt;

&lt;p&gt;人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;to be continued.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description>

&lt;p&gt;ポエムです。&lt;/p&gt;

&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;

&lt;p&gt;基本的にローカルで明示的に型を宣言するのは好ましくない&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userName = dataSource.getUserName()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。&lt;/p&gt;

&lt;p&gt;Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>