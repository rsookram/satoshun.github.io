<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Tue, 30 Apr 2019 05:59:41 UTC</updated>
    
    
    <item>
      <title>Material Components: MotionSpecを使ってアニメーションをカスタマイズする</title>
      <link>https://satoshun.github.io/2019/04/fab-motion-spec/</link>
      <pubDate>Tue, 30 Apr 2019 05:59:41 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/fab-motion-spec/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/com/google/android/material/animation/MotionSpec&#34;&gt;MotionSpec&lt;/a&gt;はAndroid material componentsに定義されている1クラスになります。
MotionSpecを使うことで、次のアニメーション属性をカスタマイズすることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;startOffset&lt;/li&gt;
&lt;li&gt;duration&lt;/li&gt;
&lt;li&gt;interpolator&lt;/li&gt;
&lt;li&gt;repeatCount&lt;/li&gt;
&lt;li&gt;repeatMode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例えば、アニメーションを長くしたいときは、durationの値を長く、アニメーションの開始時間を遅らせたいなら、startOffsetの値を長くします。&lt;/p&gt;

&lt;p&gt;FloatingActionButtonを例に、実際にMotionSpecの値をいじってみます。&lt;/p&gt;

&lt;h2 id=&#34;最初にmotionspec用のanimator-xmlを定義する&#34;&gt;最初にMotionSpec用のanimator XMLを定義する&lt;/h2&gt;

&lt;p&gt;デフォルトのXMLをコピペしてきて、それをベースにカスタマイズするのが良いと思います。&lt;/p&gt;

&lt;p&gt;FloatingActionButton用のXMLはソースコードを読んでいくと、&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;と&lt;code&gt;design_fab_hide_motion_spec.xml&lt;/code&gt;で定義されていることが分かります。MotionSpecは、show/hide用の2種類があり、カスタマイズしたいときは両方とも変更する必要があります。&lt;/p&gt;

&lt;p&gt;まずはshow用のMotionSpecを変更していきます。以下がデフォルトで定義されている&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;の中身になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;!--
    Copyright 2017 The Android Open Source Project

    Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
--&amp;gt;

&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;opacity&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;scale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;iconScale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;0&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_fast_out_slow_in&amp;quot;/&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は、アニメーションを長くして、アイコンをバウンドしたいとします。
それは、durationを長くして、interpolatorに&lt;code&gt;@android:anim/bounce_interpolator&lt;/code&gt;を指定すれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;opacity&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;scale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;iconScale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでshow用のMotionSpecが完成しました。hideでも同じようにXMLを定義してあげます。&lt;/p&gt;

&lt;p&gt;次に、これをViewにセットします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fab.showMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_show_motion_spec
)
fab.hideMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_hide_motion_spec
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な、アニメーションはこんな感じになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/7iMReht6cMrOlVErQmTAHUTkcsk8GG76aQR1hwVEA_TCnOtrAgCOEoJU8SH6bhzdMcEOv6Z-pWU=w246-h437-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;p&gt;アニメーション時間が長くなり、ボヨンボヨンしていることが分かると思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MotionSpecを使えば、アニメーションの長さやinterpolatorをカスタマイズすることが出来る

&lt;ul&gt;
&lt;li&gt;まだ、MotionSpecに対応しているViewは少ないが、今後Chipなども対応予定😃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ConstraintLayout Flowの紹介</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-flow/</link>
      <pubDate>Sun, 28 Apr 2019 11:13:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/constraintlayout-flow/</guid>
      <description>

&lt;p&gt;ConstraintLayoutの2.0.0 alpha 5にFlow Virtual Layoutが導入されました🎉
Flowを使うことで、対象のViewを様々なルールで並べることができます。&lt;/p&gt;

&lt;p&gt;メリットとしては、次のようなものがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Viewの階層をフラットに保つことが出来る&lt;/li&gt;
&lt;li&gt;Flowは普通のViewのように扱う事ができる&lt;/li&gt;
&lt;li&gt;MotionLayoutと相性が良い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では、どのように書くのかを見ていきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-配置する方向を決める&#34;&gt;1. 配置する方向を決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;android:orientation&lt;/code&gt;から、horizontal or verticalを指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはorientationにhorizontalを持ちます。また、通常のViewのように各constraintsを指定し、配置することができます。&lt;/p&gt;

&lt;h3 id=&#34;2-wrapmodeを決める&#34;&gt;2. wrapModeを決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;flow_wrapMode&lt;/code&gt;で指定することができます。&lt;/p&gt;

&lt;p&gt;wrapModeでは、どのようにViewを並べるかを指定でき、3種類のmodeがあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;none

&lt;ul&gt;
&lt;li&gt;単純にsingle lineに並べる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;chain

&lt;ul&gt;
&lt;li&gt;単純に順番に配置していく。その行（列）に収まらない場合は次の行（列）に配置する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;aligned

&lt;ul&gt;
&lt;li&gt;各要素を整列するように配置していく。テーブルのようなイメージ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはchainで対象のViewを配置します。&lt;/p&gt;

&lt;h3 id=&#34;3-対象のviewを指定する&#34;&gt;3. 対象のViewを指定する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;constraint_referenced_ids&lt;/code&gt;から指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:constraint_referenced_ids=&amp;quot;title1,title2,title3&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title1&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain1&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title2&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain2&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title3&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain3&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;50sp&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、「title1、title2、title3」が対象のViewになります。また、これらのViewはhorizontalの方向に、chainで順々に配置されます。&lt;/p&gt;

&lt;h3 id=&#34;4-その他-細かい調整&#34;&gt;4. その他、細かい調整&lt;/h3&gt;

&lt;p&gt;対象のView間のマージンや、行（列）の最大数、Viewの配置場所などの細かい部分の指定ができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app:flow_horizontalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_verticalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_verticalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_verticalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalAlign = &amp;ldquo;start|end|center&amp;rdquo; (default center)&lt;/li&gt;
&lt;li&gt;app:flow_verticalAlign = &amp;ldquo;top|bottom|center|baseline” (default center)&lt;/li&gt;
&lt;li&gt;app:flow_maxElementsWrap = &amp;ldquo;integer&amp;rdquo; (default : 0, not applied)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にMotionLayoutとFlowの使いかたについて見ていきます。&lt;/p&gt;

&lt;h2 id=&#34;motionlayout&#34;&gt;MotionLayout&lt;/h2&gt;

&lt;p&gt;これは通常のMotionLayoutの使い方と一緒です。Flowの値を変更してあげればよいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;MotionScene xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:motion=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&amp;gt;

  &amp;lt;Transition
    android:id=&amp;quot;@+id/transition&amp;quot;
    motion:constraintSetEnd=&amp;quot;@+id/end&amp;quot;
    motion:constraintSetStart=&amp;quot;@+id/start&amp;quot;
    motion:duration=&amp;quot;1000&amp;quot; /&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/start&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;0dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;horizontal&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/end&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;200dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;vertical&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;
&amp;lt;/MotionScene&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのアニメーションになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/qn9Xbhr9pqrmsJEzQ2YfhzSnJS1I9HpR_s6_UrCSxoqRHQQQ32unFB3G4ls72OuMLuIclSZ89-8=w246-h437-no&#34; width=400&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ConstraintLayout alpha5になってFlowが入った。かなり便利に使えそう

&lt;ul&gt;
&lt;li&gt;いろいろ指定できるので、実際に触って動かしてみるのが良いと思います。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;betaはGoogle I/O前後に来るらしいので、正式版までもう少し😃&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/camaelon/constraintlayout-2-dot-0&#34;&gt;ConstraintLayout 2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://androidstudio.googleblog.com/2019/04/constraintlayout-200-alpha-5.html&#34;&gt;ConstraintLayout 2.0.0 alpha 5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: プロパティの変更を検知する</title>
      <link>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</link>
      <pubDate>Wed, 24 Apr 2019 02:21:47 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</guid>
      <description>

&lt;p&gt;オブジェクト自身の変更ではなく、対象のオブジェクトが持つプロパティの変更を汎用的に検知する方法の紹介です。&lt;/p&gt;

&lt;p&gt;次が、この記事で紹介したいコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 1つのプロパティの変更を検知したい
fun &amp;lt;S, A1&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(prop1: KProperty1&amp;lt;S, A1&amp;gt;): LiveData&amp;lt;A1&amp;gt; =
  this
    .map { prop1.get(it) }
    .distinctUntilChanged()

// 2つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;
): LiveData&amp;lt;Pair&amp;lt;A1, A2&amp;gt;&amp;gt; =
  this
    .map { prop1.get(it) to prop2.get(it) }
    .distinctUntilChanged()

// 3つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2, A3&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;,
  prop3: KProperty1&amp;lt;S, A3&amp;gt;
): LiveData&amp;lt;Triple&amp;lt;A1, A2, A3&amp;gt;&amp;gt; =
  this
    .map { Triple(prop1.get(it), prop2.get(it), prop3.get(it)) }
    .distinctUntilChanged()

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KProperty1はKotlinが提供しているインターフェースで、プロパティの値を取得することが出来ます。
それと、LiveData ktxに追加された&lt;code&gt;distinctUntilChanged&lt;/code&gt;を組み合わせることで、汎用的に特定のプロパティの変更を検知することが可能です。&lt;/p&gt;

&lt;p&gt;この記事ではLiveDataを使いましたが、RxJavaやCoroutineでも同じような感じで書けると思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次にサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Presenter(initializeUser: User = User(name = &amp;quot;init&amp;quot;, age = 0)) {
  val user = MutableLiveData&amp;lt;User&amp;gt;(initializeUser)

  // nameの変更を検知する
  val watchUserName = user.watch(User::name)
  // ageの変更を検知する
  val watchUserAge = user.watch(User::age)
}

--- 以下main ---

val presenter = Presenter()

// 監視
presenter.watchUserName.observe(this) {
  Log.d(&amp;quot;watchUserName&amp;quot;, it)
}
presenter.watchUserAge.observe(this) {
  Log.d(&amp;quot;watchUserAge&amp;quot;, it.toString())
}

// 適当にUserを更新
presenter.user.postValue(User(name = &amp;quot;posted1&amp;quot;, age = 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、Userのnameプロパティだけが変更されているので、&lt;code&gt;presenter.watchUserName&lt;/code&gt;に登録したObserverのみが発火します。
変更が加わったプロパティだけを無事検知することができました😃&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多くのデータを持ったオブジェクトの一部の変更のみ検知したい時に使うと便利かもしれない😋&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ConstraintLayoutのImageFilterViewって単体でも使えるんやなって</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</link>
      <pubDate>Mon, 15 Apr 2019 13:17:53 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</guid>
      <description>

&lt;p&gt;ConstraintLayout 2.0.0-alphaから&lt;code&gt;ImageFilterView&lt;/code&gt;クラスが追加されました。今まで、MotionLayoutと一緒に使うものだから、使い所限られそうだなぁ〜と思っていたのですが、単体でも使えそうだったので、その報告記事になります。&lt;/p&gt;

&lt;p&gt;この記事ではConstraintLayout 2.0.0-alpha4を使っています。&lt;/p&gt;

&lt;h2 id=&#34;角丸にする&#34;&gt;角丸にする&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;round&lt;/code&gt;属性から指定する事ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
  app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/w0ztp5sD9OXMBfDSR_hocSPM08c9eHvIQTHCSpZGbyQF7ci0lcS265HwEAPHRnvY4Q0ABX5soYO8nIB_3wSpdiDek1N2F1X1m6fkDOevgydQ5IXXyVDVMqriB_Odu-szOHdfZIJ0YCLYUEOkXNEwDc8kRgooA3eeHJMqxl3urpG4siDCaJqsnhkP4MfKH3gtqJlsw6ol7Hd27L1eyexPod5mnOz2edWIS12Ogf9yIaWkVU2or1yyoHqUlsqr8xPyChg1gNYQ1cTzwBD9u1_xewQzJyGCn4ae3jqg4CnJ-L6VmJ08KrRVA9xWGYQ14u_r6uu-dD48sLdb28XuQ0egxLC-KhjxkIKHR3cCnlz-orcZ7AeKFMHwuG74fPAXXZ4Pyry2UmYDFSTXCL0StUi7h3wbhETX8u_-e9vIePPSn-1ZTLGGaLfbJTn4Vp8gZqrU7mWjoUVx0tzNlljfc47SJCN7RfFddWlLQFrtjQc7mGCmj9GLFZcJcRrKxLzp7yAOQo4DxWAY6PMcN-LNup3v4uH8PtUW9r9I2KqbmtW8SaBb9EJOMHlGsbcFtughox_G1d7bBUpZeqTnteU3bUldjiUywQTA6lJEbH68mjpoLMWkGmGjVJN9cmszjKCvd1LYcaJq89HCmskyfCwlMtiNItgP6zFCY7M7uQcmD5d62VGnlXHDXKvsYfhHjC5WtwUmoWzIbBzwD8F3YEdfDlxL6Tq0uA=w1067-h530-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;彩度&#34;&gt;彩度&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;saturation&lt;/code&gt;属性から設定することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:saturation=&amp;quot;0.1&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/wCPl0zHaivuj-PtkvE-HrvkIgFWqBwlz5Gr614mGfxvQB4U7IsvIbMuQVI8sK1RRtgRJwctepaxU8rnOuY1MATEXZq3S3NoNqNdcU4ULpRFRYGRaFcWpWtbd70YBYB7vOkH9Qx1hEt6qkXIKn-olrNDjjro9LlxEs0SjkvtxsyjQOgf3V0hlKH_-0ip6Zy0zk_zeWMiworGc61jHd3E4NfjgdoiCR8Xjg3qtjDWLobHAPT7HGTNWBC6gv0-vkz_xHxM5FZyviTAvLkgDkkHeJh3m-YSbRBDFIZ1C4-LIqt67gABi7sgfT7w6A5r_RSNTUqkTZvRd7ZUx1LtM6SPcpDSTCs-rZFSpYKkU4suecLswHOKDLMUh1EG_K_h_mSbCZgdFEQPhvr5hP9p-EN8WMMuMdJZjpPtxi1Hw6gY0fw6iuHMHJaVb4Kbjyfi5NeJVFZnf6-WBdoieQX438Spo7weidl7HD1mVGtIbGdb30h3FDtjHUoFl6kHM3myZxWq9DN83xHlsvPOQY-7TOPWbqBOWxLy8hhbxA3Dz7qhz-x0O1O8fBrYEpDQKJprdLNhwsy1s_sH37YBP0wadBUchOGA2f0LS_bLTKLrkE2oJx2XS38yCAbfGi3QW411W_Hg6S6DDYuYsrPRTxC2bw0BmCjadyxV3AOmX=w1080-h502-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;コントラスト&#34;&gt;コントラスト&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;contrast&lt;/code&gt;属性から設定することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:contrast=&amp;quot;0.5&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/wnE8okXNQjzyLwlW0wHmGZreCJI1-BjgPT_ofryDbrDC1Zfz1qD3gTpGKPhCSKYpkPXRkkbpbBuGHccTxqgJG7ywcdpuWXfgIY71nquRVKmGT5YdoojjC18cQj3fRdiEQyXw2t-pXD-Pe-wBqsTrFJ6ZAk25RakjtTF8vrPMH6PvC8InmBGx1HaUWKkYO1x3umMz9ORGMJB0T9qZ8KFspUhMW05QlmiVQXrbqDD50OCXrP_HTG8ACwW1CL5XuMYAmgP6sH24zm48cYY3ABbxVQFyLOkPKx-dyFzQ1pqjzwOncnZZqvTHp6ykd3kzJwd6PYoyX2-3HMPtDtTjW2GJNUTo23MLZmEqTwDLEZP7ibAmcoivYw6IpSoa05AcT_aLD-fjEDtpZIGCiQDrVjxb32fBgaA6h6nqjbRClMN0ZpChFxsJOAP9zgC_SkAHBeGpAczvNfyPxOzR29-eFGf9q4p59axmdyFIls_y7h3W3vPEvZK_JYFe38avYSvru4C1HtU9CRslj2jvahdNN__ZblA7wQznj-MUnIdX5E1KfIP0vsiy1kFm7tCHLWyh5FZmf0sxxTCyQToL366hbXvgPsu-e4LTwuP3S1saYOZe2WVClG6cTiv98nqC8WxWO_FtosHZaY6Davi43S_VeO0kTsUn4NPDx4H5=w1080-h516-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;暖色-寒色&#34;&gt;暖色、寒色&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;warmth&lt;/code&gt;属性から、暖色、寒色？を設定することできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:warmth=&amp;quot;2&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/a0aHhdG12uZoHpvFU8nCsxDwlnJt-ICgmdl2QhQi8GgeEifaDtLzM-xmwI8DmyB-Vqnii-ZQ4QEAvnUxqwef5P--45HBrSIFbRTT98XcfntFmaZYeduDAdNoWCMDTVXdz97uUfYewOF4p0fnKAvUbHoqjXFTdKU0lVLyTHUyyuNma6vx1qw9LE_Kri7xqevLstb6f5gvbCWsVmNuo_J-FlW133j7PK89zd-JbwYHf4B9L1tvo80Lo2eMKLjLvNyU26xFA0f88BBJeeT-Wh6IWm1_gTnEqBQlE9xrJvGTI93VjVE8SBYXSnmUN7Q9Qm5ZpY-dZLRr9H1Bvqju8O7nNcWPWdtLBLxyirDJ1fZlOJWqqXvzw1l4vncpPBNM-WfyCaY7TIxxTOD2Czvl8G9fNFs9ZQCehmvildHx088tpkB9IgMFanB9j1IZjzoP_c0ipaw_ayBR69dNNSUWVmWp5xlPCEjNXA7xi_JfruaHxhvMmocOkNKhQVxJ39BQv3KVWFIYHmZdDxnf7ZKj6iZ56V8eyb9E3R25V0_rljkAHLEC7cEEFjs9H7h7GDFAh71zbybA7bqauWB0VjRBuHDQ2eSpwKRSJh3wqLpArzKbjOkjiP9RNwGeI-CWcyQl7HCileL11hSbLem3GINlUkTLPiVoeSnMl0yG=w1080-h510-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView
  android:id=&amp;quot;@+id/image&amp;quot;
  android:layout_width=&amp;quot;100dp&amp;quot;
  android:layout_height=&amp;quot;100dp&amp;quot;
  app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
  app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot;
  app:round=&amp;quot;0.5dp&amp;quot;
  app:warmth=&amp;quot;0.5&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/Gac2-_7RbmYctobF_eztsBTlTGVNMNHor3tJYk-awVNB0Bz9rAiTfb_jkwLMd3JuKPJZd1B8tz4UDfITyw_2rUBAM2ji0bt5FYPvm9kebLZ0I1Wujn4-Ovv51XPdQ_61BNNfnPbdIztP408lWkPpkTJlbKe7JZcrjG-Ia2RZgnUo0z77LbPO56VXFlQSR9JvN8KEzzs4n2VaE0xmA_LBQ2elyirTzYWDlWiUs__MuD0e5JoqjXxfn6HM-ORGPb--PZeCFaUKUyizAxI7Vd_C27vGwTBEFwE3ITF-bT5e1HQW2J1QwrwygWnDMUnZBaoaHGjMDmKAs-nPRmqFGCrNSKYWJs6yKEQN4CEkj_Kk4E5ldCioCZiQIK4RtsjtEuQT1_-WOE_AGSh0eSUzbIFkDG5rofk-9c_e06-S8Nba-t8r8U7h0dVNOGMmmqmU5P3gcomoZUDJVZ6HJi_Q2mVUVsMQlZA6DKSwMRlivlvTHI1KbpyGxIBPPQrfnFp7TzLdh3f3MmPWXT3e3a47UQlnOxLPH6h1ZcMPoHXf8LTQ8y2duu9xzQ1gyxvYS8_o8Rit512VGxqCdcyt1J5y5i3Suq4fq7eezfg2tdjwR64GUjZbWEbWn57KNSiZIPmrQ2GC9p1m_GYAYg38KAjRHUDNvhLrJS4lT7sA=w1080-h513-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;h2 id=&#34;クロスフェード&#34;&gt;クロスフェード&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;crossfade&lt;/code&gt;属性から設定することが出来ます。ただ、この属性はMotionLayoutと一緒に使うもので、単体では使わないと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ImageFilterView&lt;/code&gt;、単体でも結構使いどころあるかも😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger 2.22にFactoryクラスが導入されました</title>
      <link>https://satoshun.github.io/2019/04/dagger-component-factory/</link>
      <pubDate>Sun, 07 Apr 2019 06:04:22 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/dagger-component-factory/</guid>
      <description>

&lt;p&gt;Dagger 2.22からComponent.Factoryクラスが導入されました。この記事では、簡単な使い方とユースケースを見ていきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;component-factoryとは&#34;&gt;Component.Factoryとは?&lt;/h2&gt;

&lt;p&gt;実は、Component.FactoryでやれることはComponent.Builderクラスとほぼ変わりません。&lt;/p&gt;

&lt;p&gt;例えば、次のArticlePresenterインスタンスを生成する2つのコードは本質的にやっていることは同等です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Factoryを使う場合
@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Factory
  interface Factory {
    fun create(
      @BindsInstance id: Long
    ): AppComponent
  }
}

val component = DaggerAppComponent
  .factory()
  .create(50)
val presenter = component.presentere

---

// Builderを使う場合
@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Builder
  interface Builder {
    @BindsInstance fun bindId(id: Long): Builder
    fun build(): AppComponent
  }
}

val component = DaggerAppComponent
  .builder()
  .bindId(50)
  .build()
val presenter = component.presenter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのコードは、AppComponentにIntをBindsしています。渡し方、定義の仕方は違いますが、やっていることは変わりません。&lt;/p&gt;

&lt;p&gt;ただし、Factoryを使うパターンはstatelessです。
Builderはセッターメソッドを使ってフィールドの状態を変えていきますが、Factoryはcreateメソッドから必要な値を渡します。&lt;/p&gt;

&lt;h2 id=&#34;ユースケース&#34;&gt;ユースケース&lt;/h2&gt;

&lt;p&gt;次に、Factoryのユースケースを考えます。そもそもこの機能は &lt;a href=&#34;https://github.com/google/dagger/issues/935&#34;&gt;Feature request: factory method in components for assisted injection&lt;/a&gt; を解決したいモチベーションがあります。&lt;/p&gt;

&lt;p&gt;例えば、次のコードをDaggerで解決したい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ArticlePresenter {
	...
	ArticlePresenter(long articleId, ArticleService articleService) {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;longの値を後から決めたいときには、今までだと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AssistedInject&lt;/li&gt;
&lt;li&gt;AutoFactory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のどちらかを使っていました。これに、今回のdagger.Factoryが加わりました。
dagger.Factoryを使うと、このコードを解決することが出来ます！&lt;/p&gt;

&lt;p&gt;ただし、現状のdagger.Factoryだと多くのボイラープレートコードが必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component
interface AppComponent {
  val presenter: ArticlePresenter

  @Component.Factory
  interface Factory {
    fun create(
      @BindsInstance id: Long
    ): AppComponent
  }
}

val component = DaggerAppComponent
  .factory()
  .create(50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssistedInjectとAutoFactoryを使えば、ここらへんのボイラープレートコードを緩和することが出来ます。
なので、このようなパターンのコードがよく出てくるようなプロジェクトは、AssistedInject or AutoFactoryの導入を検討しても良いと思います。pure Daggerで運用したい、もしくはそこまでこのパターンが出てこないなら、dagger.Factoryを使うのが良いかと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;dagger.Factoryが導入された

&lt;ul&gt;
&lt;li&gt;ただし、AutoFactoryやAssistedInjectのほうが多機能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DaggerFactoryExample&#34;&gt;satoshun/DaggerFactoryExample&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあれば&lt;a href=&#34;https://twitter.com/stsn_jp&#34;&gt;Twitter&lt;/a&gt;などから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>DataBindingとActivityのコンストラクタ Layout Id指定を一緒に使う</title>
      <link>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</link>
      <pubDate>Thu, 04 Apr 2019 00:46:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</guid>
      <description>

&lt;p&gt;JetpackのActivityとFragmentのコンストラクタに、Layout Idが指定できるようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/activity#1.0.0-alpha06&#34;&gt;Activity Version 1.0.0-alpha06&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/fragment#1.1.0-alpha06&#34;&gt;Fragment Version 1.1.0-alpha06&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これは、次のように使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(R.layout.main_act)

class MainFragment : Fragment(R.layout.main_frag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activityの場合は、setConentViewが。Fragmentの場合はonCreateViewがそれぞれ省略することが出来ます。&lt;/p&gt;

&lt;p&gt;ここからが本題です。これをDataBindingと一緒に使うなら、次のようになるかなと思います。&lt;/p&gt;

&lt;h3 id=&#34;activityの場合&#34;&gt;Activityの場合&lt;/h3&gt;

&lt;p&gt;まずはActvityの例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 拡張関数を定義しておく
fun &amp;lt;T : ViewDataBinding&amp;gt; ComponentActivity.bindView(): T =
  DataBindingUtil.bind(getContentView())!!

private fun Activity.getContentView(): View =
  findViewById&amp;lt;ViewGroup&amp;gt;(android.R.id.content)[0]


// MainActivity.kt
class MainActivity : AppCompatActivity(R.layout.main_act) {
  private lateinit var binding: MainActBinding

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = bindView()
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、Activityの場合に限り、by lazyと組み合わせることも可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(R.layout.main_act) {
  private val binding by lazy { bindView&amp;lt;MainActBinding&amp;gt;() }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fragmentの場合&#34;&gt;Fragmentの場合&lt;/h3&gt;

&lt;p&gt;次にFragmentの例になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 拡張関数を定義しておく
fun &amp;lt;T : ViewDataBinding&amp;gt; Fragment.bindView(): T = DataBindingUtil.bind(view!!)!!


// MainFragment.kt
class MainFragment : Fragment(R.layout.main_frag) {
  private lateinit var binding: MainFragBinding

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    binding = bindView()
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlinの拡張関数でやるなら、こんな感じになると思ってます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタにLayoud Idが指定できるようになり、それを使いたいなら、DataBindingの取得の仕方が少し変わりそう

&lt;ul&gt;
&lt;li&gt;Layout Id指定は必須ではないので、必ずしも使う必要はないと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;KotlinのDelegationを使えば、もっといい感じに書けるかもしれない&lt;/li&gt;
&lt;li&gt;サンプルは&lt;a href=&#34;https://github.com/satoshun-android-example/DataBindingContentLayoutIdExample&#34;&gt;satoshun/DataBindingContentLayoutIdExample&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>OkHttp: Java to KotlinのPRを見て勉強する</title>
      <link>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</link>
      <pubDate>Sun, 24 Mar 2019 02:36:27 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</guid>
      <description>

&lt;p&gt;OkHttpがKotlin化をするというISSUEが立てられました。
&lt;a href=&#34;https://github.com/square/okhttp/issues/4723&#34;&gt;Upgrade OkHttp 3 to Kotlin and call it OkHttp 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これの是非についてはさておき。現状、いくつかのJavaコードがKotlinへと置き換わっているので、それらのレビューで気になったこと、知らなかったこと、忘れがちなことを勉強がてらまとめたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;checknotnullを使うかどうか&#34;&gt;checkNotNullを使うかどうか&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266693078&#34;&gt;could also be &lt;em&gt;code&lt;/em&gt; no preference myself&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kotlinの標準ライブラリに、&lt;a href=&#34;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html&#34;&gt;checkNotNull&lt;/a&gt;があります。
これは、値がnullなら&lt;code&gt;IllegalStateException&lt;/code&gt;例外を投げるものです。&lt;/p&gt;

&lt;p&gt;以下のコードは同じ意味を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val state = someState ?: throw IllegalStateException(&amp;quot;State must be set beforehand&amp;quot;)

val state = checkNotNull(someState) { &amp;quot;State must be set beforehand&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、&lt;code&gt;no preference myself&lt;/code&gt;と言っている通り、使うかどうかはプロジェクトで分かれそうです。
事前に使うかどうかを、決めておくと揉めなく良さそうだと思いました。&lt;/p&gt;

&lt;h2 id=&#34;命名はto-が慣用的&#34;&gt;命名はto***が慣用的&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266693257&#34;&gt;idiomatic naming would be toUrl on the Kotlin side&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OkHttpでは、HttpUrlをURLに変換するためのメソッドとして&lt;code&gt;fun url(): URL&lt;/code&gt;が定義されています。しかし、&lt;code&gt;fun toUrl(): URL&lt;/code&gt;のほうがKotlinっぽいよと指摘がありました。&lt;/p&gt;

&lt;p&gt;確かに、言われてみるとAtoBクラス変換のメソッド名は、&lt;code&gt;to***&lt;/code&gt;が多い気がします。ただし、今回は下位互換を保つために、一旦この修正は入りませんでした。&lt;/p&gt;

&lt;h2 id=&#34;constを使う&#34;&gt;constを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266695491&#34;&gt;discussion link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;constを使うと、Compile Time Constantsとなり、付けない場合に比べ効率的に動作します。ただし、プリミティブか、String型のみに有効です。&lt;/p&gt;

&lt;p&gt;より詳しくは&lt;a href=&#34;https://kotlinlang.org/docs/reference/properties.html#compile-time-constants&#34;&gt;公式ドキュメント&lt;/a&gt;で。&lt;/p&gt;

&lt;p&gt;constを付けたほうが良いことは知っていたのですが、公式ドキュメントを読んだことがなかったので勉強になりました。&lt;/p&gt;

&lt;h2 id=&#34;事前計算済みプロパティにのみ依存している場合は-事前計算済みプロパティにを使う&#34;&gt;事前計算済みプロパティにのみ依存している場合は、事前計算済みプロパティにを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266702974&#34;&gt;scheme is a val, so this can just be a precomputed property without the get()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;isHttpsプロパティは最初、get()で定義していたんですが、isHttpsで使っているschemeプロパティがvalなので、get()が取り除かれました。&lt;/p&gt;

&lt;p&gt;事前計算出来るプロパティは事前に計算しておく方針のようです。そのほうが、無駄なメソッドが定義されないので、良いという判断なのでしょうか？&lt;/p&gt;

&lt;h2 id=&#34;プロパティ-get-jvmnameはより慣用的&#34;&gt;プロパティ + get:JvmNameはより慣用的&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745#discussion_r266697339&#34;&gt;property + @getJvmName(&amp;ldquo;size&amp;rdquo;) seems more idiomatic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;単純かつ副作用がない関数はプロパティのほうがKotlinっぽいです。さらに、&lt;code&gt;@get:JvmName&lt;/code&gt;を使うことで、Javaからスムーズに使うことが出来ます、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun size(): Int = encodedNames.size

@get:JvmName(&amp;quot;size&amp;quot;)
val size get(): Int = encodedNames.size
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;valをうまく使うことが、Kotlinっぽさを出すのに大切なんだなって&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkNotNull&lt;/code&gt;は、スコープ関数と一緒で、ある程度使い方の認識を合わせないとコードの一貫性が無くなりそう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;今回の記事を書くために調べたコミット&#34;&gt;今回の記事を書くために調べたコミット&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4741&#34;&gt;Convert some basic types to Kotlin #4741&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4745&#34;&gt;HttpUrl in Kotlin #4745&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4749&#34;&gt;Kotlin Platform refactor #4749&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp/pull/4751&#34;&gt;Refactor exceptions and static classes to Kotlin #4751&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: コンストラクタ呼び出しっぽく関数やcompanion objectを使う</title>
      <link>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</link>
      <pubDate>Tue, 19 Mar 2019 12:31:05 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</guid>
      <description>

&lt;p&gt;KotlinではJavaと異なり、コンストラクタ呼び出しの時に&lt;code&gt;new&lt;/code&gt;キーワードが必要ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A
...
val a = A()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よって、次のように関数をコンストラクタのように使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Coroutine Jobの定義
@Suppress(&amp;quot;FunctionName&amp;quot;)
public fun Job(parent: Job? = null): Job = JobImpl(parent)
...
val job = Job()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、次のようにcompanion object + operator invokeを使うことも出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ref: https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter
class CoroutineCallAdapterFactory private constructor() : CallAdapter.Factory() {
  companion object {
    @JvmStatic @JvmName(&amp;quot;create&amp;quot;)
    operator fun invoke() = CoroutineCallAdapterFactory()
  }
}
...
val factory = CoroutineCallAdapterFactory()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JobImplのような実装クラスを隠したいときに便利&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>

&lt;p&gt;Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { MainService.task1() }
  val task2 = async { MainService.task2() }

  println(&amp;quot;${task1.await()}\n${task2.await()}&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asyncで包むことで、並列に処理をすることができます。&lt;/p&gt;

&lt;p&gt;次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元で&lt;code&gt;runCatching&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { runCatching { MainService.task1() } }
  val task2 = async { runCatching { MainService.task2() } }

  val result1 = task1.await()
  val result2 = task2.await()
  println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;runCatching&lt;/code&gt;を使うことで、呼び出し先で例外が起こったとしても、処理を継続することが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;また、次のように書くことは出来ません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  val task1 = async { MainService.task1() }
  val task2 = async { MainService.task2() }

  // awaitのタイミングでrunCatchingを使う
  val result1 = runCatching { task1.await() }
  val result2 = runCatching { task2.await() }
  println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デフォルトの設定だと例外は伝搬し、子が倒れたら親も倒れます。&lt;/p&gt;

&lt;p&gt;しかし、&lt;code&gt;supervisorScope&lt;/code&gt;を使うと、上記の振る舞いを防ぐことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  supervisorScope {
    val task1 = async { MainService.task1() }
    val task2 = async { MainService.task2() }

    // supervisorScopeを使っているのでこのタイミングでもおｋ
    val result1 = runCatching { task1.await() }
    val result2 = runCatching { task2.await() }
    println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;supervisorScope&lt;/code&gt;を使うと、&lt;code&gt;Deferred.await&lt;/code&gt;のタイミングで例外のハンドリングをすることが出来ます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最後にキャンセルについて考えてみます。&lt;/p&gt;

&lt;p&gt;任意の子ジョブがキャンセルされても処理を続けたいとしたら、前述のsupervisorScopeを使う必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;launch {
  supervisorScope {
    val task1 = async { MainService.task1() }
    val task2 = async { MainService.task2() }

    val result1 = runCatching { task1.await() }
    val result2 = runCatching { task2.await() }
    println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、例えばtask1がキャンセルされたとしても、他の部分の処理を継続することが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;エラー &amp;amp; キャンセル時にも処理を継続したいならsupervisorScope + runCatchingを使う&lt;/li&gt;
&lt;li&gt;エラー時のみ処理を継続したいなら、runCatchingだけで対応できる&lt;/li&gt;
&lt;li&gt;正常系のみなら、asyncで包んであげるだけで良い&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>

&lt;p&gt;Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、
どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。&lt;/p&gt;

&lt;p&gt;以下、&lt;del&gt;2019年3月10日&lt;/del&gt; 2019年3月11日の調査結果になります。
また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。&lt;/p&gt;

&lt;p&gt;Lifecycle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Lifecycleに従うCoroutineScopeの生成
val Lifecycle.coroutineScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LifecycleOwner&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// LifecycleOwnerに従うCoroutineScopeの生成
val LifecycleOwner.lifecycleScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewModel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ViewModelに従うCoroutineScopeの生成
val ViewModel.viewModelScope: CoroutineScope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WorkManager&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class CoroutineWorker(
  appContext: Context,
  params: WorkerParameters
) : ListenableWorker(appContext, params) {
  // suspendメソッドで定義された
  abstract suspend fun doWork(): Result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Room&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Dao内でsuspendメソッドが使える
@Dao
interface HogesDao {
  @Insert
  suspend fun add(hoge: Hoge)

  @Query(&amp;quot;SELECT * FROM hoge WHERE id = :id&amp;quot;)
  suspend fun get(id: String): Hoge

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lifecycle、LifecycleOwner、ViewModelはそれらのライフサイクルに従う、CoroutineScopeの生成が出来る&lt;/li&gt;
&lt;li&gt;WorkManagerのdoWorkがsuspendメソッドになった

&lt;ul&gt;
&lt;li&gt;doWorkの中で、他のsuspendメソッドがコールできる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RoomのDao内でsuspendメソッドが定義出来る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;結構対応がされていた😃😃😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;LiveDataへのサポートも入るかも

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android-review.googlesource.com/c/platform/frameworks/support/+/890736&#34;&gt;WIP corutine live data (Id0e47973) · Gerrit Code Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Lifecycleに特定のstateに入った時に実行される拡張関数群が入りそう

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android-review.googlesource.com/c/platform/frameworks/support/+/905134&#34;&gt;Lifecycle Dispatcher (Ib1211c0f) · Gerrit Code Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger2: ProvidesはKotlin extension methodと一緒に使うことが出来る</title>
      <link>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</link>
      <pubDate>Tue, 05 Mar 2019 00:10:42 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</guid>
      <description>

&lt;p&gt;Dagger2のちょっとしたtipsです。&lt;/p&gt;

&lt;p&gt;次の2つのメソッドは同じ振る舞いをします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module
class MainActivityModule {
  // 普通の書き方
  @Provides fun provideMainContractView(activity: MainActivity): MainContract.View {
    return activity
  }

  // 拡張関数を使った書き方
  @Provides fun MainActivity.provideMainContractView(): MainContract.View {
    return this
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、拡張関数はコンパイルされると次のように解釈されるためです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
   @Provides
   @NotNull
   public final MainContract.View provideMainContractView(@NotNull MainActivity $receiver) {
      Intrinsics.checkParameterIsNotNull($receiver, &amp;quot;receiver$0&amp;quot;);
      return (MainContract.View)$receiver;
   }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拡張関数として定義したMainActivityは&lt;code&gt;$receiver&lt;/code&gt;となり、引数に入っていることが分かります。拡張関数は上記のように解釈されるため、&lt;code&gt;@Provides&lt;/code&gt;と組み合わせて使うことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;多分、使い所ないと思います😃😃😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>

&lt;p&gt;RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。&lt;/p&gt;

&lt;h2 id=&#34;issueの内容&#34;&gt;Issueの内容&lt;/h2&gt;

&lt;p&gt;実際のIssueは &lt;a href=&#34;https://github.com/ReactiveX/RxAndroid/issues/441&#34;&gt;HandlerScheduler.scheduleDirect supports async option?&lt;/a&gt; になります。&lt;/p&gt;

&lt;p&gt;Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これは&lt;code&gt;Worker.schedule&lt;/code&gt;のスケジュールからのみのサポートでした。RxJavaでは&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;でもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。&lt;/p&gt;

&lt;h2 id=&#34;そもそもこの問題に気づいたきっかけ&#34;&gt;そもそもこの問題に気づいたきっかけ&lt;/h2&gt;

&lt;p&gt;RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。&lt;/p&gt;

&lt;h2 id=&#34;調べ方&#34;&gt;調べ方&lt;/h2&gt;

&lt;p&gt;クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。&lt;/p&gt;

&lt;p&gt;結果、&lt;code&gt;Observable.observeOn&lt;/code&gt;では&lt;code&gt;Worker.schedule&lt;/code&gt;メソッドでタスクのスケジューリングをし、&lt;code&gt;Maybe.observeOn&lt;/code&gt;では&lt;code&gt;Scheduler.scheduleDirect&lt;/code&gt;メソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。&lt;/p&gt;

&lt;h2 id=&#34;その他-感想&#34;&gt;その他・感想&lt;/h2&gt;

&lt;h3 id=&#34;jakeさんとzacさんにレビューをしてもらった&#34;&gt;JakeさんとZacさんにレビューをしてもらった&lt;/h3&gt;

&lt;p&gt;二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>

&lt;p&gt;Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。
まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、&lt;code&gt;AndroidJUnit4&lt;/code&gt;ランナーが使えるなど、かなりの部分が共通化出来ます。&lt;/p&gt;

&lt;p&gt;この記事では、ユニットテストで&lt;code&gt;Activity.onActivityResult&lt;/code&gt;のテストをどこまでandroid testのように書けるかを検証します。&lt;/p&gt;

&lt;h2 id=&#34;テスト対象コード&#34;&gt;テスト対象コード&lt;/h2&gt;

&lt;p&gt;まず最初に、テスト対象コードは次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {
  ...
  override fun onCreate(savedInstanceState: Bundle?) {
    ...

    button.setOnClickListener {
      startActivityForResult(
        Intent(this, Sub2Activity::class.java).apply {
          putExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;)
        },
        1
      )
    }
  }

  override fun onActivityResult(
    requestCode: Int,
    resultCode: Int,
    data: Intent?
  ) {
    super.onActivityResult(requestCode, resultCode, data)
    if (requestCode == 1) {
      if (resultCode == Activity.RESULT_OK) {
        val value = data!!.getIntExtra(&amp;quot;test&amp;quot;, -1)
        button.text = value.toString()
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Sub2Activity : AppCompatActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)

    button.setOnClickListener {
      val intent = Intent()
      intent.putExtra(&amp;quot;test&amp;quot;, 10)
      setResult(Activity.RESULT_OK, intent)
      finish()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはMainActivityで&lt;code&gt;startActivityForResult&lt;/code&gt;がコールされ、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;で値をセットし、MainActivityの&lt;code&gt;onActivityResult&lt;/code&gt;で結果を受け取るサンプルコードになります。&lt;/p&gt;

&lt;p&gt;では、テストを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;テストコード&#34;&gt;テストコード&lt;/h2&gt;

&lt;p&gt;以下が、今回書いたテストコードになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(AndroidJUnit4::class)
internal class MainActivityTest {
  @get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)

  @Test
  fun onActivityResultTest() {
    val expectCode = 10

    // assertion setResult
    val scenario = ActivityScenario.launch(Sub2Activity::class.java)
    scenario.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
    }

    // assertion resultCode
    val result = scenario.result
    assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

    // assertion intent params
    val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
    bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)

    scenario.close()

    Intents
      .intending(
        IntentMatchers.hasComponent(
          ComponentName(
            ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
            Sub2Activity::class.java
          )
        )
      )
      .respondWith(result)

    val main = ActivityScenario.launch(MainActivity::class.java)
    main.onActivity {
      it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

      // assertion intent for startActivity(ForResult)
      val name = ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
      Intents.intended(IntentMatchers.hasComponent(name))
      Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

      // assertion onActivityResult behaves
      Espresso
        .onView(ViewMatchers.withId(R.id.button))
        .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上から順番に重要な部分を説明していきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@get:Rule val intentsTestRule = IntentsTestRule(MainActivity::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、Espresso-Intentsを使うときに必要なルールです。&lt;code&gt;Intens.intended&lt;/code&gt;、&lt;code&gt;intending&lt;/code&gt;を使うために必要なルールになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val scenario = ActivityScenario.launch(Sub2Activity::class.java)
scenario.onActivity {
    it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioはActivityを起動するためのクラスです。これはSub2Activityを起動して、ボタンをクリックするという意味になります。
ボタンがクリックされると、Sub2Activityで&lt;code&gt;setResult&lt;/code&gt;が発火するようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val result = scenario.result
assertThat(result.resultCode).isEqualTo(Activity.RESULT_OK)

val bundleSubject = IntentSubject.assertThat(result.resultData).extras()
bundleSubject.integer(&amp;quot;test&amp;quot;).isEqualTo(expectCode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ActivityScenarioでは、ActivityResultクラスから結果を取得することが出来ます。このクラスにはresultCodeと、resultDataがセットされており、それらの値をTruthを使いチェックします。この場合、&lt;code&gt;setResult&lt;/code&gt;で、resultcodeに&lt;code&gt;Activity.RESULT_OK&lt;/code&gt;が、resultdataにはキー名&lt;code&gt;test&lt;/code&gt;、値10がセットされていることを確認してします。&lt;/p&gt;

&lt;p&gt;ここまでで、Sub2ActivityのsetResultで正しい値をセットしていることがテスト出来ます。&lt;/p&gt;

&lt;p&gt;では次に、MainActivityで上記の値を受け取れることをテストしていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Intents
  .intending(
    IntentMatchers.hasComponent(
      ComponentName(
        ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
        Sub2Activity::class.java
      )
    )
  )
  .respondWith(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Intents.intending&lt;/code&gt;はマッチしたIntentが発行されたときに、onActivityResultに結果を返すAPIになります。
MainActivityのonActivityResultに、先ほどのSub2Activityの結果を渡すという意味になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val main = ActivityScenario.launch(MainActivity::class.java)
main.onActivity {
  it.findViewById&amp;lt;View&amp;gt;(R.id.button).performClick()

  val name = ComponentName(
    ApplicationProvider.getApplicationContext&amp;lt;Application&amp;gt;(),
    Sub2Activity::class.java
  )
  Intents.intended(IntentMatchers.hasComponent(name))
  Intents.intended(IntentMatchers.hasExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;))

  Espresso
    .onView(ViewMatchers.withId(R.id.button))
    .check(ViewAssertions.matches(ViewMatchers.withText(expectCode.toString())))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは、クリックイベントを発火し、&lt;code&gt;startActivityForResult&lt;/code&gt;をコールします。渡したIntentを&lt;code&gt;Intents.intended&lt;/code&gt;で正しいことを確認します。最後に、Espressoを使って、&lt;code&gt;onActivityResult&lt;/code&gt;の結果を正しく反映されているかを確認します。&lt;/p&gt;

&lt;p&gt;これで、テスト完了です😃
2つのActivityに関連するonActivityResultのテストが無事に出来ました！！&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;Espressoにはご存知、clickをするためのAPIがあるのですが、うまく動きませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// not working!!
Espresso
  .onView(ViewMatchers.withId(R.id.button))
  .perform(ViewActions.click())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;調べたんですが、原因がわかりませんでした😂分かり次第追記します。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上記のテストくらいなら、ユニットテストで書ける。すごい😃

&lt;ul&gt;
&lt;li&gt;onActivityResultみたいな、クラス間のつながりが弱い部分は意図せず壊れやすいので、テストを書いておくと安心かも😋&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に用いたサンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/Tests/blob/master/app/src/test/java/com/github/satoshun/example/tests/lifecycle/MainActivityTest.kt&#34;&gt;satoshun-android-example/Tests&lt;/a&gt;にあります。&lt;/p&gt;

&lt;p&gt;もっと良い書き方を知っているよと言う人は教えて頂けるととても嬉しいです😃😃😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>

&lt;p&gt;マルチモジュール遷移方法Part2です。&lt;a href=&#34;https://satoshun.github.io/2018/12/multi-module_transition_part1/&#34;&gt;Part1&lt;/a&gt;はここになります😌&lt;/p&gt;

&lt;p&gt;Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。&lt;/p&gt;

&lt;p&gt;また、今回の検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;モジュール構成について&#34;&gt;モジュール構成について&lt;/h2&gt;

&lt;p&gt;細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/img/SoWkIImgAStDuU8goIp9ILLutBpeSTEEnyrB7pVlUToy-kdipLnS1Od9sOdfgGfAYGK5yMcfYIMbHQbA2jLS2WhHG95O45sKNrgIMXJBLOkakhWqoH1DEKWe5iQ8nw7925EJ4KoJ4RAcvFpSWloyrBmIi3lGN1wha5Yi01H6LWNHYqqXH0PPxUF6kOyRrptPFGqi3t8likpBnktFb-z-tBJaSVFcnqtxmIPDVToq7CHesWdN4a-4kKQacmiB1Iuka2KAkdOebe4KGCKG2e4XeQ2Rab-U1rCC3MDq2IEi4Z1Jk20Cg7WDghrOv13sEwJcfG2J6G00&#34; width=600&gt;&lt;/p&gt;

&lt;p&gt;各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。&lt;/p&gt;

&lt;p&gt;このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。&lt;/p&gt;

&lt;p&gt;では、実装に入っていきます。今回はDagger2を使って実装をします。&lt;/p&gt;

&lt;h2 id=&#34;featureモジュール側の遷移用インターフェースの定義&#34;&gt;featureモジュール側の遷移用インターフェースの定義&lt;/h2&gt;

&lt;p&gt;前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。&lt;/p&gt;

&lt;p&gt;main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainModuleRouter {
  // sub1画面へ移動する
  fun routeToSub1()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mainモジュール用のインターフェースなので、&lt;code&gt;MainModuleRouter&lt;/code&gt;という名前にし、sub1画面へ遷移するためのメソッドを定義しています。&lt;/p&gt;

&lt;p&gt;そしてこのインターフェースを、MainFragmentで使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment : Fragment() {
  @Inject lateinit var moduleRouter: MainModuleRouter

  ...

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    view.findViewById&amp;lt;View&amp;gt;(R.id.route).setOnClickListener {
      moduleRouter.routeToSub1()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでfeatureモジュールでの遷移用インターフェースの定義は完了です。&lt;/p&gt;

&lt;p&gt;次にこのインターフェースの実装をします。&lt;/p&gt;

&lt;h2 id=&#34;routerモジュール側の遷移用インターフェースの実装&#34;&gt;routerモジュール側の遷移用インターフェースの実装&lt;/h2&gt;

&lt;p&gt;今回は、遷移用インタフェースの実装をrouterモジュールで行います。まずは、Navigation Componentを用いて、Graphを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;
  android:id=&amp;quot;@+id/nav_graph&amp;quot;
  app:startDestination=&amp;quot;@id/nav_main_frag&amp;quot;&amp;gt;

  &amp;lt;fragment
    android:id=&amp;quot;@+id/nav_main_frag&amp;quot;
    android:name=&amp;quot;com.github.satoshun.example.feature.main.MainFragment&amp;quot;&amp;gt;

    &amp;lt;action
      android:id=&amp;quot;@+id/main_to_sub1&amp;quot;
      app:destination=&amp;quot;@id/nav_sub1_frag&amp;quot; /&amp;gt;
  &amp;lt;/fragment&amp;gt;

  ...
&amp;lt;/navigation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、これを用いて遷移用インターフェースを実装します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainModuleRouterImpl @Inject constructor(
  private val controller: NavController
) : MainModuleRouter {
  override fun routeToSub1() {
    // NavComponentで自動生成されるコードを用いて遷移
    controller.navigate(MainFragmentDirections.mainToSub1())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実装は完了です。Navigation Componentを使っているため、実装はかなり楽です。&lt;/p&gt;

&lt;p&gt;あとはDaggerで配るだけです。Daggerで配る部分はサンプルコードを見ていただけたらと思います。サンプルでは、Dagger Androidを用いています。&lt;/p&gt;

&lt;h2 id=&#34;メモ&#34;&gt;メモ&lt;/h2&gt;

&lt;h3 id=&#34;routerモジュールをわざわざ作る必要はないかも&#34;&gt;routerモジュールをわざわざ作る必要はないかも&lt;/h3&gt;

&lt;p&gt;構成図を見てほしいのですが、実はrouterモジュールをわざわざ作る必要はなく、appモジュールに含めても良いです。routerモジュールを作るのがめんどう、もしくは意味がないと感じるなら、appモジュールで実装しても良いと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Navigation Componentでモジュール間の遷移を宣言的にXMLで書けるのは見やすくて非常に良いと思いました。

&lt;ul&gt;
&lt;li&gt;またNavigation Componentはactivityの記述もできるので、既存アプリへの導入も比較的しやすいと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;app/routerでは各featureモジュールへの依存を持つことができるので、クラスへの参照を持ちながら、navgationのgraphを作ることができる

&lt;ul&gt;
&lt;li&gt;navigation graphはActivity/Fragmentへの参照を持たなくても作ることが可能だが、持ったほうがLintなどの兼ね合いで安全&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/MultiModuleNavigationComponentExample&#34;&gt;satoshun/MultiModuleNavigationComponentExample&lt;/a&gt;にあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次は最終章になる予定です。DFMの遷移について書きます😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>

&lt;p&gt;マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）&lt;/p&gt;

&lt;p&gt;例えば、以下のモジュール構成を考えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0mYXQcxO-RfvcY4rbSMcI8QPI8nnAZRYuk81cA-Ycv9VdwTf1TAC90DKufEQb0Bq40000&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。&lt;/p&gt;

&lt;p&gt;そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLusJ3boOwrBnlxdg_evk9ApiyjoCzBpIjHY7xSkEznum8OkVnnO_VZnfR4WeB7pOiUD-rutBpqSVEUnyshOnKIYnM0miXQGGPEcunDOMPnQHAA9KrR7pTFCyIc5AZI45Ef4GwbHbnSN41NAEYcv9VdwTf1BE82aN0Xi87e8a1z3gbvAS000G00&#34; width=400&gt;&lt;/p&gt;

&lt;p&gt;途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。&lt;/p&gt;

&lt;p&gt;ただし、いくつか条件があります。&lt;/p&gt;

&lt;h3 id=&#34;1-中間モジュールで公開可能なものに限る&#34;&gt;1. 中間モジュールで公開可能なものに限る&lt;/h3&gt;

&lt;p&gt;例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。
これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。&lt;/p&gt;

&lt;p&gt;中間モジュールのコードイメージとしては以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun createUserFragment(userName: String, age: Int): Fragment {
  return UserFragment.createFragment(userName, age)
}

fun createUserIntent(context: Context): Intent {
  return Intent(context, UserActivity::class.java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserActivity、UserFragmentが公開されていないことが分かります。Androidのいわゆるfeatureモジュールでは、Activity、Fragmentを公開する場合が多いと思うので、その場合には有効に使うことができます。&lt;/p&gt;

&lt;h3 id=&#34;2-implementationで依存を定義する&#34;&gt;2. implementationで依存を定義する&lt;/h3&gt;

&lt;p&gt;apiを使うと、依存が推移するため再ビルドが行われてしまうためです。implementationで依存を記述する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;3-dagger2使ってると多分無理&#34;&gt;3. Dagger2使ってると多分無理&lt;/h3&gt;

&lt;p&gt;Dagger2では、解決する依存をAppComponentで知っている必要があります。上記の構成だと、appでAppComponentを持つことになるので、appからsub1、sub2が見えていないと最終的にDagger2で解決できません。なので、中間モジュールで、appからsubの依存が見えなくなるこのパターンは使えません。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://github.com/google/dagger/issues/970&#34;&gt;Dagger/#970&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;やりすぎ感はある

&lt;ul&gt;
&lt;li&gt;ただでさえ複雑な、モジュール構成がさらに煩雑になりそう。ただし、最終的には消えるので、差分ビルドの恩恵を受けるためのステップだとすれば許せるかも?&lt;/li&gt;
&lt;li&gt;Dagger2を使っていると推移的依存が必要になり、使えない、もしくは工夫が必要になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルは&lt;a href=&#34;https://github.com/satoshun-android-example/ApplicationModulesSpeedUpExample&#34;&gt;satoshun/ApplicationModulesSpeedUpExample&lt;/a&gt;にあります

&lt;ul&gt;
&lt;li&gt;サブモジュールを変更したときのビルドは爆速でした😊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Daggerの部分のいい解決方法を知っている人がいたら、教えて頂けると幸いです😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>