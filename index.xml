<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Sun, 20 Jan 2019 04:23:43 UTC</updated>
    
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。&lt;/p&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;https://jakewharton.com/r8-optimization-staticization/&#34;&gt;R8 Optimization: Staticization&lt;/a&gt;にとても影響を受けています。&lt;/p&gt;

&lt;h2 id=&#34;companion-object&#34;&gt;Companion object&lt;/h2&gt;

&lt;p&gt;例えば、次のコードがあるとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CompanionTest {
    companion object {
        fun show(i: Int) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを最適化なしで変換すると次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class CompanionTest {
    public static final Companion Companion = new Companion();

    public static final class Companion {
        private Companion() {
        }

        public final void show(int i) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。&lt;/p&gt;

&lt;p&gt;そこでR8による最適化を行うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class CompanionTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;無駄な内部クラス（enclosing class）が消えて、staticメソッドに変換されているのが分かります。このshowメソッドはわざわざインスタンスメソッドにする必要がないため、このような最適化が行われます。&lt;/p&gt;

&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;

&lt;p&gt;objectも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object ObjectTest {
    fun show(i: Int) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化なしだと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class ObjectTest {
    public static final ObjectTest INSTANCE = new ObjectTest();

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INSTANCEフィールドが生成されていることが分かります。&lt;/p&gt;

&lt;p&gt;次にR8による最適化を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class ObjectTest {
    public static final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Companion objectと同様に冗長なインスタンス生成が消えています。
Proguardの場合、インスタンス生成は消えないので、R8の一歩進んだ最適化といえます。（もしかしたらProguardの設定次第でインスタンス生成をしないように出来るかもしれないです。）&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>

&lt;p&gt;コードの最適化の話です。この記事ではClass Mergingについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;class-merging&#34;&gt;Class Merging?&lt;/h2&gt;

&lt;p&gt;その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。
Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。&lt;/p&gt;

&lt;p&gt;まずは縦方向のClass Mergingについて説明します。&lt;/p&gt;

&lt;h3 id=&#34;縦方向&#34;&gt;縦方向?&lt;/h3&gt;

&lt;p&gt;縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。&lt;/p&gt;

&lt;p&gt;例えば、次の実装は最適化によって1つにまとめられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface IVertical {
    fun show(i: Int)
}

class Vertical(
    private val a: Int
) : IVertical {
    override fun show(i: Int) {
        println(&amp;quot;start called $i $a&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class Vertical {
    ...

    public final void show(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IVertical&lt;/code&gt;インターフェースが見事に消されていることが分かります。&lt;/p&gt;

&lt;p&gt;また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r8.googlesource.com/r8/+/master/src/main/java/com/android/tools/r8/shaking/VerticalClassMerger.java&#34;&gt;R8: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facebook/proguard/blob/master/src/proguard/optimize/peephole/VerticalClassMerger.java&#34;&gt;Proguard: Vertical Merger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に横方向のマージを紹介します。&lt;/p&gt;

&lt;h3 id=&#34;横方向&#34;&gt;横方向?&lt;/h3&gt;

&lt;p&gt;Staticメソッドのみを持つクラスを1つにまとめるなどの最適化を行います。&lt;/p&gt;

&lt;p&gt;例えばKotlinの複数のファイルで定義されたトップレベル関数を1つのクラスにまとめてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// ShowExt.kt
fun Int.show1(i: Int) {
    ...
}

// ShowExt2.kt
fun Int.show2(i: Int) {
    ...
}

--&amp;gt; Proguard/R8による最適化後 --&amp;gt;

```java
public class ShowExt2Kt {
    public static final void show1(int i) {
        ...
    }
}

    public static final void show2(int i) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1つのクラスにまとめられていることが分かります。&lt;/p&gt;

&lt;p&gt;また、実際のAndroidプロジェクトで確認したところ、確かに拡張関数が他のクラスにマージされていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fuga.kt
fun Int.show1() {
    ...
}

// mapping.txtの内容
android.support.constraint.solver.widgets.Analyzer -&amp;gt; a.b.b.a.a.a:
    ...
    void com.github.satoshun.example.FugaKt.show1(int) -&amp;gt; d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこのクラスに移動したかは分からないので、今後の宿題とします。申し訳ありません😫&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;横方向のマージについては内容に自信がないので、もし間違っていたり、補足があれば教えて頂けるととても嬉しいです🙏&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://medium.com/@keyboardsurfer/dependency-injection-in-a-multi-module-project-1a09511c14b7&#34;&gt;Dependency injection in a multi module project&lt;/a&gt;を見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。&lt;/p&gt;

&lt;p&gt;結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。&lt;/p&gt;

&lt;p&gt;また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。&lt;/p&gt;

&lt;p&gt;検証に用いたコードは&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;satoshun-android-example/DynamicFeatureDaggerExample&lt;/a&gt;にあります😊&lt;/p&gt;

&lt;h2 id=&#34;前提知識&#34;&gt;前提知識&lt;/h2&gt;

&lt;p&gt;通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。
ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLukc_oixbB7pUkUx9lxjErCvxEtip5bPoVMv2VbvfNeX2TM53mk7dHuwOTZvkNFcxUyxXvTQn2Oh42K1XPrUEchO-RfnbYKrbSccI8gTG8Xr8ZBYukeDaAkYdvvNcwTX3TQ090DGwfUIb0Fm00&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLmgSnBpCrCLd1BJImfBKfztBZkoRwvJzVEU3fxCnTNSdvkGNvUQbw9GdHYGS7ZvaMFctOyRbxwk7dFu-RLiGg9nGf0OMHLZvksFcwUPeXDPN5faY6cKYCSIesukBX0EXHqK_BBytJjm1Q1n544k1nIyrA0dW40&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。&lt;/p&gt;

&lt;p&gt;ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。
実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。&lt;/p&gt;

&lt;p&gt;では、実装を始めます。&lt;/p&gt;

&lt;p&gt;最初に、SubActivityをDaggerApplicationのように振る舞わさせるために&lt;code&gt;ModuleRootActivity&lt;/code&gt;クラスを定義します。
それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class ModuleRootActivity : AppCompatActivity(),
  HasModuleInjector {
  @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt;

  private lateinit var injector: ModuleActivityInjector

  override fun onCreate(savedInstanceState: Bundle?) {
    injector = moduleComponent.moduleInjector
    injector.activity.inject(this)
    super.onCreate(savedInstanceState)
  }

  protected abstract val moduleComponent: ModuleActivityComponent

  override fun supportFragmentInjector(): AndroidInjector&amp;lt;Fragment&amp;gt; =
    fragmentInjector
}

class ModuleActivityInjector @Inject constructor(
  internal val activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt;
)

interface ModuleActivityComponent {
  val moduleInjector: ModuleActivityInjector
}

interface HasModuleInjector : HasSupportFragmentInjector

abstract class ModuleChildFragment : Fragment() {
  override fun onAttach(context: Context) {
    AndroidSupportInjection.inject(this)
    super.onAttach(context)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、このbaseクラス群を使い、SubActivityとDagger Componentを実装をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ModuleScope
@Component(
  dependencies = [CoreComponent::class], // 共通で使うComponent
  modules = [
    AndroidSupportInjectionModule::class,
    SubBuilder::class
  ]
)
internal interface SubComponent : ModuleActivityComponent {
  @Component.Builder
  interface Builder {
    fun appComponent(module: CoreComponent): Builder
    fun build(): Sub1Component
  }
}

@Module(
  includes = [SubActivityModule::class]
)
interface SubBuilder

@Module
internal interface SubActivityModule {
  @ContributesAndroidInjector(modules = [SubFragmentsModule::class])
  fun contributeSubActivity(): SubActivity
}

@Module
internal interface SubFragmentsModule {
  @ContributesAndroidInjector
  fun contributeSubFragment(): SubFragment
}

class SubActivity : ModuleRootActivity() {
  @Inject lateinit var ...

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.sub_act)
    ...
  }

  override val moduleComponent: ModuleActivityComponent
    get() = DaggerSubComponent
      .builder()
      .appComponent(App.coreComponent())
      .build()
}

class SubFragment : ModuleChildFragment() {
  @Inject lateinit var ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ModuleRootActivity&lt;/code&gt;で、Featureモジュール内で使うComponentを保持し、各Fragmentで保持したComponentを参照することで、ActivityをDaggerApplicationのように振る舞わさせる事ができます。ComponentやModuleの定義は従来のDagger Androidの書き方とほぼ一緒です。&lt;/p&gt;

&lt;p&gt;これで、Dynamic Featureモジュール + Dagger Androidを実現することが出来ます😃&lt;/p&gt;

&lt;p&gt;細かい部分はサンプルを見ていただけたらと思います。&lt;a href=&#34;https://github.com/satoshun-android-example/DynamicFeatureDaggerExample&#34;&gt;DynamicFeatureDaggerExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;メモ1-1つのfeature-module内で複数activityがある場合&#34;&gt;メモ1: 1つのFeature Module内で複数Activityがある場合&lt;/h2&gt;

&lt;p&gt;このパターンは考慮出来ていないです😂
おそらく、頑張ってApplicationクラス内でstaticで保持するか、もしくは、CoreComponentでScopedで管理するのが良いと思っています。&lt;/p&gt;

&lt;h2 id=&#34;メモ2-configuration-change対応&#34;&gt;メモ2: Configuration Change対応&lt;/h2&gt;

&lt;p&gt;Feature Root ComponentはActivityではなく、AACのViewModelで保持したほうが良いかも知れないです。&lt;/p&gt;

&lt;h2 id=&#34;メモ3-そもそもdagger-androidを使う必要あるのか&#34;&gt;メモ3: そもそもDagger Androidを使う必要あるのか?&lt;/h2&gt;

&lt;p&gt;Scopeをガンガン使いたい時、すでにDagger Androidを導入している場合は使ってもいいかも。
ただPlaidのように、Dagger Androidを使わないほうがコードが複雑にならなそうなので、使わないほうが基本良いと思います。（今後心変わりする可能性は大いにあります）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、Happy Dagger Life 😊😊😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>dexdumpメモ</title>
      <link>https://satoshun.github.io/2019/01/reading_dexdump_result/</link>
      <pubDate>Sat, 05 Jan 2019 02:15:50 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/01/reading_dexdump_result/</guid>
      <description>&lt;p&gt;Android build-toolsにはdexdumpというdexファイルを逆アセンブルするツールがあります。
逆アセンブルしたファイルを読みたかったのでそれのメモです。&lt;/p&gt;

&lt;p&gt;内容はまとまっていません。自分用のメモレベルの記事になります。&lt;/p&gt;

&lt;p&gt;dexファイルをコマンドから作るにはjavacとd8コマンドを使います。d8コマンドは &lt;a href=&#34;https://r8.googlesource.com/r8&#34;&gt;https://r8.googlesource.com/r8&lt;/a&gt; の手順通りにビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javac *.java // or kotlinc *.kt
java -jar $R8_HOME/build/libs/d8.jar --lib $ANDROID_HOME/platforms/android-28/android.jar --release *.class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;d8コマンドで出来たdexファイルをdexdumpで逆アセンブルします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば次のJavaコードを逆アセンブルしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Test {
    public void main() {
        show(1, 10.0);
        String[] array = {&amp;quot;&amp;quot;};
        toggle(array);
        fade();
        drag();
        hide();
        click();
        hover();
    }

    public String show(int a, double d) {
        System.out.println(a);
        return &amp;quot;showed&amp;quot;;
    }

    void toggle(String[] args) {
        System.out.println(&amp;quot;toggle&amp;quot;);
    }

    protected void fade() {
        System.out.println(&amp;quot;fade&amp;quot;);
    }

    final protected void drag() {
        System.out.println(&amp;quot;drag&amp;quot;);
    }

    private void hide() {
        System.out.println(&amp;quot;hide&amp;quot;);
    }

    public static void click() {
        System.out.println(&amp;quot;click&amp;quot;);
    }

    static void hover() {
        System.out.println(&amp;quot;hover&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Processing &#39;classes.dex&#39;...
Opened &#39;classes.dex&#39;, DEX version &#39;035&#39;
Class #0            -
  Class descriptor  : &#39;LTest;&#39; // クラス名Test
  Access flags      : 0x0000 () // パッケージプライベート
  Superclass        : &#39;Ljava/lang/Object;&#39; // スーパークラスがObject
  Interfaces        - // インターフェースを持たない
  Static fields     - // Staticフィールドを持たない
  Instance fields   - // インスタンスフィールドを持たない
  Direct methods    -
    #0              : (in LTest;)
      name          : &#39;&amp;lt;init&amp;gt;&#39; // コンストラクタを示す
      type          : &#39;()V&#39; // 引数なし/戻り値なし
      access        : 0x10000 (CONSTRUCTOR)
      code          -
      registers     : 1
      ins           : 1
      outs          : 1
      insns size    : 4 16-bit code units
0001e4:                                        |[0001e4] Test.&amp;lt;init&amp;gt;:()V
0001f4: 7010 0b00 0000                         |0000: invoke-direct {v0}, Ljava/lang/Object;.&amp;lt;init&amp;gt;:()V // method@000b // Objectのsuper
0001fa: 0e00                                   |0003: return-void
      catches       : (none)
      positions     :
        0x0000 line=1
      locals        :
        0x0000 - 0x0004 reg=0 this LTest;

    #1              : (in LTest;)
      name          : &#39;click&#39;
      type          : &#39;()V&#39;
      access        : 0x0009 (PUBLIC STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
0001fc:                                        |[0001fc] Test.click:()V
00020c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000210: 1a01 0f00                              |0002: const-string v1, &amp;quot;click&amp;quot; // string@000f
000214: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00021a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=35
      locals        :

    #2              : (in LTest;)
      name          : &#39;hide&#39;
      type          : &#39;()V&#39;
      access        : 0x0002 (PRIVATE)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00025c:                                        |[00025c] Test.hide:()V
00026c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000270: 1a01 1200                              |0002: const-string v1, &amp;quot;hide&amp;quot; // string@0012
000274: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00027a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=31
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #3              : (in LTest;)
      name          : &#39;hover&#39;
      type          : &#39;()V&#39;
      access        : 0x0008 (STATIC)
      code          -
      registers     : 2
      ins           : 0
      outs          : 2
      insns size    : 8 16-bit code units
00027c:                                        |[00027c] Test.hover:()V
00028c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000290: 1a01 1300                              |0002: const-string v1, &amp;quot;hover&amp;quot; // string@0013
000294: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00029a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=39
      locals        :

  Virtual methods   -
    #0              : (in LTest;)
      name          : &#39;drag&#39;
      type          : &#39;()V&#39;
      access        : 0x0014 (PROTECTED FINAL)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00021c:                                        |[00021c] Test.drag:()V
00022c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000230: 1a01 1000                              |0002: const-string v1, &amp;quot;drag&amp;quot; // string@0010
000234: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00023a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=27
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #1              : (in LTest;)
      name          : &#39;fade&#39;
      type          : &#39;()V&#39;
      access        : 0x0004 (PROTECTED)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
00023c:                                        |[00023c] Test.fade:()V
00024c: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000250: 1a01 1100                              |0002: const-string v1, &amp;quot;fade&amp;quot; // string@0011
000254: 6e20 0a00 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00025a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=23
      locals        :
        0x0000 - 0x0008 reg=2 this LTest;

    #2              : (in LTest;)
      name          : &#39;main&#39;
      type          : &#39;()V&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 1
      outs          : 4
      insns size    : 32 16-bit code units
00029c:                                        |[00029c] Test.main:()V
0002ac: 1210                                   |0000: const/4 v0, #int 1 // #1
0002ae: 1901 2440                              |0001: const-wide/high16 v1, #long 4621819117588971520 // #4024
0002b2: 6e40 0700 0321                         |0003: invoke-virtual {v3, v0, v1, v2}, LTest;.show:(ID)Ljava/lang/String; // method@0007
0002b8: 2300 0800                              |0006: new-array v0, v0, [Ljava/lang/String; // type@0008
0002bc: 1201                                   |0008: const/4 v1, #int 0 // #0
0002be: 1a02 0000                              |0009: const-string v2, &amp;quot;&amp;quot; // string@0000
0002c2: 4d02 0001                              |000b: aput-object v2, v0, v1
0002c6: 6e20 0800 0300                         |000d: invoke-virtual {v3, v0}, LTest;.toggle:([Ljava/lang/String;)V // method@0008
0002cc: 6e10 0300 0300                         |0010: invoke-virtual {v3}, LTest;.fade:()V // method@0003
0002d2: 6e10 0200 0300                         |0013: invoke-virtual {v3}, LTest;.drag:()V // method@0002
0002d8: 7010 0400 0300                         |0016: invoke-direct {v3}, LTest;.hide:()V // method@0004
0002de: 7100 0100 0000                         |0019: invoke-static {}, LTest;.click:()V // method@0001
0002e4: 7100 0500 0000                         |001c: invoke-static {}, LTest;.hover:()V // method@0005
0002ea: 0e00                                   |001f: return-void
      catches       : (none)
      positions     :
        0x0003 line=3
        0x0006 line=4
        0x000d line=5
        0x0010 line=6
        0x0013 line=7
        0x0016 line=8
        0x0019 line=9
        0x001c line=10
      locals        :
        0x0000 - 0x0020 reg=3 this LTest;

    #3              : (in LTest;)
      name          : &#39;show&#39;
      type          : &#39;(ID)Ljava/lang/String;&#39;
      access        : 0x0001 (PUBLIC)
      code          -
      registers     : 4
      ins           : 4
      outs          : 2
      insns size    : 8 16-bit code units
0001c4:                                        |[0001c4] Test.show:(ID)Ljava/lang/String;
0001d4: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
0001d8: 6e20 0900 1200                         |0002: invoke-virtual {v2, v1}, Ljava/io/PrintStream;.println:(I)V // method@0009
0001de: 1a01 1800                              |0005: const-string v1, &amp;quot;showed&amp;quot; // string@0018
0001e2: 1101                                   |0007: return-object v1
      catches       : (none)
      positions     :
        0x0000 line=14
      locals        :
        0x0000 - 0x0008 reg=0 this LTest;

    #4              : (in LTest;)
      name          : &#39;toggle&#39;
      type          : &#39;([Ljava/lang/String;)V&#39;
      access        : 0x0000 ()
      code          -
      registers     : 3
      ins           : 2
      outs          : 2
      insns size    : 8 16-bit code units
0002ec:                                        |[0002ec] Test.toggle:([Ljava/lang/String;)V
0002fc: 6202 0000                              |0000: sget-object v2, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
000300: 1a00 1900                              |0002: const-string v0, &amp;quot;toggle&amp;quot; // string@0019
000304: 6e20 0a00 0200                         |0004: invoke-virtual {v2, v0}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@000a
00030a: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=19
      locals        :
        0x0000 - 0x0008 reg=1 this LTest;

  source_file_idx   : 10 (Test.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;finalメソッドのdragがvirtualなのがなぜなのかわからない

&lt;ul&gt;
&lt;li&gt;finalはdirectメソッドなのでは?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>

&lt;p&gt;Androidのトレンドの1つにマルチモジュール構成があります。
マルチモジュールによるメリットとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビルド時間の短縮&lt;/li&gt;
&lt;li&gt;依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。&lt;/p&gt;

&lt;p&gt;この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい&lt;/li&gt;
&lt;li&gt;コード量を減らしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part1では、遷移専用のモジュールを作る方法を考えてみます。&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;遷移専用のモジュールを作る&#34;&gt;遷移専用のモジュールを作る&lt;/h2&gt;

&lt;p&gt;まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。&lt;/p&gt;

&lt;p&gt;例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メインではサブ画面が必要なのでサブモジュールに依存する&lt;/li&gt;
&lt;li&gt;サブではメイン画面が必要なのでメインモジュールに依存する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwecY1CaGcBmH5nSNa5BGBSfCpoZHjOE8WGW5tPpKDAW85vT3QbuAq6K0&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。
直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。&lt;/p&gt;

&lt;p&gt;そこで、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メイン画面に遷移するメインルーターモジュール&lt;/li&gt;
&lt;li&gt;サブ画面に遷移するサブルーターモジュール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのモジュールを作ります。&lt;/p&gt;

&lt;p&gt;メインルーターモジュールでは次の遷移専用インターフェースを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface MainRouter {
  fun routeToMain(context: Context): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;internal class MainRouterImpl @Inject constructor() : MainRouter {
  override fun routeToMain(context: Context): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---

@Module
internal interface MainActivityModule {
  @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SubActivity : AppCompatActivity() {
  @Inject lateinit var router: MainRouter

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な依存図は次のようになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8goIp9ILLutBpmSTEInysRTHytRNtSFEtvbDqlvovwic_kqxKpdixUpCMLd9zRa9-NcbUY40rN2r4Kgv1OhE0UwebLoUFcrO-RzpnksWyaOGgDKLGYMGTJO8If09iv9bnSN41AGRUqGBV63c8oZ6y7LG0o3Kc12K80ge7B8JKl1HWG0000&#34; width=300&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これで、相互に遷移する画面だとしても循環参照になることなく解決することが出来ます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;いちいちルーターモジュールを作るのがめんどうなのであれば、共通のRouterインターフェースを作る方法もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Router&amp;lt;T&amp;gt; {
  fun route(context: Context, params: T): Intent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実装は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;---実装

internal class MainRouter2Impl @Inject constructor() : Router&amp;lt;Unit&amp;gt; {
  override fun route(context: Context, params: Unit): Intent {
    return Intent(context, MainActivity::class.java)
  }
}

---Daggerの設定

@Module
internal interface MainActivityModule {
  @Named(&amp;quot;main&amp;quot;)
  @Binds fun bindMain2Router(impl: MainRouter2Impl): Router&amp;lt;Unit&amp;gt;
}

---使用側

class SubActivity : AppCompatActivity() {
  @field:[Inject Named(&amp;quot;main&amp;quot;)] lateinit var router: Router&amp;lt;Unit&amp;gt;
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DaggerのNamedアノテーションと組み合わせることでいい感じに共通Routerを作ることが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;相互に行き来したい画面があったときに、遷移専用のモジュールを作ることで循環参照を防ぐことが出来る&lt;/li&gt;
&lt;li&gt;基本的に画面を含んだモジュールは遷移したいときがほとんどだと思うので、遷移専用のモジュールを作ることで無駄な依存を作ることを防ぐことが出来る&lt;/li&gt;
&lt;li&gt;遷移用のモジュールが増える😂😂😂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Part2ではDeeplinkやnavigationを絡めた遷移の方法について考えてみたいと思います😃&lt;/p&gt;

&lt;p&gt;サンプルコード: &lt;a href=&#34;https://github.com/satoshun-android-example/MultiActivityRouterExample&#34;&gt;satoshun-android-example/MultiActivityRouterExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: コーディングを支える技術</title>
      <link>https://satoshun.github.io/2018/12/coding_tech/</link>
      <pubDate>Fri, 28 Dec 2018 05:27:13 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coding_tech/</guid>
      <description>&lt;p&gt;「コーディングを支える技術」を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;比較、歴史から学ぶ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;その機能はなにかの問題を解決するために導入されている

&lt;ul&gt;
&lt;li&gt;歴史から紐解くことでなぜそれが必要かが理解できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語によってどの問題を解決したいのかが違う

&lt;ul&gt;
&lt;li&gt;Python: 同じようなコードになるような言語&lt;/li&gt;
&lt;li&gt;C++: 高速に動作することを目指している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;エラー処理の進化
- globalなエラーハンドリングはgotoと変わらない
- try catch finallyのように構造化されたエラー処理が誕生した
    - Javaでは検査型例外、必ずerrorを処理しなければいけない設計&lt;/p&gt;

&lt;p&gt;アドレスを覚えるのは人間には大変&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人間はメソッド、変数を介することでアドレスを忘れることが出来た

&lt;ul&gt;
&lt;li&gt;結果、メソッド名、変数名をいかにしてわかりやすくするかが重要になってきた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本的には何をするかというよりかは、何をさせないかで進化している&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスによるポリモーフィズム

&lt;ul&gt;
&lt;li&gt;関数ポインタを直接触らないように&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gotoの禁止

&lt;ul&gt;
&lt;li&gt;構造化、モジュール化できなくなるので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>感想: オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方</title>
      <link>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</link>
      <pubDate>Tue, 25 Dec 2018 03:00:39 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/object_oriented_practical_guide/</guid>
      <description>&lt;p&gt;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方を読んだのでざっくりと感想。&lt;/p&gt;

&lt;p&gt;継承とコンポジションはトレードオフ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;継承は自動的にaメッセージを委譲する

&lt;ul&gt;
&lt;li&gt;便利だが依存関係は強い&lt;/li&gt;
&lt;li&gt;親クラスが変更されたときに、自動的に子クラスにも影響があることを意味する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;継承は階層構造を生み出す

&lt;ul&gt;
&lt;li&gt;ポリモーフィズムを実現する&lt;/li&gt;
&lt;li&gt;これまた便利だが依存関係は強い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンポジションは自動的に委譲しない

&lt;ul&gt;
&lt;li&gt;必要に応じて集約クラスで操る必要がある&lt;/li&gt;
&lt;li&gt;依存は継承より少ない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単一責任について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あたりまえだけど守らないといけない

&lt;ul&gt;
&lt;li&gt;無駄な責務があると再利用できない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;達成することで再利用可能な素晴らしいクラスが出来る&lt;/li&gt;
&lt;li&gt;責任の依存先が不明なときは一旦privateとかに切り出しておいて未来に託す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ダックタイピング&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ダックにより、具体的なGearクラスからロールへのマインドシフトが出来る&lt;/li&gt;
&lt;li&gt;ロールを満たすことにより要件を満たす&lt;/li&gt;
&lt;li&gt;実装には依存しない、メッセージを送るだけで良い世界はOOPの真骨頂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;依存関係について&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;依存関係の向きを考えるのは大切

&lt;ul&gt;
&lt;li&gt;例えばコンストラクタ内で依存するのと、インスタンスメソッドだと距離が違う。コンストラクタ内で依存したほうが良い

&lt;ul&gt;
&lt;li&gt;さらに進めるとDI，コンストラクタの外から注入する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依存関係逆転の法則

&lt;ul&gt;
&lt;li&gt;低レイヤーに依存するのではなく、インターフェースに依存しておいて、あとから実装を注入することで達成

&lt;ul&gt;
&lt;li&gt;domain層などの他の層に依存したくない層で有効&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;柔軟なインターフェース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトを信じるようなインターフェース

&lt;ul&gt;
&lt;li&gt;どのようにするかではなく、何をするかをメソッド名にする。宣言的に&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安定していなければいけない&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>

&lt;p&gt;Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、&lt;code&gt;ContinuationInterceptor&lt;/code&gt;を使えば上手くいきそうです。&lt;/p&gt;

&lt;h2 id=&#34;continuationinterceptorとは&#34;&gt;ContinuationInterceptorとは?&lt;/h2&gt;

&lt;p&gt;ContinuationInterceptorは次のようなインターフェースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * Marks coroutine context element that intercepts coroutine continuations.
 * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and
 * intercepts all coroutine continuations with [interceptContinuation] invocations.
 */
@SinceKotlin(&amp;quot;1.3&amp;quot;)
public interface ContinuationInterceptor : CoroutineContext.Element {
  public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt;
  public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;)
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;interceptContinuation&lt;/code&gt;からContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class LifecycleContinuationInterceptor(
  private val lifecycle: Lifecycle
) : ContinuationInterceptor {
  override val key: CoroutineContext.Key&amp;lt;*&amp;gt;
    get() = ContinuationInterceptor

  override fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; {
    // ContinuationからJobを取得
    val job = continuation.context[Job]
    if (job != null) {
      lifecycle.addJob(job)
    }
    return continuation
  }
}

fun LifecycleOwner.addJob(job: Job) {
  lifecycle.addJob(job)
}

fun Lifecycle.addJob(job: Job) {
  val state = this.currentState
  val event = when (state) {
      ...
  }
  val observer = LifecycleJobObserver(job, event, this)
  this.addObserver(observer)
  job.invokeOnCompletion(observer)
}

private class LifecycleJobObserver(
  private val job: Job,
  private val event: Lifecycle.Event,
  private val lifecycle: Lifecycle
) : LifecycleObserver, CompletionHandler {
  @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
  fun onEvent(owner: LifecycleOwner, event: Lifecycle.Event) {
    if (event == this.event) {
      owner.lifecycle.removeObserver(this)
      job.cancel()
    }
  }

  override fun invoke(cause: Throwable?) {
    lifecycle.removeObserver(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、Android Lifecycleと協調して動くContinuationInterceptorが出来ました。&lt;/p&gt;

&lt;p&gt;フルコードは&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample/blob/master/autodispose/src/main/java/com/github/satoshun/coroutine/autodispose/lifecycle/LifecycleContinuationInterceptor.kt&#34;&gt;ここに&lt;/a&gt;あります。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;使い方は次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseActivity : AppCompatActivity(),
  CoroutineScope {

  private val job = Job()
  override val coroutineContext get() = job +
      Dispatchers.Main +
      LifecycleContinuationInterceptor(this) // ここでInterceptorを登録
}

class MainActivity : BaseActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // onCreateでlaunchしているので、onDestroyで自動的にキャンセルされる
    launch {
      ...
    }
  }

  override fun onResume() {
    super.onResume()

    // onResumeでlaunchしているので、onPauseで自動的にキャンセルされる
    launch {
      ...
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。&lt;a href=&#34;https://github.com/uber/AutoDispose&#34;&gt;Rx-AutoDispose&lt;/a&gt;のように実行したタイミングに応じて、キャンセルする場所を自動的に登録してくれます!!&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もっと良い書き方が出来るか模索しているので、より適したAPI等を知っている人がいれば教えてくれると嬉しいです😊😊😊&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サンプルコードです😃&lt;a href=&#34;https://github.com/satoshun-android-example/AutoDisposeExample&#34;&gt;satoshun-android-example/AutoDisposeExample&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>

&lt;p&gt;この記事ではFragmentでLiveDataにObserverを登録するときは&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;を使うと良いという話をします。&lt;/p&gt;

&lt;p&gt;まず、Fragmentのおおまかなライフサイクルは次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onAttach&lt;/li&gt;
&lt;li&gt;onCreate

&lt;ul&gt;
&lt;li&gt;onCreateView&lt;/li&gt;
&lt;li&gt;onViewCreated

&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestoryView&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;onDestroy&lt;/li&gt;
&lt;li&gt;onDetach&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここで重要なのは、&lt;code&gt;onDestroy&lt;/code&gt;が呼ばれることなく、複数回&lt;code&gt;onCreateView&lt;/code&gt;が呼ばれる可能性がある点です。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っている可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.data.observe(this, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。
このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。
しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。&lt;/p&gt;

&lt;p&gt;前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。
よって、FragmentにはView用のLifecycleが用意されています。それが、&lt;code&gt;Fragment#getViewLifecycle&lt;/code&gt;です。&lt;/p&gt;

&lt;p&gt;前述のコードは次のように書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainFragment: Fragment() {
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // ViewのLifecycleOwnerを渡す
        viewModel.data.observe(viewLifecycleOwner, Observer {
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！&lt;/p&gt;

&lt;h2 id=&#34;補足1&#34;&gt;補足1&lt;/h2&gt;

&lt;p&gt;Observerが開放されるタイミングはonDestroyがコールされるタイミングとは別にもう1つあります。
それは、Observerへの参照がなくなったタイミングです。内部的にObserverはWeakReferenceで保持されており、参照が無くなったタイミングでGCされます。&lt;/p&gt;

&lt;h2 id=&#34;補足2&#34;&gt;補足2&lt;/h2&gt;

&lt;p&gt;Observerの重複登録問題はattach/detachを繰り返す場合におこります。
サンプルコードは次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;while (true) {
    delay(3000)
    supportFragmentManager.commitNow {
        if (fragment.isDetached) attach(fragment)
        else detach(fragment)
　  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>

&lt;p&gt;この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃&lt;/p&gt;

&lt;h2 id=&#34;基本編&#34;&gt;基本編&lt;/h2&gt;

&lt;p&gt;一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成は&lt;code&gt;ViewModelProvider&lt;/code&gt;を介して行う必要があるためです。&lt;/p&gt;

&lt;p&gt;例えば、次のコードは間違っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel @Inject constructor(...): ViewModel()

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideMainViewModel(...) : MainViewModel {
        // ViewModelProviderを使ってインスタンスを生成する
        return ViewModelProviders.of(...).get(MainViewModel::class.java)
    }
}

class MainActivity {
    @Inject lateinit var viewModel: MainViewModel

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、ViewModelを直接注入せずに、&lt;code&gt;ViewModelProvider.Factory&lt;/code&gt;を注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。
このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel(...): ViewModel()
or
class MainViewModel @Inject constructor(...): ViewModel()

@Module
class MainActivityModule {
    @Provides
    fun provideViewModelFactory(...) : ViewModelProvider.Factory {
        // ここでMainViewModelを生成するFactoryを定義する
        return object: ViewModelProvider.Factory {
            ...
        }
    }
}

class MainActivity : AppCompatActivity() {
    // ViewModelではなく、Factoryを注入するのがポイント
    @Inject lateinit var factory: ViewModelProvider.Factory

    // MainViewModelインスタンスの生成はActivity側で行う
    // activity-ktxで定義されている拡張関数を使う
    private val viewModel: MainViewModel by viewModels { factory }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;activity-ktxに定義されている&lt;code&gt;viewModels&lt;/code&gt;拡張関数を使ってMainViewModelインスタンスを生成します。これでViewModelのライフサイクルを保ちつつ、Daggerで依存を解決することが出来ます。&lt;/p&gt;

&lt;p&gt;次に、この2パターンのどちらの書き方がいいかを考えていきます。&lt;/p&gt;

&lt;h2 id=&#34;実例編&#34;&gt;実例編&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;@Provides&lt;/code&gt;を使うパターンと、Factoryを使うパターンは良いところ、悪いところがそれぞれあるので、好きな方を選べばいいと思います。&lt;/p&gt;

&lt;p&gt;両アプローチともに、ソースコード、ノウハウが出ているので参考リンクを張っておきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nickbutcher/plaid/blob/master/dribbble/src/main/java/io/plaidapp/dribbble/dagger/DribbbleModule.kt#L43&#34;&gt;plaid&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Provides&lt;/code&gt;を使い、ViewModelを直接注入するパターン&lt;/li&gt;
&lt;li&gt;ViewModelごとにFactoryクラスをそれぞれ定義する必要があるので記述量が多い&lt;/li&gt;
&lt;li&gt;ViewModelの依存関係が解決できなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入出来るので使い側からすると間違った使い方は出来ない（はず）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://medium.com/@marco_cattaneo/android-viewmodel-and-factoryprovider-good-way-to-manage-it-with-dagger-2-d9e20a07084c&#34;&gt;Android ViewModel and FactoryProvider: good way to manage it with Dagger Multibindings&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Daggerのmultibindingsを使い、ViewModel Factoryを注入するパターン&lt;/li&gt;
&lt;li&gt;最初に仕組みを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;multibindingsを使っているのでランタイム時に落ちる可能性がある

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動かない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その場合ViewModelProviderを介さずインスタンス生成するので正しくない

&lt;ul&gt;
&lt;li&gt;間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/satoshun-android-example/ActivityKtxDaggerExample/tree/master/app/src/main/java/com/github/satoshun/example/sample&#34;&gt;Activity-Ktx + Dagger Example&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Factory用のカスタムクラスを定義し、ViewModel Factoryを注入するパターン

&lt;ul&gt;
&lt;li&gt;僕が作ったサンプルコードです😃　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最初に汎用クラスを入れてしまえば、のちのちの記述量は少ない&lt;/li&gt;
&lt;li&gt;ViewModelが提供されていなかったらコンパイルエラーになる

&lt;ul&gt;
&lt;li&gt;Daggerのコンパイルチェックが上手く動く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelを直接注入する書き方が可能だが、その場合ViewModelProviderを介さずインスタンス生成するので正しくない

&lt;ul&gt;
&lt;li&gt;間違った書き方が出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;個人的には一番最後の自分のパターンを押したいところですが、上記のパターンはそれぞれメリット/デメリットがあると思うので、プロジェクトによって使い分けるのがよいと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一番プロジェクトに適したパターンを適用するのが良いと思います😃&lt;/li&gt;
&lt;li&gt;DaggerでViewModelサポートの&lt;a href=&#34;https://github.com/google/dagger/issues/1271&#34;&gt;Issue&lt;/a&gt;が立っており、DaggerがViewModelをサポートする計画があります

&lt;ul&gt;
&lt;li&gt;なので前述のパターンはいつか過去のものとなる可能性が高いです。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>

&lt;p&gt;&lt;code&gt;JitPack&lt;/code&gt;からライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。
詳しくは次のリンクを参照してください。&lt;a href=&#34;https://blog.autsoft.hu/a-confusing-dependency/&#34;&gt;A Confusing Dependency&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に &lt;a href=&#34;https://docs.gradle.org/5.1-rc-1/userguide/declaring_repositories.html#sec::matching_repositories_to_dependencies&#34;&gt;Matching repositories to dependencies&lt;/a&gt; が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）&lt;/p&gt;

&lt;p&gt;まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、&lt;code&gt;cloudflare&lt;/code&gt;のSDKを依存関係に入れることを目指します。
また、今回の検証にはGradle 5.1-rc-1を使いました。&lt;a href=&#34;https://github.com/satoshun-android-example/GradleDependencyMatchingExample&#34;&gt;サンプルコードはここにあります&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずは従来の書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
        }
    }
}

---

// projectのbuild.gradle
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだと全てのライブラリに対して、repositoriesで指定した&lt;code&gt;https://storage.googleapis.com/cloudflare-maven/public/&lt;/code&gt;へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。&lt;/p&gt;

&lt;p&gt;次に新機能を使った書き方です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// topのbuild.gradle
allprojects {
    repositories {
        ...

        maven {
            url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot;
            content {
                // group idがcom.cloudflareのライブラリだけこのURLが有効になる
                includeGroup &amp;quot;com.cloudflare&amp;quot;
            }
        }
    }
}

---

// projectのbuild.gradleは一緒
dependencies {
    ...

    implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しくcontentブロックが追加されました。ここで、このURLがどのライブラリで有効になって欲しいかを記述することが出来ます。今回のURLは&lt;code&gt;com.cloudflare:cloudflare-mobile-sdk&lt;/code&gt;でのみ有効になって欲しいので、&lt;code&gt;includeGroup &amp;quot;com.cloudflare&amp;quot;&lt;/code&gt;とgroup id指定することで達成できます。これでcloudflareのライブラリに対してダウンロード制限をかけられます!!&lt;/p&gt;

&lt;p&gt;また今回の事件の場合、JCenterに悪意のあるライブラリがアップロードされたのが問題なので、JCenterからダウンロードしたいライブラリのgroup idを&lt;code&gt;includeGroup&lt;/code&gt;で指定してあげれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {
    ...
    jcenter().mavenContent {
        includeGroup &amp;quot;org.jetbrains.kotlin&amp;quot;
        includeGroup &amp;quot;org.jetbrains.kotlinx&amp;quot;
        includeGroup &amp;quot;com.google.dagger&amp;quot;
        includeGroup &amp;quot;org.jetbrains&amp;quot;
        includeGroup &amp;quot;javax.inject&amp;quot;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、JCenterからダウンロードするライブラリに制限をかけられます😃&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;AndroidだとGradle5系を使えるのがAndroid Gradle Plugin3.4からになると思うので、まだ先は長い😂&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://google.github.io/truth/&#34;&gt;Truth&lt;/a&gt;はGoogleが開発をしているテストアサーションライブラリです。&lt;/p&gt;

&lt;p&gt;従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readableにアサーションが書ける&lt;/li&gt;
&lt;li&gt;デフォルトの失敗メッセージがわかりやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;それぞれについて説明していきます。&lt;/p&gt;

&lt;h2 id=&#34;readableにアサーションが書ける&#34;&gt;readableにアサーションが書ける&lt;/h2&gt;

&lt;p&gt;ドキュメントのbenefitにあるサンプルを取り上げ説明します。
&lt;a href=&#34;http://google.github.io/truth/benefits&#34;&gt;http://google.github.io/truth/benefits&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まず従来のJUnitスタイルを使って書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertFalse(middleName.isPresent());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）&lt;/p&gt;

&lt;p&gt;これがTruthを使うと次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName();
assertThat(middleName).isAbsent();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assertThatはTruthに定義されているメソッドです。&lt;code&gt;middleName&lt;/code&gt;がabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。&lt;/p&gt;

&lt;p&gt;上記の&lt;code&gt;isAbsent&lt;/code&gt;はOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。
例えばIterableには、&lt;code&gt;containsAnyIn&lt;/code&gt;や&lt;code&gt;isEmpty&lt;/code&gt;などが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。&lt;/p&gt;

&lt;h2 id=&#34;失敗メッセージがわかりやすい&#34;&gt;失敗メッセージがわかりやすい&lt;/h2&gt;

&lt;p&gt;こちらもbenefitにあるサンプルを取り上げます。&lt;/p&gt;

&lt;p&gt;まずは従来にJUnitスタイルから。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertTrue(googleColors.contains(PINK));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。
失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。&lt;/p&gt;

&lt;p&gt;次にTruthスタイルです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assertThat(googleColors).contains(PINK);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt;&lt;/code&gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。&lt;/p&gt;

&lt;p&gt;以上がTruthのメリットになります。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;truth-androidライブラリ&#34;&gt;Truth-Androidライブラリ&lt;/h3&gt;

&lt;p&gt;JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。
例えば、Intentには以下のアサーションメソッドを使うことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hasComponent
hasComponentClass
hasComponentPackage
hasPackage
hasAction
hasNoAction
hasData
hasType
extras
categories
hasFlags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。&lt;/p&gt;

&lt;h3 id=&#34;assertjとの比較&#34;&gt;AssertJとの比較&lt;/h3&gt;

&lt;p&gt;これも公式ドキュメントにまとめてあります。&lt;a href=&#34;http://google.github.io/truth/comparison&#34;&gt;http://google.github.io/truth/comparison&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現状の主だった差分は次のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Truhtはまだ1.0.0になっていないのでAPIが変わる可能性がある&lt;/li&gt;
&lt;li&gt;TruthはChainスタイルで書くことを想定していない

&lt;ul&gt;
&lt;li&gt;これは現状のTruth哲学だが、AssertJのようなChainスタイルも普及してきたので、どちらが便利かはわからない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多少の差異はあれど、AssertJとTruthはとても似ているライブラリです。どちらか一方を使っているなら、乗り換えるメリットはおそらくないだろうという旨の内容です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Truthを使うと失敗メッセージがわかりやすくなる、便利!&lt;/li&gt;
&lt;li&gt;AssertJを使っているなら乗り換えるメリットはないかも&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Result&lt;/code&gt;が1.3からstdlibに入ったので紹介をしたいと思います。&lt;/p&gt;

&lt;p&gt;Resultは&lt;code&gt;Success T | Failure Throwable&lt;/code&gt;の2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。&lt;/p&gt;

&lt;h2 id=&#34;基本的な使い方&#34;&gt;基本的な使い方&lt;/h2&gt;

&lt;p&gt;使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val i: Result&amp;lt;Int&amp;gt; = Result.success(10)
val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;runCatching&lt;/code&gt;関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a = runCatching { doSomeThing() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resultに対する操作は以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// successに対して操作
val i = Result.success(10)
i.getOrNull() // 10
i.isSuccess // true
i.exceptionOrNull() // null
i.map { 10 * 10 }.getOrNull() // 100
i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
i.recover { 1111 }.getOrNull() // 10

// failureに対して操作
val t = Result.failure(IOException())
t.getOrNull() // null
t.isFailure // true
t.exceptionOrNull() // IOException
t.map { 10 * 10 }.getOrNull() // null
t.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) }
t.recover { 1111 }.getOrNull() // 1111
t.getOrThrow() // throw IOException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値successに対しての操作と、failureに対しての操作をそれぞれすることが出来ます。&lt;/p&gt;

&lt;p&gt;また、Resultを使うことで、functionalっぽく書くことが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;try {
    val data = doSomethingSync()
    processData(data)
} catch(e: Throwable) {
    showErrorDialog(e)
}

--&amp;gt;

runCatching { doSomethingSync() }
    .onFailure { showErrorDialog(it) }
    .onSuccess { processData(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クライアント側から見たときは、functionalっぽく書ける点がメリットだと思います。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;h3 id=&#34;resultは戻り値として返せない&#34;&gt;Resultは戻り値として返せない&lt;/h3&gt;

&lt;p&gt;これは、Resultのユースケースから外さないための制約です。なぜなら、Resultはその関数内で処理すべき例外であり、関数の呼び出し側で処理させるべきではないためです。
例えば、ある関数の返り値が&lt;code&gt;Result&amp;lt;User&amp;gt;&lt;/code&gt;となっていたときに、失敗する可能性は呼び出し側に伝わりますが、どのような失敗が起こるか分かりません。どのようにエラーを処理するかはこの関数内で完結すべきなので、返り値としてResultを指定することは出来ません。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にまとめました。より詳細な内容は&lt;a href=&#34;https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md&#34;&gt;Result KEEP&lt;/a&gt;を見てください😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>

&lt;p&gt;Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングで&lt;code&gt;namespacedRClass&lt;/code&gt;フラグが新しく追加されたので紹介します。
本記事では&lt;code&gt;3.4.0-alpha07&lt;/code&gt;で試しました。&lt;/p&gt;

&lt;p&gt;まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。
それを解決するために&lt;code&gt;namespacedRClass&lt;/code&gt;が追加されました。使い方は簡単で、次の記述を&lt;code&gt;gradle.properties&lt;/code&gt;に追加するだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.namespacedRClass=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。
例として、appcompatに依存しているライブラリモジュールを用意します。&lt;/p&gt;

&lt;p&gt;まずは、&lt;code&gt;namespacedRClass=false&lt;/code&gt;の時のRクラスです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class anim {
        private anim() {}

        public static final int abc_fade_in = 0x7f010000;
        public static final int abc_fade_out = 0x7f010001;
        public static final int abc_grow_fade_in_from_bottom = 0x7f010002;
        public static final int abc_popup_enter = 0x7f010003;
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。&lt;/p&gt;

&lt;p&gt;では次に、&lt;code&gt;namespacedRClass=true&lt;/code&gt;の時です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class R {
    private R() {}

    public static final class color {
        private color() {}

        public static final int red3 = 0x7f04004b;
    }
    public static final class id {
        private id() {}

        public static final int title = 0x7f0700b1;
    }
    public static final class layout {
        private layout() {}

        public static final int base3 = 0x7f09001d;
    }
    public static final class string {
        private string() {}

        public static final int base_string3 = 0x7f0b002a;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このモジュールで定義したリソースの内容しか含まれていないことが分かります。appcompatのRクラスは含まれていません。
ライブラリモジュールのRクラスのサイズがかなり小さくすることが出来ました!!&lt;/p&gt;

&lt;p&gt;今後、中、大規模なAndroid開発はマルチモジュールに強く依存することになると思うので、このオプションをつけることで、デバッグ時のapkサイズを抑えることが期待できます。（リリース時はR8/Proguardを使うと思うので特に影響はない）&lt;/p&gt;

&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;

&lt;p&gt;ただし、注意点として、依存関係にあるライブラリのRクラスのマージが行われないため、appcompatなどのRクラスにアクセスしたいときは、明示的にRクラスをimportをする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import androidx.appcompat.R as AppCompatR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今までだとライブラリモジュールのRクラスからすべてのリソースにアクセスできたのですが、それができなくなります。なので、このオプションをtrueしたときは、ライブラリモジュールでRクラスのimportパスを変更する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;マルチモジュール時代に適した機能だと思う

&lt;ul&gt;
&lt;li&gt;ライブラリサブモジュールのRクラスのサイズ大きくなる問題を解決できる&lt;/li&gt;
&lt;li&gt;デバッグ時のapkサイズをやや小さく出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; この記事はapiとimplementationの説明をする類の記事ではありません。&lt;/p&gt;

&lt;p&gt;Gradleで&lt;code&gt;compile&lt;/code&gt;がDeprecatedになり、implementationまたはapiを使うことが推奨されています。
それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。&lt;/p&gt;

&lt;p&gt;Dagger2でもcompileをimplementationに置き換えるPRが出されました。&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;https://github.com/google/dagger/pull/1130&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内容が興味深かったのでまとめてみようと思います。&lt;/p&gt;

&lt;p&gt;まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Add Dagger dependencies
dependencies {
  - compile &#39;com.google.dagger:dagger:2.x&#39;
  + implementation &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでjakeさんが&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とコメントしました。「Daggerコンパイラの依存はすべてのモジュールで明示的に書くだろうから、多分implementationで問題ないけど、議論の余地はある。」と。&lt;/p&gt;

&lt;p&gt;この議論を生んだ要因として、Daggerライブラリの性質があります。
Daggerをライブラリで使ったときに、そのライブラリ内ではComponentやModuleを使うため、当然DaggerのAPIを使うことになります。
しかし、クライアント側ではComponentとModuleなどのDaggerのAPIを使う必要は必ずしもありません。ただ、DaggerではLazy、ProviderなどのAPIも定義されており、これらのAPIはクライアント側で使うことが予想されます。
なので、結局このライブラリを依存に持つようなモジュールはLazy、Providerを使うことになるので、最終的にDaggerに依存することが確定しているなら、implementationではなく、apiで指定したほうが良いのではという話です。ただし、プロジェクトのモジュール構成によってはimplementationのほうがふさわしい場合もあるので、その場合はimplementationに置き換えることが期待されています。&lt;/p&gt;

&lt;p&gt;最終的なこの議論の着地として、implementationを使うかapiを使うかはプロジェクトに強く依存するのでどちらが正しいかはない。そのため、今回置き換えたいcompileはapiとほぼ同等の意味を持つので、置き換えるならapiのほうがふさわしいんじゃないか、今までと同じ動作をするので安全じゃないかという感じでまとまりました。&lt;/p&gt;

&lt;p&gt;現状の差分は以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-  compile &#39;com.google.dagger:dagger:2.x&#39;
+  api &#39;com.google.dagger:dagger:2.x&#39;
  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39;
}

+ For more information on api vs implementation please see https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?utm_source=android-studio#new_configurations

- compile &#39;com.google.dagger:dagger-android:2.x&#39;
- compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
+ implementation &#39;com.google.dagger:dagger-android:2.x&#39;
+ implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dagger-androidがimplementationのままなのは、こちらにはLazyやProviderなどのクライアントライブラリが使うであろうAPIが含まれていないためだと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;READMEを更新するのにかなり熱い議論をしているのがすごい印象的でした

&lt;ul&gt;
&lt;li&gt;手を抜かないって大事なんだなって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;より詳しい議論は、&lt;a href=&#34;https://github.com/google/dagger/pull/1130&#34;&gt;ISSUE&lt;/a&gt;を見て下さい😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
  </channel>
</rss>