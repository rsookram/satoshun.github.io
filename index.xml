<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2019 Sato Shun</copyright>
    <updated>Wed, 03 Jul 2019 12:30:11 UTC</updated>
    
    
    <item>
      <title>Android: RestrictToアノテーションのIDE上での振る舞い</title>
      <link>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</link>
      <pubDate>Wed, 03 Jul 2019 12:30:11 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</guid>
      <description>

&lt;p&gt;&lt;code&gt;androidx.annotation:annotation&lt;/code&gt;には、&lt;code&gt;RestrictTo&lt;/code&gt;アノテーションクラスが定義されています。
このアノテーションは次の用途を持ちます。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Denotes that the annotated element should only be accessed from within a specific scope (as defined by Scope).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;指定したScope以外からのアクセスを制限するアノテーションです。&lt;/p&gt;

&lt;p&gt;この記事では、この&lt;code&gt;RestrictTo&lt;/code&gt;アノテーションがついたクラスに様々な場所からアクセスしたときに、どのようにIDE上で警告が出るかについて見ていきます。&lt;/p&gt;

&lt;p&gt;また、Android Studio 3.5.0-beta05で検証しました。&lt;/p&gt;

&lt;p&gt;この記事内に出てくるRestrictTo関連のコードは以下のライセンスに従います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scopeの一覧&#34;&gt;Scopeの一覧&lt;/h2&gt;

&lt;p&gt;RestrictToの定義は以下のようになっています。（コメント等は削除してます。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public @interface RestrictTo {
    Scope[] value();

    enum Scope {
        LIBRARY,
        LIBRARY_GROUP,
        LIBRARY_GROUP_PREFIX,
        @Deprecated
        GROUP_ID,
        TESTS,
        SUBCLASSES,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GROUP_IDはdeprecatedとのことなので、それ以外のLIBRARY、 LIBRARY_GROUP、 LIBRARY_GROUP_PREFIX、 TESTS、 SUBCLASSESの挙動について見ていきます。&lt;/p&gt;

&lt;h2 id=&#34;各スコープについて&#34;&gt;各スコープについて&lt;/h2&gt;

&lt;p&gt;次のように説明があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
  * Restrict usage to code within the same library (e.g. the same
  * gradle group ID and artifact ID).
  */
LIBRARY,

/**
  * Restrict usage to code within the same group of libraries.
  * This corresponds to the gradle group ID.
  */
LIBRARY_GROUP,

/**
  * Restrict usage to code within packages whose groups share
  * the same library group prefix up to the last &amp;quot;.&amp;quot;, so for
  * example libraries foo.bar:lib1 amd foo.baz:lib2 share
  * the prefix &amp;quot;foo.&amp;quot; and so they can use each other&#39;s
  * apis that are restricted to this scope. Similarly for
  * com.foo.bar:lib1 and com.foo.baz:lib2 where they share
  * &amp;quot;com.foo.&amp;quot;. Library com.bar.qux:lib3 however will not
  * be able to use the restricted api because it only
  * shares the prefix &amp;quot;com.&amp;quot; and not all the way until the
  * last &amp;quot;.&amp;quot;.
  */
LIBRARY_GROUP_PREFIX,

/**
  * Restrict usage to tests.
  */
TESTS,

/**
  * Restrict usage to subclasses of the enclosing class.
  * &amp;lt;p&amp;gt;
  * &amp;lt;strong&amp;gt;Note:&amp;lt;/strong&amp;gt; This scope should not be used to annotate
  * packages.
  */
SUBCLASSES,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;名前から何となく想起できると思います。LIBRARY系のスコープはやや複雑に感じました。&lt;/p&gt;

&lt;p&gt;次から、実際の挙動を見ていきます。&lt;/p&gt;

&lt;h2 id=&#34;同一モジュール内&#34;&gt;同一モジュール内&lt;/h2&gt;

&lt;p&gt;最初に、呼び出される側の定義です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object Hoge {
  @RestrictTo(RestrictTo.Scope.LIBRARY)
  fun library() {}

  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
  fun libraryGroup() {}

  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
  fun libraryGroupPrefix() {}

  @RestrictTo(RestrictTo.Scope.SUBCLASSES)
  fun subclasses() {}

  @RestrictTo(RestrictTo.Scope.TESTS)
  fun tests() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;適当にスコープをつけたメソッドを定義しただけです。&lt;/p&gt;

&lt;p&gt;次に呼び出し側です。&lt;/p&gt;

&lt;p&gt;まずは、アプリケーションコードから呼び出してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Hoge.library() // OK
Hoge.libraryGroup() // OK
Hoge.libraryGroupPrefix() // OK
Hoge.subclasses() // NG
Hoge.tests() // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SUBCLASSESと、TESTSスコープを付けたときはIDEに怒られました。サブクラスではないし、テストからの呼び出しでも無いので、納得出来ます。&lt;/p&gt;

&lt;p&gt;次に、テストコードから呼び出しになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Hoge.library() // OK
Hoge.libraryGroup() // OK
Hoge.libraryGroupPrefix() // OK
Hoge.subclasses() // OK
Hoge.tests() // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SUBCLASSESスコープのときはNGだと思ったんですけど、全部OKでした。テストのときはlintって走らないんですかね？（無知）&lt;/p&gt;

&lt;h2 id=&#34;同一プロジェクト内-ライブラリモジュール&#34;&gt;同一プロジェクト内、ライブラリモジュール&lt;/h2&gt;

&lt;p&gt;次に、lib1という名前でライブラリモジュールを作り、そこで定義したクラスに、appモジュールからアクセスしてみます。&lt;/p&gt;

&lt;p&gt;settings.gradleは次のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include &#39;:app&#39;
include &#39;:lib1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、lib1に次のクラスを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object Hoge2 {
  @RestrictTo(RestrictTo.Scope.LIBRARY)
  fun library() {}

  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
  fun libraryGroup() {}

  @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
  fun libraryGroupPrefix() {}

  @RestrictTo(RestrictTo.Scope.SUBCLASSES)
  fun subclasses() {}

  @RestrictTo(RestrictTo.Scope.TESTS)
  fun tests() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、appモジュールからアクセスしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Hoge2.library() // OK
Hoge2.libraryGroup() // OK
Hoge2.libraryGroupPrefix() // OK
Hoge2.subclasses() // NG
Hoge2.tests() // NG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LIBRARY、LIBRARY_GROUP、LIBRARY_GROUP_PREFIXでOKになりました。現状だと同一プロジェクト内に各モジュールが定義されている場合、これらのスコープは特に考慮されなそうでした。&lt;/p&gt;

&lt;h2 id=&#34;サードパーティライブラリの場合&#34;&gt;サードパーティライブラリの場合&lt;/h2&gt;

&lt;p&gt;androidx内で定義されているスコープが付いたクラスに、appモジュールからアクセスしてみます。&lt;/p&gt;

&lt;p&gt;まずは、ライブラリモジュール内の定義から。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestrictTo(LIBRARY)
public class ContentFrameLayout extends FrameLayout

---

public class MediaItem {
  @RestrictTo(LIBRARY_GROUP)
  public static class Builder
}

---

@RestrictTo(LIBRARY_GROUP_PREFIX)
public class DrawableWrapper extends Drawable implements Drawable.Callback
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、appから呼び出してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;ContentFrameLayout(...) // NG
MediaItem.Builder().build() // NG
DrawableWrapper(...) // OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LIBRARY、LIBRARY_GROUPスコープがついたクラスに、アクセスするとIDEに怒られました。これは想像つくと思います。
しかし、LIBRARY_GROUP_PREFIXは怒られませんでした。これは多分間違った挙動だと思うのでいつか直ると思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ざっくりと挙動を見ていきました。

&lt;ul&gt;
&lt;li&gt;ライブラリ開発をしているときはLIBRARY**系のスコープを意識すると良さそう&lt;/li&gt;
&lt;li&gt;アプリケーション開発時は、TESTS、SUBCLASSESを必要に応じてつける感じで&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LIBRARY_GROUP_PREFIXは、おそらくマルチモジュール環境で有効に使うことが可能だと思うので、今後に期待&lt;/li&gt;
&lt;li&gt;なぜこのような挙動になるか、などの細かい部分は実際のRestrictToクラスのコメントを見ていただけると幸いでございます&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Retrofit: Coroutineを使うときの、Response&lt;T&gt;と生のTの使い分け</title>
      <link>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</link>
      <pubDate>Tue, 02 Jul 2019 13:46:54 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</guid>
      <description>

&lt;p&gt;psideさんの、&lt;a href=&#34;https://qiita.com/pside/items/e546f0f12989e8dcd729&#34;&gt;Retrofit2でRxJavaを使う時の Result&lt;T&gt;, Response&lt;T&gt;, そのままT の使い分け所感&lt;/a&gt;のCoroutineバージョンの記事となります。&lt;/p&gt;

&lt;p&gt;上記の記事に書いてある、Rxとは違い、Result型は用意されていないので、Response型で包むか、生で値ｗ受け取るかのどちらかが基本となります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface HogeService {
    suspend fun getHoge(): Hoge
    or
    suspend fun getHoge(): Response&amp;lt;Hoge&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Retrofitの2.6.0で、挙動の違いを確認しました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;生&lt;/th&gt;
&lt;th&gt;Response&lt;T&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;例外&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ネットワークに繋がっていない&lt;/td&gt;
&lt;td&gt;例外&lt;/td&gt;
&lt;td&gt;例外&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;シリアライズが出来ない（型がおかしい）&lt;/td&gt;
&lt;td&gt;例外&lt;/td&gt;
&lt;td&gt;例外&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;生の場合、HTTPのstatus Code的に失敗とされるものは例外になる&lt;/li&gt;
&lt;li&gt;Response型で包めば、HTTPのstatus Code的に失敗だとしても例外が発生しない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;っていう感じの挙動になります。&lt;/p&gt;

&lt;h2 id=&#34;どっちを使えばいいの&#34;&gt;どっちを使えばいいの?&lt;/h2&gt;

&lt;p&gt;サーバがエラーコードを返してきた時に、特別な振る舞いをしたいエンドポイントってあると思うので、そういうときはResponseで包んであげて、それ以外は生でいいんじゃない？って思ってます（小並感&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>RxJava 3.xの開発が本格的に始まりました</title>
      <link>https://satoshun.github.io/2019/06/rxjava3-preview/</link>
      <pubDate>Mon, 24 Jun 2019 13:52:14 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/06/rxjava3-preview/</guid>
      <description>

&lt;p&gt;現状での差異をまとめておきます。&lt;/p&gt;

&lt;h2 id=&#34;rxjava2との差異&#34;&gt;RxJava2との差異&lt;/h2&gt;

&lt;h3 id=&#34;readmeから&#34;&gt;READMEから&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/blob/3.x/README.md&#34;&gt;README.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RxJava2 との差分は以下のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fixed API mistakes and many limits of RxJava 2

&lt;ul&gt;
&lt;li&gt;RxJava2のいくつかのAPIのミス、制限を直している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;intended to be a replacement for RxJava 2 with relatively few binary incompatible changes

&lt;ul&gt;
&lt;li&gt;APIに多少の変更があり、バイナリ互換がない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;test and diagnostic support via test schedulers, test consumers and plugin hooks

&lt;ul&gt;
&lt;li&gt;テストのサポートの充実&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-x-different-docsから&#34;&gt;3.x different docsから&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/blob/3.x/docs/What&#39;s-different-in-3.0.md&#34;&gt;3.x different docs&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;asメソッドとtoメソッド&#34;&gt;asメソッドとtoメソッド&lt;/h4&gt;

&lt;p&gt;toメソッドはFunction型を引数から取っていた。しかし、あらゆるReactive型でFunction型を受け取っていたので、共通のConverterを作ることが出来なかった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Obsevable.java
public final &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Observable&amp;lt;T&amp;gt;, R&amp;gt; converter)

// Single.java
public final &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Single&amp;lt;T&amp;gt;, R&amp;gt; convert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じFunction型を引数に取るので、共通のクラスを作ることが出来ない。&lt;/p&gt;

&lt;p&gt;→ そこで、asメソッドが誕生&lt;/p&gt;

&lt;p&gt;asメソッドでは、CompletableConverter、ObservableConverterなど、専用のインターフェース型が定義され、1つのクラスに実装できるようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Observable.java
public final &amp;lt;R&amp;gt; R to(@NonNull ObservableConverter&amp;lt;T, ? extends R&amp;gt; converter)

// Single.java
public final &amp;lt;R&amp;gt; R to(@NonNull SingleConverter&amp;lt;T, ? extends R&amp;gt; converter) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;→ autodisposeみたいな、ライブラリを作るときに便利&lt;/p&gt;

&lt;p&gt;従来のtoメソッドは消えて、RxJava 3ではasに統合された。（メソッド名はtoです)&lt;/p&gt;

&lt;h4 id=&#34;functional-typesがthrowableをthrowするようになった&#34;&gt;Functional typesがThrowableをthrowするようになった&lt;/h4&gt;

&lt;p&gt;今まではFunctional typesとして、Callableインターフェースを使っていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Callable&amp;lt;V&amp;gt; {
    /**
      * Computes a result, or throws an exception if unable to do so.
      *
      * @return computed result
      * @throws Exception if unable to compute a result
      */
    V call() throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これからは、Supplierインターフェースを使うようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Supplier&amp;lt;T&amp;gt; {

    /**
     * Produces a value or throws an exception.
     * @return the value produced
     * @throws Throwable if the implementation wishes to throw any type of exception
     */
    T get() throws Throwable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;throwする例外がException -&amp;gt; Throwableに広がりました。&lt;/p&gt;

&lt;p&gt;ちなみに、lambda式を使っている場合は変更するコードを必要がないかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// before
source.to(flowable -&amp;gt; flowable.blockingFirst());

// after
source.to(flowable -&amp;gt; flowable.blockingFirst());
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;startwithメソッド&#34;&gt;startWithメソッド&lt;/h4&gt;

&lt;p&gt;startWith(T)、startWith(Iterable)、 startWith(Publish)の同名で3つのメソッドがありましたが、
startWithItem、startWithIterableにそれぞれリネームされました。&lt;/p&gt;

&lt;h2 id=&#34;メモ-その他&#34;&gt;メモ・その他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;continued support for Java 6+ &amp;amp; Android 2.3+

&lt;ul&gt;
&lt;li&gt;RxJava 2.xとサポートバージョンは変わらないっぽい🎉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RxJava 2からの、大きな変更はなさそう。APIの整理がメイン？&lt;/li&gt;
&lt;li&gt;12月に正式版のリリースのようです &lt;a href=&#34;https://twitter.com/RxJava/status/1141324394595266562&#34;&gt;twitter/Rxjava&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;3.0.0-RC0が出ました

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://search.maven.org/artifact/io.reactivex.rxjava3/rxjava/3.0.0-RC0/jar&#34;&gt;https://search.maven.org/artifact/io.reactivex.rxjava3/rxjava/3.0.0-RC0/jar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlinのwildcard importと拡張関数</title>
      <link>https://satoshun.github.io/2019/06/kotlin-wildcard-import-extension-method/</link>
      <pubDate>Wed, 19 Jun 2019 00:48:27 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/06/kotlin-wildcard-import-extension-method/</guid>
      <description>

&lt;p&gt;Kotlinの公式?ではwildcard importを多様しているなって思っていました。&lt;/p&gt;

&lt;p&gt;Roman Elizarovさんが、&lt;a href=&#34;https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee&#34;&gt;Extension-oriented design&lt;/a&gt;中でちらっとメリットについて話していました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You might notice that our Kotlin code usually uses wildcard imports like import com.example.*. It is handy in Kotlin, because importing just a class in Kotlin is rarely enough. All the useful, convenient, utility functions are typically defined in the same package but outside of the class as extension functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;まとめると、Javaとは違い、Kotlinでは拡張関数があります。拡張関数の多くは、クラスと同じパッケージに定義されますが、拡張関数なのでクラスの外側に配置されます。wildcard importでは外側に配置された、拡張関数もまとめてimportすることが出来るため便利です。&lt;/p&gt;

&lt;p&gt;という理由らしいです。&lt;/p&gt;

&lt;h2 id=&#34;雑談-wildcard-importのデメリット&#34;&gt;雑談: wildcard importのデメリット&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;名前衝突が起きやすい&lt;/li&gt;
&lt;li&gt;どのような依存があるのかが分かりにくい

&lt;ul&gt;
&lt;li&gt;レビューのしずらさ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;無駄なクラスへの依存が生まれる&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Google I/O&#39;19: Build a Modular Android App Architectureのまとめ・感想</title>
      <link>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</link>
      <pubDate>Sun, 09 Jun 2019 12:04:27 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</guid>
      <description>

&lt;p&gt;以下の動画のまとめです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PZBg5DIzNww&#34;&gt;Build a Modular Android App Architecture (Google I/O&amp;rsquo;19)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;なぜモジュール化をするか&#34;&gt;なぜモジュール化をするか?&lt;/h2&gt;

&lt;h3 id=&#34;スケール&#34;&gt;スケール&lt;/h3&gt;

&lt;p&gt;モジュール化することで、開発者が独立して開発出来るようになる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人数が増えてきた時、アプリが大きくなってきた時にモジュール化は有効&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保守性&#34;&gt;保守性&lt;/h3&gt;

&lt;p&gt;例えば、モノリシックアプリだとレイアウトファイルを1つのディレクトリに持つことになる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;何をしているのか、何をしたいのかが理解しにくい&lt;/li&gt;
&lt;li&gt;長いレイアウトファイル名になりがち&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ビルド時間の短縮&#34;&gt;ビルド時間の短縮&lt;/h3&gt;

&lt;p&gt;変更があったモジュール + その依存関係にあるモジュールが再ビルドされるため、ビルド時間が短くなる&lt;/p&gt;

&lt;h3 id=&#34;ciの高速化&#34;&gt;CIの高速化&lt;/h3&gt;

&lt;p&gt;再ビルドが必要なモジュールのみテストをすれば良いので、テスト時間が短くなる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/buildSrc/src/main/kotlin/androidx/build/dependencyTracker/&#34;&gt;androidx/dependencyTracker&lt;/a&gt;を使うといい感じにテストが出来る（らしい）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;apkサイズの縮小&#34;&gt;APKサイズの縮小&lt;/h3&gt;

&lt;p&gt;App Bundle、Dynamic Deliveryの恩恵を受けられる&lt;/p&gt;

&lt;h2 id=&#34;モジュール&#34;&gt;モジュール&lt;/h2&gt;

&lt;p&gt;どのようにモジュール分けをするか?&lt;/p&gt;

&lt;h3 id=&#34;1-feature-機能-ごとに分ける&#34;&gt;1. Feature（機能）ごとに分ける&lt;/h3&gt;

&lt;p&gt;ライブラリモジュールとDynamic Featureモジュールの2種類がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ライブラリモジュール

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;com.android.library&lt;/code&gt;を指定する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dynamic Featureモジュール

&lt;ul&gt;
&lt;li&gt;onDemand trueとfalseがある

&lt;ul&gt;
&lt;li&gt;Paidのような一部のユーザが使う機能の場合はtrueが良い&lt;/li&gt;
&lt;li&gt;Onboardingのように、後でいらなくなる機能の場合はfalseが良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plaidでは以下のようなモジュール構成にした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/qwNff93mQNWP8E8yIOdnxHlB7VxeyatfnF6mB5UV8OM79kqVVVy4bH1syJsrv3Y2ABqIkebCB2ASKv1-vyLt0dPas4mIbO9CkTt1CZ7wUJ78nPRp35B0guWwfdZ0B3qEtge5wTLi-tCVpT2akRMPHBHV34dGIJ1kiI-PUiRIhy_NXtz4LCyrk5ib1AeXa2K0DPkCW4GLF-IfFMbNrffNOjy7YG1_8CUBRQplKTKrk2s_6F7keIBlgfPCk8i_ZwOImb7S-6SHMKtPF5gAjZtaSKeDkDee7-otF9ca671scd8gRoZteWpBtZBdbYcarckAZB3Kr8b2ZW187r_CSwZIyC17TdKoAu5z6lgaEoOE_dR-XAn5mnrIY8MrjqqF3o6muIL2kZZ2zd3dmyJvb3PopvKSb2H8UvMg3nyIQifrVii3RWMebioPyvdbiB8sRfLtsYHaF3X_2gj8FMk3YayCGY99FgGUsyOngHJgthm8CE7lFU6GavE008tozIL6HKKIDgs1kPJ3RlpDwNCcBG__lEUNCoZqbsQjN0Wo6lv3URK7xv3ZOzj-eBpaeN6oZQCs6OK7W6SEtZ5-vlP8CYxCMpxSqIjI1cepS6NOO3-IjcCTIQA7JxYjkPswTCIOi6Ur5tU56GMSR9wXN08ePlt3ELR1_CRsKA3e=w720-h404-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;p&gt;dribbleと、designernewsがDynamic Featureモジュールになっている。&lt;/p&gt;

&lt;h3 id=&#34;2-layer-層-階層-ごとに分ける&#34;&gt;2. Layer（層、階層）ごとに分ける&lt;/h3&gt;

&lt;p&gt;Plaidでは以下のように分けた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/eKPc5MsRrRbOjCXfIJnVppLjpevSWsz4e13QVgu8wAmd1AI2An-aVSerQ1Wz0DuALe6RCP3JPHkkJh1mBZx-9N2lwJj2i4aBoCrIqztFu2CLyZXu6QZBEC5AuO5FzXD90hqMMV8J12g0Sn9WjVMUQHA4RxREdVaSmNwXRt0OBfIVG_4UYdnp8SDJJ8OOKPsDqBX3cOhopNBWEK2B6Of-VwkN25G3IRrV952EnleuGaFbsxrGXkGTv64oAbnB6aw71alRN4JO3HUbXlJY54XZOXtJV3wMHu1NWOqUF9sM5GsEtcMQn_fdKsfkynN3UIZ-QTRNI2PKefKKV7X-aPZp6Jg_OAm9WoGA-VktrPj9dQRpx1EPvT6av3KfChS_x0_oCdIeJpXwLBObooQMmRpiJzKJCb112Pnq4s3XhDOcK9n08kOQZgOHOOFx_jC-CjhUEMRmK3j-XQBNmmJjqLdzBksgpajJqpbl8QS7B6snoEXPRa7AoVIfhPNRQurFi5880dhTx0JrFYEm1yeHzHYTHqW7bXpjjtAYWW5MQJ6HDwSOpphlZiR1z6AnJK3DTiM5K7Q1-p27e802TcjF8O3yhFq4XDLl6IqZ_99TFoxcNcocxFCd2FlYcBcD1lOsXcIwpXOMRDapFTv7Tx8UBhzeeijqGc512lTI=w720-h402-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/_81GbLd7eZJQvhnKKjlzv08wTjRKtzqt_IZPQNf1BlYcUmCvBv1B4kD6Pjw5b0MfQfPMke62kIzaXW7AjRON695kLYHQKHkk_-03L7IynQHKNggkWh9L5BZWafVz2nEz4f8Bn_mFDjuo2FT8iK6Ho4HI8L3d67qQh7N-Ljj-5G7glOklHSEQMGLOPzLRr7bH_b_jogHxLZS48_hWkeeFLqsBFscsiPXMjuyz5mjfCv9z-ZgvKa45LL8vkqe6jMWaBH2bGhkMJChHCD8fMbPaVDN-eNaSq5hvU6XcmAexyYMqM72exG2fuzxj2aGDPFCtZ3v9_8g5RMHVTb4wG4yG87epXC2XDRG9TJ3P6hAUl4IEgX0bJScukdHZMJDB7zqVJXgP_WSrHzkcecQEaj5cFLnZlCaS4TDXF-4g9gD4dOgA7RyE2nusWN0fWIgd7BC5JzdjIOU8Z9M8IoMB_wFjw8y0y8lshQCQJSgmgS0sg-GUihaICY0SuV_CRNuLSYwcJhUgA7-a1fXHnfg5dUOJt7nDyAfAsocbLxv1p35c9bgFkyDQMMqDB0dcljZgyl8mAjcMIXv_XbmhZohbYKdFVHqT_IZ6m3q94GGZk3tpFB-FFNf023I_6HS3vqeWgEXA4ukB86FZdiCmeHVBbWuqyWvYLKZXITx-=w979-h593-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web Servicesの知識はUIはいらないので、implementationを指定する

&lt;ul&gt;
&lt;li&gt;そうすることで、UIがDTOやRetrofitの知識を知らないですむ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Entitiesの知識はUIが必要なので、apiを指定する

&lt;ul&gt;
&lt;li&gt;ただし、この場合、DAOsの知識までUIが知ってしまうので微妙

&lt;ul&gt;
&lt;li&gt;そこでCommon Value Objectsの導入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/nfbY2Dd1jEsPoFt75QM0ikteiUp7vVYGhMWJvx0nCaRgEw_WKMR3c0MABc_UOr3pLDAZnq6s6rBgNQpwF1jD7C7WR_o2ipG8_IYodL_94C8rLYaY-gP6uIgEajxxC9RC7d4vRWn6cRhT4s-ZFcwJPvnHwH3WFYMmXRNu_OnHQMSWzY6oBnjQe-LzH_km1C38s18qLcLgvdMWbJvqJLfOjOqUQrv485RI4M-R5VWfEbTAgrZ7H7XFBvZ1WVwMizg4IpWEIDWfJvO788FiavN8ipD0LS6FCYIfcyfNcmng92uFgp7wtifaSKVLl1_DnLS3rkU-QB2nJr9l_if46OjLzCMeZ33JOLRbBYxGmch0NGD_ruyQSpmK3bceTHkZ-tzaNX-6ZxY-QJsjT3OdfcI5uJnnO_4vJWRwUQ07p9FJJ8-LqAuI2rjFpS3gh3aw9F4xhGb3LPB_RynE2wQFdw7ntOj_yJR6oakRxKk2JrE-0DiTH-5BrItd0QCngLvf-7oyDqR08LidmheYrMm4WIFTiMWW5QKceMotv6Q1Sxj5jpvW_vsIiNZ7gWwtx5Xk1MljhKYdb6q900RAZozhiAIYuYtgGlvt8yBE4cA7xdjlRD4my4F3CBNneEWt-3ZtYk7TQ3OeCgEtgySEP6zQQvIqIEhSQlCEdWy8=w2160-h1210-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;p&gt;こうすることで、UIがDAOの知識を知らずに済む&lt;/p&gt;

&lt;h3 id=&#34;fakes-for-tests&#34;&gt;Fakes for tests&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/hkjj2f7NohLfThmJNQienXwvchycNGrieetXpGITrD1Lyupjz_0HHbZBdRNDpO2rR2f8RRhBB2hfqX4FkHnv7-UpRehP6Kry0vZE-upK7MjZcINGpEzCCR9mB-H_LjQ2jgQGTpn3rsvMJEoLfKp2B1GNoULlj9aLucM0_gs9nHiN1MIMHRL4AhwQHVdk6ai8yyYtu7T8LBf-vBvFNX2e8nCbuvMNclYZvSukJwLpyGX8LX5bmtTnSuuUzJvPtvCR041-tFqZd2ju44eHkeE5YrU8ZYGn3y62ojO-4A91rj8-g8tIJ3okmISj4U4qYMKRUs6CjnKYBX4bQz42ZF1jdrBMKvP3wCqfwJ4OmAkCA6lpVWWKBFZijStGF2_S2UnmXeQn5PcjyeeAqiExz644SMNifNidRglSEEVq19OARawWvp_U40MjG2Jyj3M0jxixF4qVm_cJdehDBQ_mJpUnPngzeqFfYZ-pIeC_bc4D8bzfeqv7IhVvXd_cLDsGCNlt6VpuvkMbOAVShoxg-mejMLtSA_bSOAuTalT3clfTQWJJyzPNvHW7te5sczXVdIthtqvSnsStJCItNbdcuPpDDScCKLzqHVBIWj2NT1McfivRzECx2P_AYEWkCkPgDLESKYFUz-ORoJJeLhseWuqdz2VWU-NtXyus=w2160-h1202-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;モックよりも優れた方法

&lt;ul&gt;
&lt;li&gt;fakeはRepository（対象のクラス）がどのように振る舞うかを理解した上で作られる

&lt;ul&gt;
&lt;li&gt;（モックはその場、その場で作られがちという意味？）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;featureモジュールの利点&#34;&gt;Featureモジュールの利点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;カプセル化&lt;/li&gt;
&lt;li&gt;Dynamic Delivery&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;layerごとに分ける利点&#34;&gt;Layerごとに分ける利点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;サードパーティライブラリの依存を独立&lt;/li&gt;
&lt;li&gt;構造をもたらす&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dynamic-deliveryの課題&#34;&gt;Dynamic Deliveryの課題&lt;/h3&gt;

&lt;p&gt;Featureモジュール間のNavigationをどうするか?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;appから、Dynamic Featureモジュールへの依存を持てない

&lt;ul&gt;
&lt;li&gt;（これはDynamic Deliveryの制約のため）&lt;/li&gt;
&lt;li&gt;文字列、リフレクションでstartActivityするしかない&lt;/li&gt;
&lt;li&gt;Fragmentも同様&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今後、Navigationライブラリで自然に書けるようになるらしい😃&lt;/p&gt;

&lt;h2 id=&#34;データベース&#34;&gt;データベース&lt;/h2&gt;

&lt;h3 id=&#34;1つのデータベースのみ持つ&#34;&gt;1つのデータベースのみ持つ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;pros

&lt;ul&gt;
&lt;li&gt;コネクションの管理が楽&lt;/li&gt;
&lt;li&gt;テーブルのシェアが簡単&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cons

&lt;ul&gt;
&lt;li&gt;モジュール間に依存が生まれる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;モジュールごとに1つのデータベースを持つ&#34;&gt;モジュールごとに1つのデータベースを持つ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;pros

&lt;ul&gt;
&lt;li&gt;モジュール間の依存が疎になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cons

&lt;ul&gt;
&lt;li&gt;データベースのコネクション管理がめんどい&lt;/li&gt;
&lt;li&gt;繰り返しのコードが生まれやすい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hybridアプローチ&#34;&gt;hybridアプローチ&lt;/h3&gt;

&lt;p&gt;特にルールを決めずに、データベースモジュールを作っていく&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pros

&lt;ul&gt;
&lt;li&gt;Flexible&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cons

&lt;ul&gt;
&lt;li&gt;Fiexible

&lt;ul&gt;
&lt;li&gt;どこに、どのDAO、Entityを置けば良いのかの判断を常に迫られる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/gTSq0TPmgz2B2iyb_qidLaq-G8VSSnmSOI_VDez7Mu0UBASB5h7PIRDKWMJPrH40XGxFCw3QDenkSgiD6f4D2U5EhBAK_OEayUdIVtH5hX53vvUQM7Q-4AiJHx0NDt-4iRjCjaTeIlJs16YyeZpEt6iIvgp9HrAD_cr7vE5myFyRzeJnaHSU_vzZULGICVIWBmgxKFAcHUKDdiHRHUMuncyewUxZGc_O5t3xlQvXUanCQxVh6NXvBQZXxhFpqYRMwPiSTTNmIGz8BFFnX5JqHZAdKULHDZDV8FjeT6KtQXFjPQMMrEm6c_Sdka9aHgH5c4U76VbhF9lJd1xnn0i_jeVhbBXZ4Ylhwuem8trNGg0L2-JSphGwz2dlud0oS39CwN3spcRFEXkyQ3F6AjaW0omnmWYh1S3r2p_W9Wd3Yxyy3H7egkYyHdYmdqU76m5s0y9pCL3VWaiGvLZFr61Z0NVABPVW9O_dDS5jroA8OV4yJn_q6kMEQ_QgYz5uCatq_a86gXcWFRBipdZfhqMCZCMvJ8apGzKzrIyDuiM-3GMk_IZLR4ybtgdpFoxIEdXhCPHpUnWiCPQ6xsH3Od2P485MLbKLdZWDp76NB36DZRhlPAs33Z5h-ItZfm1mKok05rXrzibepyocRNr2rUKnOoyaHtsaxKek=w2160-h1202-no&#34; width=500 /&gt;&lt;/p&gt;

&lt;p&gt;マルチモジュール対応Room絶賛開発中らしい😃&lt;/p&gt;

&lt;h3 id=&#34;android-free-modules&#34;&gt;Android free modules&lt;/h3&gt;

&lt;p&gt;multi platformにする場合&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kotlin nativeとか

&lt;ul&gt;
&lt;li&gt;ちゃんとユースケースを持っているなら、multi platformは良い選択&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;テストの高速化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;確かにテストは早くなるが、テストのためだけにAndroid freeにするのは冗長

&lt;ul&gt;
&lt;li&gt;Robolectricで十分&lt;/li&gt;
&lt;li&gt;Android Frameworkの再開発は無駄e&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;最小限の依存関係でモジュールを構成する&lt;/li&gt;
&lt;li&gt;関心事の分離

&lt;ul&gt;
&lt;li&gt;ビジネスロジックがUIに依存しない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;抽象化

&lt;ul&gt;
&lt;li&gt;抽象化は非常に便利だが、複雑になりがちなので、抽象化により得れる利点を常に考える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;これらのモジュール化のやりかたは、あくまでオプション

&lt;ul&gt;
&lt;li&gt;ユーザはマルチモジュールなコードだからって5つ星はくれない&lt;/li&gt;
&lt;li&gt;あくまでユーザが一番大事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;まとめ-感想&#34;&gt;まとめ・感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dynamic DeliveryはNavigationに対応が入ってきたあたりで導入検討したいなって思った

&lt;ul&gt;
&lt;li&gt;まだノウハウが少ない印象なので&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Fakeのためのモジュールはいいアイデアだなって思った

&lt;ul&gt;
&lt;li&gt;テストで、モックはあまり使わない流れなのかもしれない

&lt;ul&gt;
&lt;li&gt;確かにモックをカジュアルに使いすぎると何をテストしているか分からなくなるときがある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;やっぱ関心ごとの分離って大事なんやなって

&lt;ul&gt;
&lt;li&gt;層、モジュールでうまく強制、表現したい&lt;/li&gt;
&lt;li&gt;サードパーティライブラリへの依存が、特定のモジュールに押し込めるのは良さ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Dagger2: 2.23に入ったHasAndroidInjectorについて</title>
      <link>https://satoshun.github.io/2019/06/dagger-android-injector/</link>
      <pubDate>Sun, 02 Jun 2019 09:08:57 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/06/dagger-android-injector/</guid>
      <description>

&lt;p&gt;Dagger 2.23に新しく、&lt;code&gt;HasAndroidInjector&lt;/code&gt;インターフェースが入りました。
これは、従来の&lt;code&gt;HasActivityInjector&lt;/code&gt;や&lt;code&gt;HasFragmentInjector&lt;/code&gt;などを置き換えるために作られました。&lt;/p&gt;

&lt;p&gt;この記事では、どのように置き換えるかを説明していきたいと思います。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;DaggerApplication&lt;/code&gt;や&lt;code&gt;DaggerActivity&lt;/code&gt;などの基底クラスは使っていないものとします。&lt;/p&gt;

&lt;h2 id=&#34;置き換えていく&#34;&gt;置き換えていく&lt;/h2&gt;

&lt;h3 id=&#34;appcomponent&#34;&gt;AppComponent&lt;/h3&gt;

&lt;p&gt;AndroidSupportInjectionModuleを使っているなら、&lt;code&gt;AndroidInjectionModule&lt;/code&gt;に置き換えます。
今後は、&lt;code&gt;AndroidSupportInjectionModule&lt;/code&gt;を使う必要はありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton
@dagger.Component(
  modules = [
    AndroidInjectionModule::class, // AndroidInjectionModuleを使う
    ...
  ]
)
interface AppComponent ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;application&#34;&gt;Application&lt;/h3&gt;

&lt;p&gt;Applicationで実装している、HasActivityInjector、HasServiceInjectorなどのHasxxxInjectorを&lt;code&gt;HasAndroidInjector&lt;/code&gt;に置き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class App : Application(),
  // HasAndroidInjectorのみでおｋ
  HasAndroidInjector {

  // 型変数がAnyになる
  @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt;

  // 返り値の型変数がAnyになる
  override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; {
    DaggerAppComponent.factory().create(this).inject(this)
    return androidInjector
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今まではActivity用、Fragment用、Service用などのクラスごとに&lt;code&gt;DispatchingAndroidInjector&lt;/code&gt;がありましたが、それが1つの&lt;code&gt;DispatchingAndroidInjector&amp;lt;Any&amp;gt;&lt;/code&gt;まとまりました。&lt;/p&gt;

&lt;h2 id=&#34;activity-fragment&#34;&gt;Activity, Fragment&lt;/h2&gt;

&lt;p&gt;HasSupportFragmentInjectorなどのInjectorは、&lt;code&gt;HasAndroidInjector&lt;/code&gt;に置き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity(),
  // HasSupportFragmentInjectorの代わりに、HasAndroidInjectorを使う
  HasAndroidInjector {

  @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt;

  override fun onCreate(savedInstanceState: Bundle?) {
    AndroidInjection.inject(this) // ここは一緒
    ...
  }

  override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; {
    return androidInjector
  }
}

---以下、Fragment---

class MainFragment : Fragment() {
  override fun onAttach(context: Context) {
    AndroidSupportInjection.inject(this) // ここは一緒
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となります。従来の***Injectorが汎用的な&lt;code&gt;HasAndroidInjector&lt;/code&gt;まとまりました😃&lt;/p&gt;

&lt;p&gt;大きなコードの修正は必要なさそうです。&lt;/p&gt;

&lt;h2 id=&#34;なぜこの変更が入ったか&#34;&gt;なぜこの変更が入ったか?&lt;/h2&gt;

&lt;p&gt;ronshapiroさんが以下のツイートをしていました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Dagger 2.23 turns off formatting by default so your build is faster, but has a flag to turn it back on if you&amp;#39;d like.&lt;br&gt;&lt;br&gt;It also brings bug fixes and a more flexible &lt;a href=&#34;https://t.co/d0MeQYkvAV&#34;&gt;https://t.co/d0MeQYkvAV&lt;/a&gt; API that will allow for more androidx support&lt;a href=&#34;https://t.co/vtW7gebmu2&#34;&gt;https://t.co/vtW7gebmu2&lt;/a&gt;&lt;/p&gt;&amp;mdash; Ron Shapiro (@rdshapiro) &lt;a href=&#34;https://twitter.com/rdshapiro/status/1133493726561619968?ref_src=twsrc%5Etfw&#34;&gt;May 28, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;今後、androidxのサポートを柔軟に対応するために必要だった変更のようです。&lt;/p&gt;

&lt;h2 id=&#34;daggerapplicationや-daggerappcompatactivity-daggersupportfragmentなどを使っている場合&#34;&gt;DaggerApplicationや、DaggerAppCompatActivity、DaggerSupportFragmentなどを使っている場合&lt;/h2&gt;

&lt;p&gt;2.23では、これらの基底クラスで&lt;code&gt;HasAndroidInjector&lt;/code&gt;を使っているので特に対応は必要ありません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// HasAndroidInjectorを使う実装に置き換わっている
@Beta
public abstract class DaggerApplication extends Application implements HasAndroidInjector {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唯一、AppComponentでは&lt;code&gt;AndroidSupportInjectionModule&lt;/code&gt;を使っていると思うのでそこの置き換えは必要です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HasAndroidInjectorという1つの汎用インターフェースが爆誕した&lt;/li&gt;
&lt;li&gt;androidxのサポート増やしてくれそう。嬉しい😃

&lt;ul&gt;
&lt;li&gt;（ViewModel対応してほしい&amp;hellip;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ViewModel SavedState &#43; Dagger</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</link>
      <pubDate>Sat, 25 May 2019 10:38:15 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</guid>
      <description>

&lt;p&gt;ViewModel + SavedStateでDaggerを使う方法を考えてみました。&lt;/p&gt;

&lt;h2 id=&#34;前提知識-課題&#34;&gt;前提知識・課題&lt;/h2&gt;

&lt;p&gt;SavedStateを使う場合、ViewModelに&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスを渡さなければいけません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyViewModel(
  private val state: SavedStateHandle
) : ViewModel() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateHandleインスタンスを作るために、&lt;code&gt;SavedStateVMFactory&lt;/code&gt;もしくは、&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を使う必要があります。&lt;/p&gt;

&lt;p&gt;生成したいViewModelのコンストラクタの引数がSavedStateHandleのみなら、SavedStateVMFactoryを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// thisはFragmentActivity
ViewModelProvider(this, MyViewModel(this))
  .get(MyViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタの引数がSavedStateHandle以外にもあるなら、&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を拡張します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class TestViewModel(
  private val state: SavedStateHandle,
  private val name: String
) : ViewModel()

class TestViewModelFactory(
  owner: SavedStateRegistryOwner,
  defaultArgs: Bundle? = null
) : AbstractSavedStateVMFactory(owner, defaultArgs) {
  override fun &amp;lt;T : ViewModel&amp;gt; create(
    key: String, modelClass: Class&amp;lt;T&amp;gt;,
    handle: SavedStateHandle
  ): T {
    return TestViewModel(handle, &amp;quot;test&amp;quot;) as T
  }
}

// 以下、生成コード
ViewModelProvider(this, TestViewModelFactory(this))
  .get(TestViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。&lt;/p&gt;

&lt;p&gt;今までとは違い、AbstractSavedStateVMFactoryに&lt;code&gt;SavedStateRegistryOwner&lt;/code&gt;インターフェース（実質、FragmentActivity or Fragment）を渡さなければいけません。
また、初期値が欲しい場合は、defaultArgs(Bundle)も渡す必要があります。&lt;/p&gt;

&lt;h2 id=&#34;daggerでどのように使うか&#34;&gt;Daggerでどのように使うか?&lt;/h2&gt;

&lt;p&gt;以下いろいろと書いていきます。クラス名は適当です。また、このサンプルはFragmentActivity + 初期値がintent.extras固定となります。Fragmentの場合はFragmentに置き換える必要があります&lt;/p&gt;

&lt;h3 id=&#34;1-abstractsavedstatevmfactoryを生成するクラスを定義する&#34;&gt;1. AbstractSavedStateVMFactoryを生成するクラスを定義する&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SavedStateViewModel2(
  private val dummy: Dummy,
  private val state: SavedStateHandle
) : ViewModel() {
  class Factory @Inject constructor(private val dummy: Dummy) {
    fun create(owner: FragmentActivity): AbstractSavedStateVMFactory {
      return object : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
        override fun &amp;lt;T : ViewModel&amp;gt; create(
          key: String,
          modelClass: Class&amp;lt;T&amp;gt;,
          handle: SavedStateHandle
        ): T {
          return SavedStateViewModel2(dummy, handle) as T
        }
      }
    }
  }
}

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory: SavedStateViewModel2.Factory
  private val viewModel by viewModels&amp;lt;SavedStateViewModel2&amp;gt; { // viewModelsはktxの拡張関数
    factory.create(this)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一番シンプルな方法だと思います。&lt;code&gt;AbstractSavedStateVMFactory&lt;/code&gt;を作るためのFactory（FactoryのFactory）を作り、それに&lt;code&gt;@Inject&lt;/code&gt;をつけます。&lt;/p&gt;

&lt;h3 id=&#34;2-1の方法に加え-fragmentactivityをbinds-or-providesする&#34;&gt;2. 1の方法に加え、FragmentActivityをBinds or Providesする&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Binds
fun fragmentActivity(activity: MainActivity): FragmentActivity

or

@Provides
fun fragmentActivity(activity: MainActivity): FragmentActivity = fragmentActivity

--

class SavedStateViewModel5(
  private val dummy: Dummy,
  private val state: SavedStateHandle
) : ViewModel() {
  class Factory @Inject constructor(
    owner: FragmentActivity,
    private val dummy: Dummy
  ) : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
    override fun &amp;lt;T : ViewModel&amp;gt; create(
      key: String,
      modelClass: Class&amp;lt;T&amp;gt;,
      handle: SavedStateHandle
    ): T {
      return SavedStateViewModel5(dummy, handle) as T
    }
  }
}

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory: SavedStateViewModel5.Factory
  private val viewModel by viewModels&amp;lt;SavedStateViewModel5&amp;gt; {
    factory
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FragmentActivityがInject可能になったので直接AbstractSavedStateVMFactoryが生成可能になりました😃&lt;/p&gt;

&lt;h3 id=&#34;3-assistedinjectを使う&#34;&gt;3. AssistedInjectを使う&lt;/h3&gt;

&lt;p&gt;SavedStateHandleがDaggerで解決しにくい値なので、&lt;a href=&#34;https://github.com/square/AssistedInject&#34;&gt;square/AssistedInject&lt;/a&gt;を使うことで解決を試みます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SavedStateViewModel3 @AssistedInject constructor(
  @Assisted private val state: SavedStateHandle,
  private val dummy: Dummy
) : ViewModel() {

  @AssistedInject.Factory
  interface Factory {
    fun create(state: SavedStateHandle): SavedStateViewModel3
  }
}

---

@AssistedModule
@Module(includes = [AssistedInject_SavedStateViewModelModule::class])
interface SavedStateViewModelModule

---

// 以下、生成コード
class MainActivity : AppCompatActivity() {
  @Inject lateinit var factory3: SavedStateViewModel3.Factory
  private val viewModel3 by viewModels&amp;lt;SavedStateViewModel3&amp;gt; {
    viewModelWrapper(this) { factory3.create(it) }
  }
}

---

// ただの便利関数
fun &amp;lt;T : ViewModel&amp;gt; viewModelWrapper(
  owner: FragmentActivity,
  body: (state: SavedStateHandle) -&amp;gt; T
): AbstractSavedStateVMFactory {
  return object : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
    override fun &amp;lt;T : ViewModel&amp;gt; create(
      key: String,
      modelClass: Class&amp;lt;T&amp;gt;,
      handle: SavedStateHandle
    ): T {
      @Suppress(&amp;quot;UNCHECKED_CAST&amp;quot;)
      return body(handle) as T
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じになります。FragmentActivityをInject可能にすれば、もう少しいい感じに書けると思います。最終的なコード量は1、2のパターンに比べかなり減ると思います。&lt;/p&gt;

&lt;h3 id=&#34;4-assistedinject-multibindsを使う&#34;&gt;4. AssistedInject + multibindsを使う&lt;/h3&gt;

&lt;p&gt;DaggerでViewModelのインスタンスを生成するときに、multibindsを使うパターンがよく使われているので、SavedStateの場合も考えてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@MustBeDocumented
@Target(
  AnnotationTarget.FUNCTION,
  AnnotationTarget.PROPERTY_GETTER
)
@Retention(AnnotationRetention.RUNTIME)
@MapKey annotation class ViewModelKey(
  val value: KClass&amp;lt;out ViewModel&amp;gt;
)

---

class ViewModelFactory @Inject constructor(
  owner: FragmentActivity,
  private val creators: Map&amp;lt;Class&amp;lt;out ViewModel&amp;gt;, @JvmSuppressWildcards Provider&amp;lt;SavedStateViewModelFactory&amp;gt;&amp;gt;
) : AbstractSavedStateVMFactory(owner, owner.intent.extras) {
  override fun &amp;lt;T : ViewModel&amp;gt; create(
    key: String,
    modelClass: Class&amp;lt;T&amp;gt;,
    handle: SavedStateHandle
  ): T {
    var creator: Provider&amp;lt;out SavedStateViewModelFactory&amp;gt;? = creators[modelClass]
    if (creator == null) {
      for ((key, value) in creators) {
        if (modelClass.isAssignableFrom(key)) {
          creator = value
          break
        }
      }
    }
    if (creator == null) {
      throw IllegalArgumentException(&amp;quot;unknown model class $modelClass&amp;quot;)
    }
    try {
      @Suppress(&amp;quot;UNCHECKED_CAST&amp;quot;)
      return creator.get().create(handle) as T
    } catch (e: Exception) {
      throw RuntimeException(e)
    }
  }
}

---

interface SavedStateViewModelFactory {
  fun create(
    state: SavedStateHandle
  ): ViewModel
}

---

class SavedStateViewModel4 @AssistedInject constructor(
  @Assisted private val state: SavedStateHandle,
  private val dummy: Dummy
) : ViewModel() {

  @AssistedInject.Factory
  interface Factory : SavedStateViewModelFactory {
    override fun create(state: SavedStateHandle): SavedStateViewModel4
  }
}

---

@Binds
fun bindFragmentActivity(activity: MainActivity): FragmentActivity

@ViewModelKey(SavedStateViewModel4::class)
@IntoMap @Binds
fun bind(
  factory: SavedStateViewModel4.Factory
): SavedStateViewModelFactory

---

@Inject lateinit var viewModelFactory: ViewModelFactory
private val viewModel4 by viewModels&amp;lt;SavedStateViewModel4&amp;gt; {
  viewModelFactory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateViewModelFactoryインターフェースを作るところがポイントです。他の部分は従来のViewModel + multibindsと大体一緒です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SavedStateHandleはDaggerで解決しにくい・できない？

&lt;ul&gt;
&lt;li&gt;自分で頑張ってFactoryを書く、Assisted Injectを使うなどの方法をしなければ行けない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;multibindsを使う方法はさらに複雑になった

&lt;ul&gt;
&lt;li&gt;出来るとは思うけど、個人的には推奨しない。複雑になりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の検証に使ったコードは&lt;a href=&#34;https://github.com/satoshun-android-example/ViewModelSavedState&#34;&gt;satoshun-android-example/ViewModelSavedState&lt;/a&gt;にあります😃&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>雑メモ: ViewModel SavedStateのコードリーディング</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate/</link>
      <pubDate>Tue, 21 May 2019 23:59:53 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate/</guid>
      <description>

&lt;p&gt;ViewModelのSavedStateがどのように実現しているのか、内部でどのように動作しているのか気になったので、ソースコードを読んでみました。&lt;/p&gt;

&lt;p&gt;この記事のソースコードは全て、下記のライセンスに従います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;/*
 * Copyright 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まずsavedstate本体のコード&#34;&gt;まずsavedstate本体のコード&lt;/h2&gt;

&lt;p&gt;主な登場クラスは以下です。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistry-savedstateprovider&#34;&gt;SavedStateRegistry.SavedStateProvider&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * This interface marks a component that contributes to saved state.
 */
public interface SavedStateProvider {
   /**
    * Called to retrieve a state from a component before being killed
    * so later the state can be received from {@link #consumeRestoredStateForKey(String)}
    *
    * @return S with your saved state.
    */
    @NonNull
    Bundle saveState();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;のタイミングでコールされ、&lt;code&gt;outState&lt;/code&gt;に追加で、保存したい値をBundle型で返却します。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistry&#34;&gt;SavedStateRegistry&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An interface for plugging components that consumes and contributes to the saved state.
 *
 * &amp;lt;p&amp;gt;This objects lifetime is bound to the lifecycle of owning component: when activity or
 * fragment is recreated, new instance of the object is created as well.
 */
public final class SavedStateRegistry {
    public Bundle consumeRestoredStateForKey(@NonNull String key)
    public void registerSavedStateProvider(@NonNull String key,
            @NonNull SavedStateProvider provider)
    public void unregisterSavedStateProvider(@NonNull String key)
    public boolean isRestored()
    public void runOnNextRecreation(@NonNull Class&amp;lt;? extends AutoRecreated&amp;gt; clazz)

    void performRestore(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)
    void performSave(@NonNull Bundle outBundle)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先程のSavedStateProviderを&lt;code&gt;registerSavedStateProvider&lt;/code&gt;メソッドを通して集約し、&lt;code&gt;performRestore&lt;/code&gt;、&lt;code&gt;performSave&lt;/code&gt;によって、savedStateから読み込み、outStateに保存します。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistryowner&#34;&gt;SavedStateRegistryOwner&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * A scope that owns {@link SavedStateRegistry}
 */
public interface SavedStateRegistryOwner extends LifecycleOwner {
    /**
     * Returns owned {@link SavedStateRegistry}
     *
     * @return a {@link SavedStateRegistry}
     */
    @NonNull
    SavedStateRegistry getSavedStateRegistry();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SavedStateRegistryOwnerは先程の&lt;code&gt;SavedStateRegistry&lt;/code&gt;のOwnerになります。これは、&lt;code&gt;ComponentActivity&lt;/code&gt;や&lt;code&gt;Fragment&lt;/code&gt;が実装しています。LifecycleOwner、Lifecycleのような実装です。&lt;/p&gt;

&lt;h3 id=&#34;savedstateregistrycontroller&#34;&gt;SavedStateRegistryController&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * An API for {@link SavedStateRegistryOwner} implementations to control {@link SavedStateRegistry}.
 * &amp;lt;p&amp;gt;
 * {@code SavedStateRegistryOwner} should call {@link #performRestore(Bundle)} to restore state of
 * {@link SavedStateRegistry} and {@link #performSave(Bundle)} to gather SavedState from it.
 */
public final class SavedStateRegistryController {
    public SavedStateRegistry getSavedStateRegistry()
    public void performRestore(@Nullable Bundle savedState)
    public void performSave(@NonNull Bundle outBundle)

    public static SavedStateRegistryController create(@NonNull SavedStateRegistryOwner owner)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SavedStateRegistryOwner&lt;/code&gt;のための実装です。ComponentActivityやFragmentではこのクラスを介して、Bundleから値を復元/restoreしたり、保存/saveします。&lt;/p&gt;

&lt;p&gt;これがSavedStateで使われている主なクラスになります。&lt;/p&gt;

&lt;p&gt;次に、ViewModelのsaveの実行の流れを見てみます。&lt;/p&gt;

&lt;h2 id=&#34;viewmodelのsaveの実行の流れ&#34;&gt;ViewModelのsaveの実行の流れ&lt;/h2&gt;

&lt;p&gt;ViewModelのSavedStateのsaveの実行の流れを見ながら、コードリーディングをしていきます。&lt;/p&gt;

&lt;h3 id=&#34;1-viewmodelを生成する&#34;&gt;1. ViewModelを生成する&lt;/h3&gt;

&lt;p&gt;ViewModelとSavedStateを一緒に扱い時は、&lt;code&gt;SavedStateVMFactory&lt;/code&gt;を使います。
これは、ViewModelインスタンスに&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスを渡すために必要なFactoryです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// thisはFragmentActivity
val vm = ViewModelProvider(this, SavedStateVMFactory(this))
    .get(MyViewModel::class.java)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こう書くことで、MyViewModelで&lt;code&gt;SavedStateHandle&lt;/code&gt;を受け取ることが出来ます。&lt;/p&gt;

&lt;p&gt;SavedStateVMFactoryでは以下の処理を行っています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt;インスタンスの生成

&lt;ul&gt;
&lt;li&gt;SavedStateHandleでは、&lt;code&gt;SavedStateProvider&lt;/code&gt;の実装と、outStateに保存/saveしたい状態を保持している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成したSavedStateHandleインスタンスをViewModelに渡す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SavedStateRegistry&lt;/code&gt;に、SavedStateHandleで保持しているSavedStateProviderを登録する&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-componentactivity-onsaveinstancestate&#34;&gt;2. &lt;code&gt;ComponentActivity#onSaveInstanceState&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ComponentActivity ... {
    private final SavedStateRegistryController mSavedStateRegistryController =
            SavedStateRegistryController.create(this);

    protected void onSaveInstanceState(@NonNull Bundle outState) {
        ...
        mSavedStateRegistryController.performSave(outState);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは、SavedStateRegistryControllerに、&lt;code&gt;outState&lt;/code&gt;に保存を頼みます。&lt;/p&gt;

&lt;h3 id=&#34;3-savedstateregistrycontroller-performsave&#34;&gt;3. &lt;code&gt;SavedStateRegistryController#performSave&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class SavedStateRegistryController {
    private final SavedStateRegistry mRegistry;

    ...

    public void performSave(@NonNull Bundle outBundle) {
        mRegistry.performSave(outBundle);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SavedStateRegistry&lt;/code&gt;に処理を委譲します。&lt;/p&gt;

&lt;h3 id=&#34;4-savedstateregistry-performsave&#34;&gt;4. &lt;code&gt;SavedStateRegistry#performSave&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class SavedStateRegistry {
    private SafeIterableMap&amp;lt;String, SavedStateProvider&amp;gt; mComponents =
            new SafeIterableMap&amp;lt;&amp;gt;();
    private Bundle mRestoredState;

    ...

    void performSave(@NonNull Bundle outBundle) {
        Bundle components = new Bundle();
        if (mRestoredState != null) {
            components.putAll(mRestoredState);
        }
        for (Iterator&amp;lt;Map.Entry&amp;lt;String, SavedStateProvider&amp;gt;&amp;gt; it =
                mComponents.iteratorWithAdditions(); it.hasNext(); ) {
            Map.Entry&amp;lt;String, SavedStateProvider&amp;gt; entry1 = it.next();
            components.putBundle(entry1.getKey(), entry1.getValue().saveState());
        }
        outBundle.putBundle(SAVED_COMPONENTS_KEY, components);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;outBundle#putBundle&lt;/code&gt;を通して、保存を行います。今で、直接Activityの&lt;code&gt;onSaveInstanceState&lt;/code&gt;をoverrideして書いていた処理がここに移ったイメージです。&lt;/p&gt;

&lt;h3 id=&#34;5-savedstatehandleの-savedstateprovider-の実装&#34;&gt;5. SavedStateHandleの&lt;code&gt;SavedStateProvider&lt;/code&gt;の実装&lt;/h3&gt;

&lt;p&gt;実際に保存される内容を決めるのはSavedStateHandleのSavedStateProviderの実装/中身になります。&lt;/p&gt;

&lt;p&gt;実装は次のようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Map&amp;lt;String, Object&amp;gt; mRegular;

private static final String VALUES = &amp;quot;values&amp;quot;;
private static final String KEYS = &amp;quot;keys&amp;quot;;

private final SavedStateProvider mSavedStateProvider = new SavedStateProvider() {
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    @NonNull
    @Overrides
    public Bundle saveState() {
        Set&amp;lt;String&amp;gt; keySet = mRegular.keySet();
        ArrayList keys = new ArrayList(keySet.size());
        ArrayList value = new ArrayList(keys.size());
        for (String key : keySet) {
            keys.add(key);
            value.add(mRegular.get(key));
        }

        Bundle res = new Bundle();
        // &amp;quot;parcelable&amp;quot; arraylists - lol
        res.putParcelableArrayList(&amp;quot;keys&amp;quot;, keys);
        res.putParcelableArrayList(&amp;quot;values&amp;quot;, value);
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mapに保存したい値を保持しておいて、それをBundleに書き出すだけです。&lt;/p&gt;

&lt;p&gt;ざっくりと保存の流れはこんな感じです:D&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;LifecycleOwnerのような感じで実装されていた&lt;/li&gt;
&lt;li&gt;SavedStateProviderを実装して、registerSavedStateProviderに渡せば、誰でもカスタムのSavedStateが書ける😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ViewPager2 with TabLayout</title>
      <link>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</link>
      <pubDate>Fri, 17 May 2019 04:08:42 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</guid>
      <description>

&lt;p&gt;Material ComponentsでViewPager2 + TabLayoutのコードが入ったのでそれの紹介。まだalphaへのリリースもされていないので、APIは大きく変わるかもしれません。おそらく&lt;code&gt;1.1.0-alpha07&lt;/code&gt;に入ってくると思います。&lt;/p&gt;

&lt;p&gt;TabLayoutはViewPagerでサポートされていましたが、それがViewPager2にも来たって感じです。&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;新しく追加された&lt;a href=&#34;https://github.com/material-components/material-components-android/blob/67e4489293290853de83ef1b00205058ae25fa8e/lib/java/com/google/android/material/tabs/TabLayoutMediator.java&#34;&gt;TabLayoutMediator&lt;/a&gt;を使います。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;TabLayoutMediator&lt;/code&gt;インスタンスを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val viewPager: ViewPager2 = findViewById(R.id.viewpager)
val tabLayout: TabLayout = findViewById(R.id.tab)
val mediator = TabLayoutMediator(tabLayout, viewPager) { tab: TabLayout.Tab, position: Int -&amp;gt;
  tab.text = &amp;quot;test $position&amp;quot; // タブにタイトルをセット
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタには、TabLayout、ViewPager2、OnConfigureTabCallbackを渡します。
&lt;code&gt;OnConfigureTabCallback&lt;/code&gt;は、tabとpositionを受け取り、tabに対して、タイトルをセットします。
ViewPagerのPageAdapterとは違い、RecyclerViewのAdapterからはタイトルを取得できないので、このような変更になったと思われます。&lt;/p&gt;

&lt;p&gt;最後に&lt;code&gt;attach&lt;/code&gt;関数を呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;mediator.attach()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、ViewPager2 + TabLayoutを実現できます。とても簡単！！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ViewPager2もエコシステムが整いつつある😊&lt;/li&gt;
&lt;li&gt;今回試したサンプルコードは &lt;a href=&#34;https://github.com/satoshun-android-example/ViewPager2&#34;&gt;satoshun-android-example/ViewPager2&lt;/a&gt;にあります😃&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Data Binding 3.5と3.6のまとめ/感想</title>
      <link>https://satoshun.github.io/2019/05/databinding-3dot5/</link>
      <pubDate>Thu, 16 May 2019 00:33:48 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/databinding-3dot5/</guid>
      <description>

&lt;p&gt;Google I/O 2019でDataBindingについて少し話されていたので感想とまとめを。
動画だと&lt;a href=&#34;https://youtu.be/Qxj2eBmXLHg?t=243&#34;&gt;ここらへん&lt;/a&gt;になります。&lt;/p&gt;

&lt;h2 id=&#34;改善系&#34;&gt;改善系&lt;/h2&gt;

&lt;h3 id=&#34;ビルドの高速化&#34;&gt;ビルドの高速化!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;20%くらいビルドが早くなった&lt;/li&gt;
&lt;li&gt;distributed build cache対応&lt;/li&gt;
&lt;li&gt;Incremental annotation processing対応

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android.databinding.incremental=true&lt;/code&gt; を設定にすると使えます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;android-studioとの連携強化&#34;&gt;Android Studioとの連携強化!!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Live Class Generation

&lt;ul&gt;
&lt;li&gt;XMLを変更したら、コンパイルせずともクラス、フィールドにアクセスすることが出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;リファクタリング系

&lt;ul&gt;
&lt;li&gt;フィールド名の変更リファクタリングなどをしたときに、XML、コードの両方に反映される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;errorメッセージの改善&#34;&gt;Errorメッセージの改善!!!&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;DataBinding用のエラーセクションが出来たことで、どこでエラーが出たか特定しやすくなった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/9sMrM9zLYG96Vg2Mlt7KON2audHhb2hPcryUDkkp9E0s2Q2oVKd94EsoxxvxZwhAfkORXabT2-V2lnxDlEF7gMoTWMmJ0AmIPjyp-o54bFdqoN7u4KQlNqwz6ufqT8xKx7JvKJoJc-cyaH-3IOujqq-m7V0h5QYeN1W2JAeon_fDv-vqPRqzHydPvW2zv8NEuboWPOCQFSqABPj61OEI0kLstUwClb6E6_1CAjtenJfmhUjG2_gBbNakPao6BnSb4-1_BHeZnpkUMPzWyip4I0bRtnAIZcCjt797Sk90o8e87H0y_JdGUu-crJ2LVL5QvJ8Sz2WKkFcs1AxaLnn4PfRYzooeh70hJAjFPXuR9tkonL5PjyT96EqgOhmQlmzmXaj6NEwYjmOc7VE8KDFXSvLUm1K5GlyaU1j8vUWhnNKvPPpfFn26XnIcTD0j2-YE_RhR4nP40LNS1XxCsFOJBpOWZCK69JwAp3flmULDQpmkJkeSp99T_suxdxlRDrPZnTb4gNAs6Bd0IMsalfJpOQWpAPQebqNkuan_BjytvzQl3sR0KPi73AafkfzcNQbPjsMXxMJNqbyMaxZFwDIIw5WLLm7GoOsU8PX8d1sadYbwTHVYpx9M_nqTcBLns-henpEBj89wDXy3tXg-xF2DyGNScK2blikn=w2160-h1620-no&#34; style=&#34;max-width: 600px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;新規系&#34;&gt;新規系&lt;/h2&gt;

&lt;h3 id=&#34;view-binding&#34;&gt;View Binding&lt;/h3&gt;

&lt;p&gt;簡易版Data Bindingのような立ち位置で、findViewByIdを省略 + コンパイルセーフ + コンパイルを高速にすることを目的に作られました。3.6で入るみたいです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/WfZyK356KdBHf5gHL1PExSKTXXo5_lEKhsvoDhrlRgSWH40Qa4Y6hhw_08w3Wm46KAoFAf26_cAhtDIzDja3OKxf7cVTju9UwNp-JAvaTDJrlI2gWHSmTkePpGB8Vl8pxzdmAcjuuJ1EzUW_h67sFEULzQE-a1ro96x03jAC5FCjWSArhx2f5jz9cqSPdhieW_zk1glrdLqHUogvoeJCoLbtaDy2KFnwQkwJDWPkWDfBs3Q2CxrkI6-Fom1fmpHIFMZ4NjUVU4TKfbDqYWCALnvB5G17HXy0YvFjYnSDLtWn4nUMH2rZWnh0R9JJU5fIVBDtncuZkqhp-AZUJBrInCsvV-8vIaUeBr6ZoUPTd9Ja4qz0ooODr7VOJDGBFPP4qHpNIzQwxWzCgYlsRU4l8i9dxMCKq0bLfTxZcIGBYYm-Bed8AGiUyPnsS_7HTMkuWu_NPGn-cTOTIFJ6n9vSdm2uR0IIJWXW8fS6s_q0S9eSZJYW6zeJBXOxdP4ot2FSaZDL8pmwbxivfaWTA_R3XraQizWG788EvVkpFvF2Xree28fR6qKP1zlKS2mSrooQCsQ-xNkoLWnTkNkLC8j9USiSRFrhDl0Mu9LmJckzPSq52FmaX8ClbXt8_H2vML3tmwqY8FQ92ZTmP9WNHDFr12jP96uX_3jKsraXa8btthUlzCHe58dIWeSlKU7GOqh1hr8k4GGcxZYvJVzjydsGIY-mqQ=w2160-h1620-no&#34; style=&#34;max-width: 600px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Data Bindingと比較したときの、メリット、デメリット以下になります。（ただし、まだalphaも出ていない段階なのでI/O動画から見る限りの感想です）&lt;/p&gt;

&lt;h4 id=&#34;メリット&#34;&gt;メリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;コンパイルが早くなる

&lt;ul&gt;
&lt;li&gt;Data Bindingより機能が少なくなるのでそれはそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;layout&amp;gt;&lt;/code&gt;で囲う必要がなくなった

&lt;ul&gt;
&lt;li&gt;これ個人的には好きでなかったので嬉しい。ネストが減る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;デメリット&#34;&gt;デメリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;data&amp;gt;&lt;/code&gt;セクションがなくなる

&lt;ul&gt;
&lt;li&gt;モデルの値とViewのマッピングはコード側ですることになりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多分BindingAdapterは使えない

&lt;ul&gt;
&lt;li&gt;これもコード側ですることになりそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;双方向バインディングとか使えない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;おそらくなんですけど、Data Binding、View Bindingは1つにプロジェクトに混在させることが出来るので、基本View Bindingで、双方向使いたいときはData Bindingみたいな使い方も出来るはずです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ-感想&#34;&gt;まとめ/感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;今、3.5-beta01を使っているんですが、肌感、かなり良くなっています😃

&lt;ul&gt;
&lt;li&gt;Live Class Generation便利すぎワロリン&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;View Bindingはとても良さそう

&lt;ul&gt;
&lt;li&gt;Kotlin syntheticの代わりに使ってもよさそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CameraX: CameraView触ってみた</title>
      <link>https://satoshun.github.io/2019/05/camerax-camera-view/</link>
      <pubDate>Mon, 06 May 2019 05:47:14 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/camerax-camera-view/</guid>
      <description>

&lt;p&gt;CameraXのコードが公開されていたので、その中にあったCameraViewを触ってみました。まだ、alphaであることからAPIは大きく変わる可能性があります。&lt;/p&gt;

&lt;p&gt;内部の実装であったり、細かい部分はpsideさんの「&lt;a href=&#34;https://p-side.net/posts/2019-05-05-camerax/&#34;&gt;CameraXのコードがきたので気合い入れて読んでみた&lt;/a&gt;」が詳しいです。&lt;/p&gt;

&lt;h2 id=&#34;環境構築&#34;&gt;環境構築&lt;/h2&gt;

&lt;p&gt;CameraViewはまだ公開されていないため、ソースコードからビルドする必要があります。また、設定でpublishフラグがfalseになっているので、trueにしてビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; androidx {
     name = &amp;quot;Jetpack Camera View Library&amp;quot;
-    publish = false
+    publish = true
     mavenVersion = LibraryVersions.CAMERA
     mavenGroup = LibraryGroups.CAMERA
     inceptionYear = &amp;quot;2019&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;CameraViewは普通のViewのように使うことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&amp;gt;

  &amp;lt;androidx.camera.view.CameraView
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に初期化をします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.bindToLifecycle(this) // thisはLifecycleOwner
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LifecycleOwnerとCameraViewを結びつけることでLifecycleに合わせて自動でリソースを調整してくれます。
CameraViewはLifecycle-Aware Componentとなっています。非常に扱いやすそうです。&lt;/p&gt;

&lt;p&gt;これだけでカメラ機能が使えるようになります！とても簡単！!&lt;/p&gt;

&lt;p&gt;以下、CameraViewで現状使えるAPIについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;cameraviewで使えるapi達&#34;&gt;CameraViewで使えるAPI達&lt;/h2&gt;

&lt;h3 id=&#34;モードの変更&#34;&gt;モードの変更&lt;/h3&gt;

&lt;p&gt;CameraViewでは次の3つのモードがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Image: 写真を取る&lt;/li&gt;
&lt;li&gt;Video: ビデオを取る&lt;/li&gt;
&lt;li&gt;Mixed: 両方。ただし、動かない端末もあるらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Image
cameraView.captureMode = CameraView.CaptureMode.IMAGE
cameraView.takePicture(...)

// Video
cameraView.captureMode = CameraView.CaptureMode.VIDEO
cameraView.startRecording(...)
cameraView.stopRecording()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scaletypeの設定&#34;&gt;ScaleTypeの設定&lt;/h3&gt;

&lt;p&gt;Scaleを設定することができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CENTER_CROP&lt;/li&gt;
&lt;li&gt;CENTER_INSIDE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次のように使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.scaleType = CameraView.ScaleType.CENTER_INSIDE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lensfacingの切り替え&#34;&gt;LensFacingの切り替え&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.toggleCamera()

// or

cameraView.setCameraByLensFacing(CameraX.LensFacing.FRONT)
cameraView.setCameraByLensFacing(CameraX.LensFacing.BACK)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flashモードの設定&#34;&gt;Flashモードの設定&lt;/h3&gt;

&lt;p&gt;撮影時にフラッシュを有効にすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.flash = FlashMode.ON
cameraView.flash = FlashMode.OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;torchの有効-無効&#34;&gt;torchの有効/無効&lt;/h3&gt;

&lt;p&gt;背面ライトを有効にすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.enableTorch(true)
cameraView.enableTorch(false)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zoomの設定&#34;&gt;zoomの設定&lt;/h3&gt;

&lt;p&gt;コードから変えることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.zoomLevel = 3f
cameraView.zoomLevel = 10f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、CameraViewはpinch-in-outでのzoomの変更にも対応しています。&lt;/p&gt;

&lt;h3 id=&#34;focus&#34;&gt;focus&lt;/h3&gt;

&lt;p&gt;指定した部分にfocusを合わせることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;cameraView.focus(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CameraViewは柔軟性がない代わりに、簡単にカメラの機能を使うことが出来る

&lt;ul&gt;
&lt;li&gt;とはいえ、基本的な機能は揃っていそう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後に、CameraViewを実装した結果になります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/2_s_ijtuGJSuwaJlLbsBXZ1QMTrJDjaqCM4I4ZmJQexItcrj9TgHIsh7g_VgR0nhTf-kYZ00kRDILJEsfjkd57CDK_f-d835KBsdaYdJQ0w55gsA1iCze5mC5Sm_HxDmtgHT7Asm8RUjPmYgxuI22TmFuEhP0gzxqR4ZPAroobBb0itTuZZX2Gi3X7JMfCm31wNMYSUleaBBwm9X7V3edWVCERxyLXUSoTs4ewZ-J05OMozhe0r6Wx1TsJx_5-wc4k4yrex08x4osdIiZVGJHI4W_hrlcIBL131nwHzm29djjrYLiaeb-UnKnP1kdum0NPEDIMQyvCgs3R3BR_BjoeqhLV6CadhPT2PH-AFkH4jXDKXbCC-BNRmJFbeubUtg6ATOCSXNV_Zc0i8qjzqzQFQ-kHlknUgn592eQECQYSNxS4m340CXqy_xP0DnU-o6WjE5ay4gJuYH8kR1eGflOG8sgyvoNlxaFmIXZpreBQJaXfqImK9tncglYIwVQnxEL8uMxZ_31Rc2--SVsKNCDCl625teKj28EaedQ0lzjvXlFAge4OKz-dMmMRiz12TTIfq6TFGB3TPLmjtpV1Su6VbQ0peovn6AvKgAOW2XM7JxVUmZU20GI4jtKyBMGppf4hsTY624sFnaSwoBr_7RshaOZ6f4JFykCBE4P2AvC549faCde3pnGhsQ2_ZFwA7ESpMN1hsgI7gUjFzaeSc0iLYVIw=w600-h1067-no&#34; width=300 /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>MvRxの雑な感想</title>
      <link>https://satoshun.github.io/2019/05/mvrx-architecture/</link>
      <pubDate>Sun, 05 May 2019 05:05:09 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/05/mvrx-architecture/</guid>
      <description>

&lt;p&gt;雑多なことを書いただけのブログになります。内容はあまりないよう〜。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/airbnb/MvRx&#34;&gt;MvRx&lt;/a&gt;はAirbnbが開発をしているOSSフレームワークです。&lt;/p&gt;

&lt;p&gt;特徴としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kotlinファースト&lt;/li&gt;
&lt;li&gt;RxJavaを使っている&lt;/li&gt;
&lt;li&gt;AAC（Android Architecture Components）をベースにしている

&lt;ul&gt;
&lt;li&gt;AACをRxJavaであったり、便利関数、クラス群で補佐している感じ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多くの部分でReactのAPIを参考にしてる

&lt;ul&gt;
&lt;li&gt;State、renderなど&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/airbnb/epoxy&#34;&gt;Epoxy&lt;/a&gt;と相性が良い

&lt;ul&gt;
&lt;li&gt;一緒に使うことを推奨している&lt;/li&gt;
&lt;li&gt;ReactのComponentのように振る舞わうことが出来る&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewModelが保持しているState（状態）に対して、Viewがpure functionのように振る舞う

&lt;ul&gt;
&lt;li&gt;副作用がない（減らしたい）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボイラープレートなコードを減らすことが期待できます😃&lt;/p&gt;

&lt;h2 id=&#34;個人的に気になった部分-好きなとこ&#34;&gt;個人的に気になった部分、好きなとこ&lt;/h2&gt;

&lt;h3 id=&#34;stateでview状態を管理するところ&#34;&gt;StateでView状態を管理するところ&lt;/h3&gt;

&lt;p&gt;Stateを定義することのメリットは以下かなと思ってます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stateを見れば、Viewの構成要素が分かる

&lt;ul&gt;
&lt;li&gt;MVPアーキテクチャのViewインターフェースのような役割を果たす&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;状態の管理が楽

&lt;ul&gt;
&lt;li&gt;Androidでは、configuration changes時の状態の保持が難しいが、Stateだけをケアすれば良い

&lt;ul&gt;
&lt;li&gt;MvRxの流儀に習って、正しく実装すればよしなに状態の管理をしてくれる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Viewからロジックを取ることが出来る

&lt;ul&gt;
&lt;li&gt;もちろん実装次第なのですが、StateでViewの状態を表現するようにすれば、Viewはマッピングするだけで良くなる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;asyncがすごい良い&#34;&gt;Asyncがすごい良い&lt;/h3&gt;

&lt;p&gt;MvRxではAsyncというsealed classが定義されていて、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uninitialized&lt;/li&gt;
&lt;li&gt;Loading&lt;/li&gt;
&lt;li&gt;Success&lt;/li&gt;
&lt;li&gt;Fail&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の4状態を表現することができます。画面の初期値は上記4状態で、大体のケースはケア出来ると思います。&lt;/p&gt;

&lt;p&gt;プロジェクトに、Asyncだけ取り入れるのもアリだと思います。&lt;/p&gt;

&lt;h3 id=&#34;single-eventの処理をどうするのか&#34;&gt;Single Eventの処理をどうするのか&lt;/h3&gt;

&lt;p&gt;State内で保持すると、毎回発火してしまうので、Stateとは違う、他のstreamで表現することになると思う&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;invalidateメソッドではなく、直接ViewModelに定義したフィールドを、observeすることになるので、他のページと比較したときに違和感があるかも

&lt;ul&gt;
&lt;li&gt;やっぱりSingle Eventの取り扱いって大変なんやなって&lt;/li&gt;
&lt;li&gt;とはいえ、sealed classで定義すれば、同じように見えることが出来ると思うので、大きな話ではない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chrisbanes/tivi&#34;&gt;Tivi&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;プロジェクトも大きく、Coroutineなども使っている&lt;/li&gt;
&lt;li&gt;これ見れば、なんとなく肌感は分かると思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Material Components: MotionSpecを使ってアニメーションをカスタマイズする</title>
      <link>https://satoshun.github.io/2019/04/fab-motion-spec/</link>
      <pubDate>Tue, 30 Apr 2019 05:59:41 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/fab-motion-spec/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/com/google/android/material/animation/MotionSpec&#34;&gt;MotionSpec&lt;/a&gt;はAndroid material componentsに定義されている1クラスになります。
MotionSpecを使うことで、次のアニメーション属性をカスタマイズすることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;startOffset&lt;/li&gt;
&lt;li&gt;duration&lt;/li&gt;
&lt;li&gt;interpolator&lt;/li&gt;
&lt;li&gt;repeatCount&lt;/li&gt;
&lt;li&gt;repeatMode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例えば、アニメーションを長くしたいときは、durationの値を長く、アニメーションの開始時間を遅らせたいなら、startOffsetの値を長くします。&lt;/p&gt;

&lt;p&gt;FloatingActionButtonを例に、実際にMotionSpecの値をいじってみます。&lt;/p&gt;

&lt;h2 id=&#34;最初にmotionspec用のanimator-xmlを定義する&#34;&gt;最初にMotionSpec用のanimator XMLを定義する&lt;/h2&gt;

&lt;p&gt;デフォルトのXMLをコピペしてきて、それをベースにカスタマイズするのが良いと思います。&lt;/p&gt;

&lt;p&gt;FloatingActionButton用のXMLはソースコードを読んでいくと、&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;と&lt;code&gt;design_fab_hide_motion_spec.xml&lt;/code&gt;で定義されていることが分かります。MotionSpecは、show/hide用の2種類があり、カスタマイズしたいときは両方とも変更する必要があります。&lt;/p&gt;

&lt;p&gt;まずはshow用のMotionSpecを変更していきます。以下がデフォルトで定義されている&lt;code&gt;design_fab_show_motion_spec.xml&lt;/code&gt;の中身になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;!--
    Copyright 2017 The Android Open Source Project

    Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
--&amp;gt;

&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;opacity&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;scale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;200&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_linear_out_slow_in&amp;quot;/&amp;gt;
  &amp;lt;objectAnimator
      android:propertyName=&amp;quot;iconScale&amp;quot;
      android:startOffset=&amp;quot;0&amp;quot;
      android:duration=&amp;quot;0&amp;quot;
      android:interpolator=&amp;quot;@interpolator/mtrl_fast_out_slow_in&amp;quot;/&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は、アニメーションを長くして、アイコンをバウンドしたいとします。
それは、durationを長くして、interpolatorに&lt;code&gt;@android:anim/bounce_interpolator&lt;/code&gt;を指定すれば良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;set xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;opacity&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;scale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;

  &amp;lt;objectAnimator
    android:duration=&amp;quot;1000&amp;quot;
    android:interpolator=&amp;quot;@android:anim/bounce_interpolator&amp;quot;
    android:propertyName=&amp;quot;iconScale&amp;quot;
    android:startOffset=&amp;quot;0&amp;quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでshow用のMotionSpecが完成しました。hideでも同じようにXMLを定義してあげます。&lt;/p&gt;

&lt;p&gt;次に、これをViewにセットします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fab.showMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_show_motion_spec
)
fab.hideMotionSpec = MotionSpec.createFromResource(
    this,
    R.animator.fab_hide_motion_spec
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的な、アニメーションはこんな感じになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/7iMReht6cMrOlVErQmTAHUTkcsk8GG76aQR1hwVEA_TCnOtrAgCOEoJU8SH6bhzdMcEOv6Z-pWU=w246-h437-no&#34; width=400 /&gt;&lt;/p&gt;

&lt;p&gt;アニメーション時間が長くなり、ボヨンボヨンしていることが分かると思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MotionSpecを使えば、アニメーションの長さやinterpolatorをカスタマイズすることが出来る

&lt;ul&gt;
&lt;li&gt;まだ、MotionSpecに対応しているViewは少ないが、今後Chipなども対応予定😃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>ConstraintLayout Flowの紹介</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-flow/</link>
      <pubDate>Sun, 28 Apr 2019 11:13:20 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/constraintlayout-flow/</guid>
      <description>

&lt;p&gt;ConstraintLayoutの2.0.0 alpha 5にFlow Virtual Layoutが導入されました🎉
Flowを使うことで、対象のViewを様々なルールで並べることができます。&lt;/p&gt;

&lt;p&gt;メリットとしては、次のようなものがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Viewの階層をフラットに保つことが出来る&lt;/li&gt;
&lt;li&gt;Flowは普通のViewのように扱う事ができる&lt;/li&gt;
&lt;li&gt;MotionLayoutと相性が良い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では、どのように書くのかを見ていきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-配置する方向を決める&#34;&gt;1. 配置する方向を決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;android:orientation&lt;/code&gt;から、horizontal or verticalを指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはorientationにhorizontalを持ちます。また、通常のViewのように各constraintsを指定し、配置することができます。&lt;/p&gt;

&lt;h3 id=&#34;2-wrapmodeを決める&#34;&gt;2. wrapModeを決める&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;flow_wrapMode&lt;/code&gt;で指定することができます。&lt;/p&gt;

&lt;p&gt;wrapModeでは、どのようにViewを並べるかを指定でき、3種類のmodeがあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;none

&lt;ul&gt;
&lt;li&gt;単純にsingle lineに並べる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;chain

&lt;ul&gt;
&lt;li&gt;単純に順番に配置していく。その行（列）に収まらない場合は次の行（列）に配置する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;aligned

&lt;ul&gt;
&lt;li&gt;各要素を整列するように配置していく。テーブルのようなイメージ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはchainで対象のViewを配置します。&lt;/p&gt;

&lt;h3 id=&#34;3-対象のviewを指定する&#34;&gt;3. 対象のViewを指定する&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;constraint_referenced_ids&lt;/code&gt;から指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
  android:layout_width=&amp;quot;match_parent&amp;quot;
  android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

  &amp;lt;androidx.constraintlayout.helper.widget.Flow
    android:id=&amp;quot;@+id/flow&amp;quot;
    android:layout_width=&amp;quot;0dp&amp;quot;
    android:layout_height=&amp;quot;0dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    app:flow_wrapMode=&amp;quot;chain&amp;quot;
    android:background=&amp;quot;@android:color/white&amp;quot;
    app:constraint_referenced_ids=&amp;quot;title1,title2,title3&amp;quot;
    app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
    app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
    app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
    app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title1&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain1&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title2&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain2&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

  &amp;lt;TextView
    android:id=&amp;quot;@+id/title3&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:text=&amp;quot;chain3&amp;quot;
    android:textColor=&amp;quot;@android:color/black&amp;quot;
    android:textSize=&amp;quot;50sp&amp;quot; /&amp;gt;

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、「title1、title2、title3」が対象のViewになります。また、これらのViewはhorizontalの方向に、chainで順々に配置されます。&lt;/p&gt;

&lt;h3 id=&#34;4-その他-細かい調整&#34;&gt;4. その他、細かい調整&lt;/h3&gt;

&lt;p&gt;対象のView間のマージンや、行（列）の最大数、Viewの配置場所などの細かい部分の指定ができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;app:flow_horizontalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_verticalStyle = &amp;ldquo;spread|spread_inside|packed&amp;rdquo; (default spread)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_verticalBias = &amp;ldquo;float&amp;rdquo; (default 0.5)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_verticalGap = &amp;ldquo;dimension&amp;rdquo; (default 0)&lt;/li&gt;
&lt;li&gt;app:flow_horizontalAlign = &amp;ldquo;start|end|center&amp;rdquo; (default center)&lt;/li&gt;
&lt;li&gt;app:flow_verticalAlign = &amp;ldquo;top|bottom|center|baseline” (default center)&lt;/li&gt;
&lt;li&gt;app:flow_maxElementsWrap = &amp;ldquo;integer&amp;rdquo; (default : 0, not applied)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にMotionLayoutとFlowの使いかたについて見ていきます。&lt;/p&gt;

&lt;h2 id=&#34;motionlayout&#34;&gt;MotionLayout&lt;/h2&gt;

&lt;p&gt;これは通常のMotionLayoutの使い方と一緒です。Flowの値を変更してあげればよいです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;MotionScene xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
  xmlns:motion=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot;&amp;gt;

  &amp;lt;Transition
    android:id=&amp;quot;@+id/transition&amp;quot;
    motion:constraintSetEnd=&amp;quot;@+id/end&amp;quot;
    motion:constraintSetStart=&amp;quot;@+id/start&amp;quot;
    motion:duration=&amp;quot;1000&amp;quot; /&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/start&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;0dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;horizontal&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;

  &amp;lt;ConstraintSet android:id=&amp;quot;@+id/end&amp;quot;&amp;gt;
    &amp;lt;Constraint
      android:id=&amp;quot;@id/flow&amp;quot;
      android:layout_width=&amp;quot;200dp&amp;quot;
      android:layout_height=&amp;quot;0dp&amp;quot;
      android:orientation=&amp;quot;vertical&amp;quot;
      motion:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot;
      motion:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;
  &amp;lt;/ConstraintSet&amp;gt;
&amp;lt;/MotionScene&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのアニメーションになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/qn9Xbhr9pqrmsJEzQ2YfhzSnJS1I9HpR_s6_UrCSxoqRHQQQ32unFB3G4ls72OuMLuIclSZ89-8=w246-h437-no&#34; width=400&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ConstraintLayout alpha5になってFlowが入った。かなり便利に使えそう

&lt;ul&gt;
&lt;li&gt;いろいろ指定できるので、実際に触って動かしてみるのが良いと思います。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;betaはGoogle I/O前後に来るらしいので、正式版までもう少し😃&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/camaelon/constraintlayout-2-dot-0&#34;&gt;ConstraintLayout 2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://androidstudio.googleblog.com/2019/04/constraintlayout-200-alpha-5.html&#34;&gt;ConstraintLayout 2.0.0 alpha 5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Kotlin: プロパティの変更を検知する</title>
      <link>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</link>
      <pubDate>Wed, 24 Apr 2019 02:21:47 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</guid>
      <description>

&lt;p&gt;オブジェクト自身の変更ではなく、対象のオブジェクトが持つプロパティの変更を汎用的に検知する方法の紹介です。&lt;/p&gt;

&lt;p&gt;次が、この記事で紹介したいコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 1つのプロパティの変更を検知したい
fun &amp;lt;S, A1&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(prop1: KProperty1&amp;lt;S, A1&amp;gt;): LiveData&amp;lt;A1&amp;gt; =
  this
    .map { prop1.get(it) }
    .distinctUntilChanged()

// 2つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;
): LiveData&amp;lt;Pair&amp;lt;A1, A2&amp;gt;&amp;gt; =
  this
    .map { prop1.get(it) to prop2.get(it) }
    .distinctUntilChanged()

// 3つのプロパティの変更を検知したい
fun &amp;lt;S, A1, A2, A3&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(
  prop1: KProperty1&amp;lt;S, A1&amp;gt;,
  prop2: KProperty1&amp;lt;S, A2&amp;gt;,
  prop3: KProperty1&amp;lt;S, A3&amp;gt;
): LiveData&amp;lt;Triple&amp;lt;A1, A2, A3&amp;gt;&amp;gt; =
  this
    .map { Triple(prop1.get(it), prop2.get(it), prop3.get(it)) }
    .distinctUntilChanged()

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KProperty1はKotlinが提供しているインターフェースで、プロパティの値を取得することが出来ます。
それと、LiveData ktxに追加された&lt;code&gt;distinctUntilChanged&lt;/code&gt;を組み合わせることで、汎用的に特定のプロパティの変更を検知することが可能です。&lt;/p&gt;

&lt;p&gt;この記事ではLiveDataを使いましたが、RxJavaやCoroutineでも同じような感じで書けると思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次にサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Presenter(initializeUser: User = User(name = &amp;quot;init&amp;quot;, age = 0)) {
  val user = MutableLiveData&amp;lt;User&amp;gt;(initializeUser)

  // nameの変更を検知する
  val watchUserName = user.watch(User::name)
  // ageの変更を検知する
  val watchUserAge = user.watch(User::age)
}

--- 以下main ---

val presenter = Presenter()

// 監視
presenter.watchUserName.observe(this) {
  Log.d(&amp;quot;watchUserName&amp;quot;, it)
}
presenter.watchUserAge.observe(this) {
  Log.d(&amp;quot;watchUserAge&amp;quot;, it.toString())
}

// 適当にUserを更新
presenter.user.postValue(User(name = &amp;quot;posted1&amp;quot;, age = 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、Userのnameプロパティだけが変更されているので、&lt;code&gt;presenter.watchUserName&lt;/code&gt;に登録したObserverのみが発火します。
変更が加わったプロパティだけを無事検知することができました😃&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多くのデータを持ったオブジェクトの一部の変更のみ検知したい時に使うと便利かもしれない😋&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;内容におかしい点や、もっとこうしたほうがいいよって！！いうのがあればTwitterなどから教えてもらえればとても嬉しいです😊&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>