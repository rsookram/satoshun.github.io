<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on stsnブログ</title>
    <link>https://satoshun.github.io/blog/</link>
    <description>Recent content in Blogs on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Thu, 12 Jul 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://satoshun.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。 https://kotlinlang.org/docs/reference/type-aliases.html
典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。
typealias MyHandler = (Int, String, Any) -&amp;gt; Unit  さらにtypealiasは、アノテーションをつけることも出来ます。
typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;  JvmSuppressWildcardsはDagger(参考リンク)やretrofit(参考リンク)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。</description>
    </item>
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>Daggerを使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。 Androidでは、すべてのActivityで共通のインスタンスを使うには SingletonスコープとAppComponentを組み合わせて使う方法がよく知られています。 しかし、特定のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。SingletonだとすべてのActivity間で共通のインスタンスが使えてしまいます。
この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。 また、基本的なDaggerの使い方は知っている前提で説明していきます。
サンプルコードはこちらになります。 コードを見ると理解がより深まると思うので、ぜひご覧になってください😊
では説明していきます。今回のサンプルコードの目指すところは
 UserScopeを定義し、MainActivity、UserScopedActivityで同一のUserManagerインスタンスを使用する  とします。
まず最初にUserScopeを定義します。
@Scope @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) annotation class UserScope  次にUserSubcomponentを作ります。
@UserScope @Subcomponent interface UserSubcomponent { @Subcomponent.Builder interface Builder { fun build(): UserSubcomponent } val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; }  ここでは、UserSubcomponentにUserScopeスコープを持たせています。 このように書くことで、SubcomponentとScopeを結びつけることが出来ます。
次にAppComponentを作ります。
@Singleton @Component( modules = [ AndroidSupportInjectionModule::class ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; { @Component.Builder interface Builder { @BindsInstance fun application(application: App): Builder fun build(): AppComponent } override fun inject(app: App) // AppComponentとUserSubcomponentを結びつける val userComponentBuilder: UserSubcomponent.</description>
    </item>
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。 ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。
このライブラリの機能に、safeargsというものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。
safeargsを使ってみる 一般的にFragmentに適当な値を渡すときはBundleを通して渡します。
// 呼び出し側 val bundle = Bundle() bundle.putInt(&amp;quot;step&amp;quot;, 10) // 呼び出され側 val step = arguments?.getInt(&amp;quot;step&amp;quot;)  これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&amp;quot;step2&amp;quot;にしてしまうと、ランタイムエラーになります。
これを解決にするためにNavigationではsafe argsという機能を提供しています。 これは、DataBindingのように、クラスを生成することでtypesafeを実現します。
&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt; &amp;lt;fragment android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot; android:label=&amp;quot;Hoge&amp;quot;&amp;gt; &amp;lt;argument android:name=&amp;quot;step&amp;quot; app:type=&amp;quot;integer&amp;quot; android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt; &amp;lt;/fragment&amp;gt; &amp;lt;/navigation&amp;gt;  とnavigationを記述すると、
public class HogeFragmentArgs { private int step = 1; private HogeFragmentArgs() { } public static HogeFragmentArgs fromBundle(Bundle bundle) { HogeFragmentArgs result = new HogeFragmentArgs(); if (bundle.containsKey(&amp;quot;step&amp;quot;)) { result.</description>
    </item>
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。 適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。
定義は以下のようになります。
fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; { // skip用の初期値を入れておく return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null } } fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) { // 最初の値は常にskipすることで、キャッシュを無視する val firstIgnore = AtomicBoolean(true) this.observe(owner, Observer { if (firstIgnore.getAndSet(false)) return@Observer observer(it) }) }  使う時はこんな感じで使います。
// TestViewModel.kt class TestViewModel: ViewModel() { val errorEvent = singleLiveData&amp;lt;String&amp;gt;() } // TestActivity.kt testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java) testViewModel.errorEvent.observeSingle(activity) { Log.d(&amp;quot;one&amp;quot;, it.toString()) }  メリットはサブクラスを作らずに済むところです。
参考  https://github.</description>
    </item>
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description> CoroutineBindingライブラリを作ったのでその紹介です。 https://github.com/satoshun/CoroutineBinding
Android開発でCoroutineの流れが来ていると思っていて、RxBindingのような感じで、 CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。
使い方 例えばclickのイベントを受け取りたいとします。 CoroutineBindingでは以下のように書くことが出来ます。
val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root) launch(UI) { for (click in root.clicks()) { Log.d(&amp;quot;clicked&amp;quot;, click.toString()) } }  RxBindingのように使うことが出来ます! 他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。
まとめ  Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい! https://github.com/satoshun/CoroutineBinding 何かあればissueや、PRを貰えると嬉しいです  </description>
    </item>
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。
まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。 振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。
型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。
人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。

to be continued.</description>
    </item>
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description> ポエムです。
結論 基本的にローカルで明示的に型を宣言するのは好ましくない
問題 Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。
val userName = dataSource.getUserName()  型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。
Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。
まとめ  ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする  </description>
    </item>
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>問題 Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。
理由としては、Data Bindingの生成が失敗すると、MainActivityBindingみたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。 デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)
解決法 全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです
kapt { javacOptions { option(&amp;quot;-Xmaxerrs&amp;quot;, 5000) } }  これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。
これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。
before(一部ログ修正しています)
... // 長いエラーログ ... ... symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:91: error: cannot find symbol @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:102: error: cannot find symbol @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding :app:kaptProductDebugKotlin FAILED  after</description>
    </item>
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。
例えば以下のようなActivityがあるとします。
class HogeActivity : Activity() { ... ... private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  これを見た時、「なんで loginCount &amp;lt;= 100にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。
class HogeActivity : Activity() { private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。
ただ、自分の考えでは上記のコードは根本的に間違っていると思っていて、そもそもActivityでコメントが必要なほど複雑なことをしているのが問題だと思います。 なんでActivityで複雑なことをしてはいけないかというと、ActivtyはContextにアクセスできたりと、なんでも出来るからです。なんでも出来る層でいろいろやってしまうと、 いわゆるfat activity問題が起こってしまいます。</description>
    </item>
    
    <item>
      <title>DroidKaigi2018で「なんとなく動いているProguardから脱出するために」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2018/02/droidkaigi-2018/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/02/droidkaigi-2018/</guid>
      <description>DroidKaigi2018でセッションが採択されたので発表しました。
 https://goo.gl/S95MJs
正直、Proguardは目新しいトピックでないのでそんなに聞きに来てくれないだろうなと思っていました。 しかし、Room3という広い部屋が割り当てられて、さらに当日はかなりの人が聞きに来てくれました。本当に聞きに来てくれた人ありがとうございます😊😊😊
Twitterの反応を見る限りだと、分かりやすいと言っている人が多くいたので嬉しかったです。 Proguardは苦手意識を持っている人が多いと思っていて、なのでstep by stepで順序良く聞けるような発表を心掛けたのでその効果が少しは出たのかなと思っています。
反省点としては、自分が想定したより時間に余裕があったので何か面白いことを喋ろうとしたら何も思いつかないでフガフガしてしまったところです。 今後はフガフガせずに、アドリブ力みたいなものを身につけていきたいと思います!
あと、もう一つ反省点としてすべるのが怖くて積極的にネタみたいなものをスライドに入れられなかったことです。一応考えていたものは
 「Self-Styled Proguardエバンジェリストです」と自己紹介しようとした。 僕の発表資料はProguardに失敗してやや冗長になってしまいましたけど、みなさんのAPKサイズはProguardに成功して小さくなることを期待しています。みたいなことを言おうとした。  みたいなことを言って笑いを取りたかったなと後悔しています(笑いを取れるとは言っていない)。
来年もDroidKaigiあるとしたらCfP出してまた登壇できるように頑張ります。 そして運営の皆さん本当にありがとうございました。凄い楽しかったです(•ө•)♡</description>
    </item>
    
    <item>
      <title>Android: ViewがどのFragmentに属しているかをViewから取得する</title>
      <link>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</guid>
      <description>ViewがどのFragmentに属しているかを取得する方法の紹介になります。 前々からtag、id以外の仕組みで取得出来ないかなと考えていたら、GlideでViewからFragmentを取得するコードがありました。
@Nullable private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) { tempViewToSupportFragment.clear(); findAllSupportFragmentsWithViews( activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment); Fragment result = null; View activityRoot = activity.findViewById(android.R.id.content); View current = target; while (!current.equals(activityRoot)) { result = tempViewToSupportFragment.get(current); if (result != null) { break; } if (current.getParent() instanceof View) { current = (View) current.getParent(); } else { break; } } tempViewToSupportFragment.clear(); return result; } private static void findAllSupportFragmentsWithViews( @Nullable Collection&amp;lt;Fragment&amp;gt; topLevelFragments, @NonNull Map&amp;lt;View, Fragment&amp;gt; result) { if (topLevelFragments == null) { return; } for (Fragment fragment : topLevelFragments) { // getFragment()s in the support FragmentManager may contain null values, see #1991.</description>
    </item>
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description> LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。
package android.arch.lifecycle; public abstract class LiveData&amp;lt;T&amp;gt; { protected void onActive() { } }  onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。
package android.arch.lifecycle fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる }  同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。
package android.arch fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // コンパイルエラー &amp;quot;Cannot access &#39;onActive&#39;: it is protected in &#39;LiveData&#39;&amp;quot; }  なぜかこのような挙動になるか? protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。
まとめ protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう
参考  https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a  </description>
    </item>
    
    <item>
      <title>Android: MVP, Dagger2, Retrofitなどなどでアプリを作りました</title>
      <link>https://satoshun.github.io/2015/09/android-app-events/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/09/android-app-events/</guid>
      <description>イベントを検索するAndroidアプリを作成したので, 使った技術のまとめです.
アプリの技術的機能, 特徴は以下になります.
 HTTPを介してイベントのデータを取得する  検索対象のサーバは複数あるため(今回は3つ), どこかでそれらのレスポンスデータを同期する必要がある それら複数のサーバーはJSONを返すが, 微妙にJSONの構造が異なる  Data-Bindingライブラリを使う MVP(Model-View-Presenter)パターンを使う  Activity(Fragment)に機能が集中しないようにしたい!   上記を中心にどのように実装をしたかを説明をしていきます.
フルソースコードはここにあります. https://github.com/satoshun/AndroidEvents
HTTPを介してイベントのデータを取得する connpass, Atnd, Zusaarの3つのAPIを使うことにしました. RetrofitでAPIを定義し, JSONのパースにはGson, データの処理にはRxJavaを使いました.
例えば, connpass APIは以下のように定義しました.
/** Get data from Conpass */ public interface Connpass { @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;keyword&amp;quot;) String keyword, @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); }  keywordとymdを指定してリクエストを生成します. 「2015/12/31のAndroidのイベント」のように使う想定です. Retrofitを使うと, このようにinterfaceとして, APIを定義することが出来ます. (https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/network/Connpass.java#L10)
次に, RxJavaの説明をします. RxJava(Observable)を使うと, 非同期にデータが扱いやすくなります. またデータのマージ(merge)や, フィルタリング(filter)などを簡単に行うことが出来ます.</description>
    </item>
    
    <item>
      <title>Improving Android: 列挙にはenumではなくIntDef, StringDef annotationを使う</title>
      <link>https://satoshun.github.io/2015/08/improve-android-performance1/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/08/improve-android-performance1/</guid>
      <description>enumの典型的な使い方として, 月(month)や, ネットワークプロコトルなどの, 特定の種類を列挙するために使用されます.
列挙型としてのenumは, 以下のように書くことが出来ます.
enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER } /** 指定した月が何日まであるかを返す */ int getDate(Month month) { //// }  また, enumではなく定数を使うとしたら以下のように書くことが出来ます.
static final int JANUARY = 1; static final int FEBRUARY = 2; static final int MARCH = 3; static final int APRIL = 4; ... static final int NOVEMBER = 11; static final int DECEMBER = 12; /** 指定した月が何日まであるかを返す */ int getDate(int month) { //// }  定数を使うバージョンだと, getDate(int)のため, 予期せぬ値が入ってきてしまう可能性があります.</description>
    </item>
    
    <item>
      <title>Android: Picassoで使われているデザインパターン</title>
      <link>https://satoshun.github.io/2015/06/reading_picasso/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/reading_picasso/</guid>
      <description>Picassoで使われているデザインパターンを紹介する記事です.
Singletonパターン Singletonパターンは, インスタンスの生成を1つに制限するパターンになります.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L672
public static Picasso with(Context context) { if (singleton == null) { synchronized (Picasso.class) { if (singleton == null) { singleton = new Builder(context).build(); } } } return singleton; }  Picasso#withは, すでにPicassoのインスタンス singleton が生成されていればそれを返し, 生成されていなければ, インスタンスを生成して返します.
このパターンのメリットは, インスタンスを多くても1つしか作らないのでメモリ的に有利な点です(使い回せる) しかし, singletonなインスタンスは, 複数のクラスから使われる可能性があるので, スレッドセーフである必要があります.
スレッドセーフにするためには, 全てのfieldの値をfinalにする. 排他的制御を入れるなどの方法があります.
Builderパターン Builderパターンはインスタンス生成時に多数のパラメータが必要なときに便利なパターンです.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L702
public static class Builder { private final Context context; private Downloader downloader; private ExecutorService service; private Cache cache; private Listener listener; private RequestTransformer transformer; private List&amp;lt;RequestHandler&amp;gt; requestHandlers; private Bitmap.</description>
    </item>
    
    <item>
      <title>心理学: 人間は合理的な判断は出来ない</title>
      <link>https://satoshun.github.io/2015/06/anchoring_effect/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/anchoring_effect/</guid>
      <description>人間は合理的な判断をしているようで, 実はそんなにしていないという話をします.
例: 値引き商品 普段, 1,000円のとんかつ定食があるとします. その日は割引セールで40%OFFの600円になっていました. この時に本来は, 「このとんかつ定食が600円」が高いかどうかで判断を下さないといけません. しかし, 脳では「普段より400円安い!お得!!」と判断し, お得なとんかつ定食を選ぶ可能性があがります.
この現象を, アンカリング効果(Anchoring effect)と呼びます. 1,000円がアンカー(一種の基準)になり, 600円を非常にお得と判断してしまいます. 例えば, 隣の店で全く同じとんかつ定食が600円で売られているとしても, こちらのとんかつ定食がお得だと判断します. これは合理的な判断とはいえません.
ものを販売する時はアンカーを意識して値段設定すると, ユーザの心を揺さぶることが出来ます.
合理的に判断するなら, 割引前の値段には影響を受けてはダメです. メーカーは定価を高めに設定しています. 冷凍食品なんかは常に割引セールをしています.
例: 全く無関係な数字 「値引き商品だったら, なんとなく影響を受けている気がする」という人は多いと思います. しかし, 全く無関係な数字にも人間は影響を受けます.
事前に10 or 50という数字を見せられているとします. 次にAndroid5.0のシェア率答えてもらいます. この時, Android5.0のシェア率に関してなんら情報を持っていなければ, 10 or 50という数字に大きく影響を受けることが分かっています. これは10 or 50という数字が基準(アンカリング)とし, 正解だと思う数字に調整するためです.
これは, 直感的には「そんなことないよと」言いたいところですが, 多くの人間が無関係な数字に影響を受けるようです.
合理的に判断するなら, 事前の数字に影響を受けてはダメです. しかし, よほど意識しない限り人間の脳は無関係な数字にも影響を受けてしまいます.
例: いろいろなレンジ帯の商品群 ある高級マットレスA,Bがあるとします. マットレスAは78,000円, マットレスBは128,000円の時に, マットレスBを選ばせるためにはどうするのがよいでしょうか? それは, マットレスC 488,000円を売り出すことです.
マットレスA 78,000円, マットレスB 128,000円, マットレスC 488,000円とあると, マットレスAだと安すぎて不安, マットレスCだと高すぎるし, ちょうど中間帯のマットレスBを買おうと誘導することが出来ます.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>概要 この記事では, JakeWhartonさんのu2020から, AndroidでDagger2を使うときの実践的な方法を紹介します. u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.
DI, Dagger2の基本について知りたい方は, Part1を見て下さい.
目次
 debugとproductionでModuleを切り替える Debug専用のViewを作る Mockモードの定義 -　まとめ  debugとproductionでModuleを切り替える gradleは, productFlavorsを設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります. そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています. 具体的には,
 /src/production/java/com/jakewharton/u2020/Modules.java /src/internalDebug/java/com/jakewharton/u2020/Modules.java /src/internalRelease/java/com/jakewharton/u2020/Modules.javaに  それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています. これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.
こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.
 Debugのみログを有効にしたい APIのエンドポイントを変えたい debug専用のViewを出したい Test用のインスタンスをinjectしたい etc, etc&amp;hellip;  以下では, より細かく説明していきます.
Debug専用のViewを作る u2020では, Debug専用のView DebugAppContainerがあります. Debug専用のView はこんな感じです. Debugビルドの時は, このContainerをinjectしています.
DebugAppContainerは簡単にいえば, DrawerLayoutを1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.
Mockモードの定義 u2020ではMockモードがあり, Mockデータを表示機能があります.
public final class DebugDataModule { .</description>
    </item>
    
    <item>
      <title>ReactiveX: Hot, Coldの違い</title>
      <link>https://satoshun.github.io/2015/05/hot_cold/</link>
      <pubDate>Fri, 22 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/hot_cold/</guid>
      <description>ReactiveXにおける, Cold/Hot Observableの違いを説明します.
(本文中の「subscribeする」と, 「Observerを登録する」は同義です.)
Cold Observable Cold ObservableはSubscribeされると動作を開始します.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });  例えば, 上のコードだと, sourceを定義した時点ではストリームが生成されておらず, source.subscribeされた時に, 初めてストリームが生成されます. 遅延評価(lazy evaluation)のような振る舞いをします.
次に, 1つのCold Observableに対して複数subscribeしたとします.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); source.subscribe(function(x) { console.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. 基本編 Part1</title>
      <link>https://satoshun.github.io/2015/05/dagger2/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2/</guid>
      <description>概要 この記事では, 最初にDIとは何かについて説明します. DIを理解した後にDagger2の基本的な使い方を紹介します. Dagger2はDI(Dependency Injection)をするライブラリです.
DIとは? DIとはDependency Injectionの略で, 訳すと「依存性の注入」です. ここでいう依存とは クラス同士の依存関係のことを表します. クラス同士の依存関係は, 委譲パターンの時に現れます.
例えば, 以下のコードがあったとします.
class Blogger { public Blogger() { } public void post(String title) { // 何かメインの処理 // ... // fileにlogを取る FileLogger logger = new FileLogger(title); logger.logging(); } } class FileLogger implements Logger { @Override public void logging(String... messages) { // fileにmessagesを書き出す File file = new File(&amp;quot;hoge.txt&amp;quot;); ... } } interface Logger { void logging(String messgae); }  クラスBloggerはクラスFileLoggerに依存している.</description>
    </item>
    
    <item>
      <title>Python: Pythonライクな書き方 Part1</title>
      <link>https://satoshun.github.io/2015/04/python-beautiful/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/python-beautiful/</guid>
      <description>Pythonライクな書き方について紹介します. Part1です.
for文関連 indexを使いたいとき Bad: range, lenを使う
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] for i in range(len(names)): print i, names[i]  Good: enumerateを使う
for i, name in enumerate(names): print i, name  2つのコレクションを扱うとき Bad: indexを使ってアクセスする
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] ages = [12, 19, 11] for i in range(min(len(names), len(ages))): print names[i], ages[i]  Good: 組み込み関数zipを使う
for name, age in zip(names, ages): print name, age  dictionaryでkey, valueを使う Bad: keyでアクセス, valueを取得する</description>
    </item>
    
    <item>
      <title>Android: AndroidKaigiまとめ</title>
      <link>https://satoshun.github.io/2015/04/droid-kaigi/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/droid-kaigi/</guid>
      <description>AndroidKaigiの記事まとめです.
DroidKaigi - Welcome talk   DroidKaigi - Welcome talk  from mhidaka
エンジニアのための勉強会をやるよ!みたいな内容
Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法   Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法 -  from Yuki Anzai 
CardboardのUXをカメラで向上する   CardboardのUXをカメラで向上する (droidkaigi 2015&amp;frasl;04)  from Kenichi Takahashi 
絶対落ちないアプリの作り方 あるゲームアプリケーションの構成とアップデートサイクル   あるゲームアプリケーションの構成とアップデートサイクル  from Kentaro Iizuka 
開発を効率的に進めるられるまでの道程   開発を効率的に進めるられるまでの道程  from Takao Sumitomo 
アプリの企画、プロトタイプからリリースに至るまで   初学者に嬉しいAndroid開発環境   【DroidKaigi2015】初学者に嬉しいAndroid開発環境(あとMVCとか)  from Hiroyuki Kusu</description>
    </item>
    
    <item>
      <title>データベース: RDBと第1~3正規形について</title>
      <link>https://satoshun.github.io/2015/04/normalization/</link>
      <pubDate>Sun, 19 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/normalization/</guid>
      <description>正規形は, リレーショナルデータベース設計における理論の1つです. 正規化を行うことで, データの重複をなくし, 効率良くデータを保持することが出来ます.
この記事では, リレーショナルデータベースについて説明し, 第1-3正規化について説明します.(BCNF, 第4-6正規化は次の記事で説明します)
リレーショナルデータベースモデル(RDB)について 最初にリレーションについて説明します. リレーションは見出し(heading)と本体(body)からなります. 見出しは, SQLでいうところの属性に相当します. 例えば, 生徒なら下のようなデータを持つと考えられます.
   学生番号 名前 年齢     001 田中 17   002 多田野 19   003 木下 19   004 西岡 18    上記表がリレーションの一例になります. {学生番号, 名前, 年齢}が見出し, {{001, 田中, 17}, {002, 多田野, 19}, {003, 木下, 19}, {004, 西岡, 18}}が本体になります. ここで{}を使っているのは, リレーショナルにおける見出し, 本体はそれぞれタプルで表現されるためです. そのため各要素には順序が存在せず, 重複が許されません(重複があっても意味がない).
ここで集合という言葉が出てきましたが, RDBは集合論 に基づいた理論です.</description>
    </item>
    
    <item>
      <title>データベース: 履歴データについて</title>
      <link>https://satoshun.github.io/2015/04/history_data/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/history_data/</guid>
      <description>RDBで履歴データを保持する方法についてまとめました. そもそも履歴データは, リレーショナルモデルとは相性が悪いので, これが正解!みたいなものはないです.
履歴データとは? スーパーの商品の値段のように, 時間の経過とともに属性の値が変化していくデータがあります. そのようなデータを履歴データと呼びます.
フラグを付ける 最初に一番オーソドックス?な, フラグをつけて管理する方法です.
productsテーブル
   id name price active     1 卵 200 0   2 卵 250 1   3 肉 100 1    activeなデータを取得するときは, SELECT * FROM products WHERE active = 1; とします.
この方法の利点はパッと見に分かりやすいことだと思います. しかし, この方法はバッドノウハウだとされています. 理由を以下にあげます.
 activeフラグはカーディナリティが低く効率が悪い テーブルサイズが時間ともに肥大化し, 検索効率が下がる恐れがある activeの更新は, アプリ側 もしくは, トリガーで制御しなければいけない  単純で分かりやすいですが, あまり使わないほうが良い方法のようです.
範囲を指定する 次は範囲を指定する方法です.</description>
    </item>
    
    <item>
      <title>[ERROR] InnoDB: Cannot allocate memory for the buffer pool の対処法</title>
      <link>https://satoshun.github.io/2015/04/mysql_memory_error/</link>
      <pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/mysql_memory_error/</guid>
      <description>上記のエラーが出たらメモリ不足なので, スワップ領域を作るのが良いと思います.
## swap領域の確認 $ swapon -s Filename Type Size Used Priority ## swap領域の確保 $ sudo dd if=/dev/zero of=/swapfile bs=1024 count=1024k ## swap領域の作成 $ sudo mkswap /swapfile ## swap領域の割り当て $ sudo swapon /swapfile $ swapon -s Filename Type Size Used Priority /swapfile file 1048572 4320 -1 $ free total used free shared buffers cached Mem: 760132 689248 70884 4672 7740 48944 -/+ buffers/cache: 632564 127568 Swap: 1048572 88556 960016 ## 再起動時にもswapを割り当てるように設定 $ sudo vi /etc/fstab  これでおｋ.</description>
    </item>
    
    <item>
      <title>Android: FragmentPagerAdapterでハマった話</title>
      <link>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</guid>
      <description>ハマったのでメモ. 以下のことをしたかった.
 データ取得するまで, Fragment内でProgress Barを出力 ネットワークからデータを取得し, Fragment内にあるAdapterのデータ更新 UIに反映  notifyDataSetChangedメソッドが効かない データが更新した後に FragmentPagerAdapter#notifyDataSetChangedメソッドを叩けばFramentが再生成されるんでしょ?と思っていた時期が僕にもありました. notifyDataSetChangedメソッドを叩いても, データがUIに反映されず, ProgressBarが表示されたままでした.
FragmentPagerAdapterでは, 基本的に一度作られたFragmentは削除されず, notifyDataSetChangedメソッドでデータを更新したよーと知らせても, Fragmentを再生成してくれません.(仕様通り)
これはどうしたものかと思っていろいろ調べたところ, FragmentStatePagerAdapterクラスにいきつきました.
FragmentStatePagerAdapterを使う FragmentPagerAdapterでなくて, FragmentStatePagerAdapterを使えばUIにデータが反映されました.
以下, 実装例になります. まずは, ダメパターンです. FragmentPagerAdapterクラスを使い, Activityでデータを受け取ったら, refreshメソッドを叩くようになっています.
public class PagerAdapter extends FragmentPagerAdapter { ... ... public void refresh() { notifyDataSetChanged(); } }  FragmentPagerAdapterがスーパークラスになっているため, notifyDataSetChangedを何度叩いても, Fragmentが再生成されることはありません. つまり, データを更新した後にUIにデータが反映されません.
次にOKパターンです. FragmentStatePagerAdapterを使い, getItemPositionをOverrideするのがポイントです.
public class PagerAdapter extends FragmentStatePagerAdapter { private List&amp;lt;Fragment&amp;gt; mFragments; ... ... @Override public int getItemPosition(Object object) { Fragment target = (Fragment) object; if (mFragments.</description>
    </item>
    
    <item>
      <title>HTML5: Shadow DOMについて</title>
      <link>https://satoshun.github.io/2015/03/shadow_dom/</link>
      <pubDate>Sat, 14 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/shadow_dom/</guid>
      <description>Web Componentsの機能の一つ Shadow DOMについて説明します.
Shadow DOMとは? 外部から影響を受けない, 外部に影響を与えない隔離された要素です. 「カプセル化されたHTML要素」みたいな感じです.
Shadow DOMの誕生背景 なぜShadow DOMが出てきたかについて説明します.
CSS, JavaScriptは, 全要素に対して影響が及ぶという性質があります.(グローバルに影響を与える) ある箇所を修正したら, 予期せぬ箇所にも影響が出てしまうことがよく起こりますが, これはバグを生み出しやすくとてもよくないです. 例をあげると,
.hoge { font-size: 30px; }  と書くと, hogeをclass属性に持つ要素の文字サイズが30pxになります. 偶然にも他の部分でhogeクラスセレクターを使っていたとしたらそのセレクターにも影響を与えてしまいます. 仮に, 他の人が作ったコンテンツが隔離されて使用できれば, 同じセレクターを使ったとしても, 問題がなくなります.
フロント側が年々複雑になったことにより, スタイルシート, JavaScriptが肥大化した結果, コンテンツを互いに隔離したいという要望が高まり, Shadow DOMが誕生しました.
使い方 Shadow DOMを作るにはcreateShadowRootAPIを使います. 以下, Shadow DOM版Hello Worldです.
&amp;lt;div id=&amp;quot;shadow&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function insertShadow() { // Shadow DOMの作成 var shadow = document.querySelector(&#39;#shadow&#39;).createShadowRoot(); shadow.textContent = &#39;Hello world&#39;; } insertShadow(); &amp;lt;/script&amp;gt;  Shadow DOMが挿入され, Hello Worldと表示されます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Value Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-valueobject/</link>
      <pubDate>Sun, 22 Feb 2015 04:53:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-valueobject/</guid>
      <description>Value Object(値オブジェクト)は, メンバとメソッドを持ちクラスとしての特徴を持つが, immutableであり, identityキー(RDSでいうところのautoincremental id)を持たないオブジェクトのことです. 異なるオブジェクト同士であっても値が等しければ等しいとみなされます. immutableなので, primitive(int, floatなど)な値と同等に扱うことが出来ます.
immutableであるメリット immutableであるメリットとしては
 状態を持たないので, 呼び出し順序を考慮しなくて良い 値が書き換わらないため, thread safeである プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来ることが多い  1, 2つ目は理解できると思うので, 「プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来る」をJavaのコードをあげて説明します.
public static Calendar getYesterday() { Calendar rightnow = Calendar.getInstance(); // ここの時点ではrightnowは, 今の時間を示している rightnow.add(Calendar.DATE, -1); // ここの時点ではrightnowは, 昨日を示している. 変数名rightnowは相応しくない return rightnow; }  上記コードは, 変数rightnowを定義した段階では, 相応しい変数名なのですが, rightnow.add(Calendar.DATE, -1)を実行した段階で, 相応しくない変数名に変わります. これは, Calendarインスタンスが, mutableなためです. このようなコードは混乱を招きます. オブジェクトは初期化したら, セッターなどで値は変更しないほうが, コードをreadableに保つことができ, バグを防ぐことが出来ます.
indentityキーを持たないメリット Value Objectは, 名前の通り, Value(値)に注目しているパターンです. 量などの属性値が重要であり, identityキーには注目していないため, 除去しています. 逆に, identityキーに注目しているパターンのことを, エンティティ(Entity)と言います.</description>
    </item>
    
    <item>
      <title>Go: GojiにPRした話</title>
      <link>https://satoshun.github.io/2015/02/go-pr_goji/</link>
      <pubDate>Sun, 22 Feb 2015 04:11:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-pr_goji/</guid>
      <description>Goにハマりつつあります. 最近家ではGo or Androidって感じです.
最近, GoのWEBフレームのソースコードをちょいちょい読んでいて, GojiにPRをしたのでその話.
Goji? Goji is a minimalistic web framework that values composability and simplicity です. SinatraのようなMicro Frameworkになっています.
どこにPRしたか? バグではなくて, こっちのほうがGoライクにだよ!と思ったのでPRをしました. 計2回PRしたので, それぞれ紹介します.
switch type assertion 1つ目は, switch type assertionについてです. switch文の冒頭にある, type assertionの結果を使うようにしました.
--- a/web/pattern.go +++ b/web/pattern.go @@ -32,13 +32,13 @@ type Pattern interface { } func parsePattern(p interface{}) Pattern { - switch p.(type) { + switch v := p.(type) { case Pattern: - return p.</description>
    </item>
    
    <item>
      <title>Android: strings.xmlのまとめ</title>
      <link>https://satoshun.github.io/2015/02/android-resource_string/</link>
      <pubDate>Sun, 22 Feb 2015 04:10:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-resource_string/</guid>
      <description>res/values/strings.xmlは, 文字列関連のリソースを管理するファイルです. 文字列をプログラム外で定義することで, 多国語の対応, デバッグブルドの時にサーバのURLを変更する等が, コードをいじらずに容易に行えます.
また, 意外といろいろな機能があったので, 紹介したいと思います.
基本的な使い方 &amp;lt;string name=&amp;quot;app_name&amp;quot;&amp;gt;Application&amp;lt;/string&amp;gt;  のように記述して使います. アプリケーション側では, 下のように取得します.
getString(R.string.app_name); or context.getString(R.string.app_name);  特に, 説明はいらないと思います.
arrayの定義 strings.xmlでは単純なkey-valueだけでなく, arrayも定義することができます.
string-array要素で定義してあげます.
&amp;lt;string-array name=&amp;quot;sports&amp;quot;&amp;gt; &amp;lt;item&amp;gt;マラソン&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;野球&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;サッカー&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;卓球&amp;lt;/item&amp;gt; &amp;lt;/string-array&amp;gt;  アプリケーション側では下のように取得します.
getResources().getStringArray(R.array.sports) or context.getResources().getStringArray(R.array.sports)  Contextから直接取得することが出来ないので, 一旦Resourcesを取得し, そこからarrayを取り出します.
値展開 strings.xmlでは, 文字列展開することが出来ます. printf formatのように使います.
&amp;lt;!-- %1: 引数1, $d: 数字 --&amp;gt; &amp;lt;string name=&amp;quot;hoge&amp;quot;&amp;gt;Hello %1$d&amp;lt;/string&amp;gt; &amp;lt;!-- %1: 引数1, %2: 引数2, $s: 文字列 --&amp;gt; &amp;lt;string name=&amp;quot;hogestr&amp;quot;&amp;gt;%1$s %2$d %1$s&amp;lt;/string&amp;gt;  アプリケーション側では, 下のように指定します.</description>
    </item>
    
    <item>
      <title>Android: Pull to Refreshの実装(SwipeRefreshLayout)</title>
      <link>https://satoshun.github.io/2015/02/android-pull_to_refresh/</link>
      <pubDate>Sun, 22 Feb 2015 04:09:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-pull_to_refresh/</guid>
      <description>AndroidでPull to Refreshの実装方法です. ListViewなどを下方向に引っ張ると, データを更新するように出来ます. Gmailとかで使われているあれです.
具体的には, SwipeRefreshLayoutを使って実装します. 以下でコードで説明していきます.
XML側の記述 ListViewに覆いかぶさるように定義します.
&amp;lt;android.support.v4.widget.SwipeRefreshLayout android:id=&amp;quot;@+id/refresh&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt; &amp;lt;ListView android:id=&amp;quot;@android:id/list&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt; &amp;lt;/android.support.v4.widget.SwipeRefreshLayout&amp;gt;  XML側はこれで完了です. これで, ListViewを引っ張ると「Pull to Refresh」のアニメーションが起こります.
Activity側の記述 Pull to Refreshをした時に, イベントが発生するのでListenerを記述します.
実装例です. setOnRefreshListenerでListenerを登録します.
private SwipeRefreshLayout mSwipe; @Override protected void onCreate(Bundle savedInstanceState) { ... mSwipe = (SwipeRefreshLayout) findViewById(R.id.refresh); // Callback登録 mSwipe.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { /* ここに適当な処理を書く */ mSwipe.setRefreshing(false); } }); }  ListViewを引っ張ると, setOnRefreshListenerメソッドがコールされます. setOnRefreshListenerの最後に, setRefreshing(false)をコールします.</description>
    </item>
    
    <item>
      <title>tips: 気軽にローカルにサーバを立てる</title>
      <link>https://satoshun.github.io/2015/02/tips-ser/</link>
      <pubDate>Sun, 22 Feb 2015 02:40:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/tips-ser/</guid>
      <description>サクッとローカルサーバを立てるためのTipsを紹介します.
下記コマンドは, Pythonが入っていれば, 問題なく動きます.
$ python -m CGIHTTPServer Serving HTTP on 0.0.0.0 port 8000 ...  僕は, 上記コマンドをaliasに登録しています.
alias ser=&#39;python -m CGIHTTPServer&#39;  これで, serでサーバが立つようになりました.
ちなみに, Portを指定することも出来ます.
$ ser Serving HTTP on 0.0.0.0 port 8000 ... $ ser 8001 Serving HTTP on 0.0.0.0 port 8001 ...  簡単にローカルサーバを立てることが出来るようになりました.</description>
    </item>
    
    <item>
      <title>CSS: Clearfixについて</title>
      <link>https://satoshun.github.io/2015/02/css-clearfix/</link>
      <pubDate>Sun, 22 Feb 2015 02:32:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/css-clearfix/</guid>
      <description>CSSには「clearfix」と呼ばれるテクニックがあります.
この記事では, なぜclearfixを使うのか, clearfixとは何なのかについて説明します.
floatの問題点 clearfixを説明する前に, floatプロパティの問題点について説明します.
まず例をあげます.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  上記HTMLは, imgが右に寄り, その左側にtest1, test2と表示されます. floatは, 指定したエレメント以降のエレメントを反対側に回りこませることが出来ます.
回りこみを止めたいときは, clear: both;プロパティを指定します.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- clear:bothがないと, このdivも左側に回りこむ --&amp;gt; &amp;lt;div style=&amp;quot;clear:both;&amp;quot;&amp;gt; hogehoge &amp;lt;/div&amp;gt;  clear:both;の記述を忘れると, 後続の意図しないエレメントにも影響を及ぼしてしまうので, 忘れずに指定しなければいけません.
とは言っても, floatingの解除は忘れてしまいがちです. そこでclearfixと呼ばれるテクニックを使います.
clearfixとは clearfixとは, after擬似要素を使いfloatを解除するテクニックです.
具体的には以下のように記述します.
.clearfix:after { content: &amp;quot;&amp;quot;; clear: both; display: block; }  clear: both;をしてくれる要素をafter擬似要素で挿入しているだけです. これを, 親エレメントにつけておけば, floatを解除してくれます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Null Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-null_object/</link>
      <pubDate>Sun, 22 Feb 2015 02:22:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-null_object/</guid>
      <description>Null Objectパターンは, オブジェクト自身にNullかどうかの判定をしてもらうデザインパターンです.
このパターンのメリットは, if (obj == null)のような面倒臭い記述を除去出来るところです. また, ポリモーフィズムにより, nullの時の処理をObjectに委譲することが出来ます. (nullの時の処理を, Objectに持たせることが出来るパターン)
例 例があった方が分かり易いので, 簡単なサンプルプログラムです.
まずは, Null Objectを使わない場合になります.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.format(self.id)) student = Student.get_student(1) if student is not None: student.show() else: print(&#39;not student&#39;)  次にNull objectパターンを使い, if student is not None: を除去します.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.</description>
    </item>
    
    <item>
      <title>AnsibleでGhostアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</guid>
      <description>VPSにGhostを, Ansibleでデプロイしている話.
サーバー側で使っているソフトウェアは, supervisor, nodeです.
GitHubでソース管理 CSS, HTMLを少し弄りたいので, Ghostをforkし, それを編集してデプロイしています.(https://github.com/satoshun/ghost)
このリポジトリを, デプロイしていきます.
デプロイ時の手順 サーバで以下のタスクを行います.
 Gitリポジトリを最新の状態にする(git pull origin master) npm moduleの更新(npm install) gruntの実行(grunt init &amp;amp;&amp;amp; grunt prod) ghostプロセスの再起動(supervisorctl restart ghost)  Playbookは以下になります.
--- - hosts: all user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_source.yml - include: update_package.yml - include: restart.yml  各タスクについて説明していきます.
Git pullする Gitモジュールがあるので, それを使います.
- name: Update Git repository git: repo=&amp;lt;git url&amp;gt; dest=&amp;lt;path to project&amp;gt;  npm moduleの更新 npmモジュールがあるので, それを使います.</description>
    </item>
    
    <item>
      <title>Golang: nil pointer receiverの話</title>
      <link>https://satoshun.github.io/2015/02/go-nil_receiver/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-nil_receiver/</guid>
      <description>nil pointer receiverについてお話しようと思います. 具体例をあげたほうが分かりやすいので, コードを元に説明していきます.
gist: https://gist.github.com/satoshun/3dc1302dbc163c9a9245
にソースコードがあります.
nil pointer receiver nilについて. 下のコードを見てください.
package main import &amp;quot;fmt&amp;quot; type A struct { } func (a *A) b() { fmt.Println(1000) } func main() { var a *A = nil a.b() }  どう考えても, runtime error: nil pointer access 的なものが出るだろうと思っていました.
sato$ go run main.go 1000  ちゃんと実行できました. Goではnilにも型情報があるので, nilの場合でもPointer receiverの場合は実行できるのです! この機能を使えば, Pointer receiverの中でnilの場合に処理を変えることが可能です. 覚えておくと便利だと思います.
ちなみに, Value receiverの場合はエラーが出ます.
package main import &amp;quot;fmt&amp;quot; type A struct { } // b is value receiver func (a A) b() { fmt.</description>
    </item>
    
    <item>
      <title>AnsibleでGoアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-go_deploy/</link>
      <pubDate>Sun, 22 Feb 2015 01:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-go_deploy/</guid>
      <description>ローカルでバイナリを作成し, デプロイするような, Ansible Playbookを書きました. Supervisorでプロセスの管理を行っています.
下の手順でデプロイを行っています.
 Macでコンパイルして, Linux-amd64用のバイナリ生成(注意1) バイナリをサーバにデプロイ(コピー) アプリのリスタート(supervisorで再起動)  実際のPlaybookは以下のようになります.
deploy.yml
--- - hosts: local connection: local tasks: - include: build.yml - hosts: app user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_binary.yml - include: restart.yml  各タスクについて, 説明してきます.
Linux-amd64用のバイナリ生成 Goはデフォルトで, クロスコンパイル出来る機能を持っているので, その機能を使います.
やり方はいろいろあると思うのですが, Makefileを作成して, それをAnsibleから叩くようにして実装しました. Makefileを作る必要ないと思います.
Makefile
get: go get -v build-amd64: get GOOS=linux GOARCH=amd64 go build .  build.yml
--- - name: build src command: make build-amd64 chdir={{ local_home }}  local_homeは変数で, Makefileがあるディレクトリを定義しています.</description>
    </item>
    
    <item>
      <title>様々な言語のフィボナッチ関数</title>
      <link>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</guid>
      <description>Java, JavaScript, Go, Python, Bashでfibonacciを書いてみました.
極力, その言語特有の機能を使って実装するようにしました.
Go type fibonacci intで, int型にfibonacci用の関数を生やしました. せっかくなので, goroutineも使ってみました.
package main import &amp;quot;fmt&amp;quot; type fibonacci int func (self fibonacci) value() chan int { ch := make(chan int, 1) a, b := 0, 1 index := 0 go func() { defer close(ch) for { if int(self) &amp;lt; index { break } a, b = b, a+b index++ ch &amp;lt;- a } }() return ch } func main() { var i fibonacci i = 10 for v := range i.</description>
    </item>
    
  </channel>
</rss>