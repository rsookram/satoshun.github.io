<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on stsnブログ</title>
    <link>https://satoshun.github.io/blog/</link>
    <description>Recent content in Blogs on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Thu, 13 Dec 2018 11:16:06 +0000</lastBuildDate>
    
	<atom:link href="https://satoshun.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってリポジトリにフィルターをかける</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>JitPackからライブラリをインストールしたかったところ、jcenterからライブラリをインストールしてしまう事件がありました。 詳しくは次のリンクを参照してください。A Confusing Dependency
従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1にMatching repositories to dependenciesが導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）
今回の検証にはGradle 5.1-rc-1を使いました。サンプルコードはここにあります
まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、cloudflareのSDKを依存関係に入れることを目指します。
まずは従来の書き方です。
// topのbuild.gradle allprojects { repositories { ... maven { url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot; } } } --- // projectのbuild.gradle dependencies { ... implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot; }  これだと全てのライブラリに対して https://storage.googleapis.com/cloudflare-maven/public/のチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対しては制限をかけたいところです。
次に新機能を使った書き方です。
// topのbuild.gradle allprojects { repositories { ... maven { url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot; content { // group idがcom.cloudflareのライブラリだけこのURLが有効になる includeGroup &amp;quot;com.cloudflare&amp;quot; } } } } --- // projectのbuild.gradleは一緒 dependencies { ... implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot; }  新しくcontentブロックが追加されました。ここでgroup idを指定することが出来ます。今回のURLはcom.</description>
    </item>
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>TruthはGoogleが開発をしているテストアサーションライブラリです。
従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。
 readableにアサーションが書ける デフォルトの失敗メッセージがわかりやすい  それぞれについて説明していきます。
readableにアサーションが書ける ドキュメントのbenefitにあるサンプルを取り上げ説明します。 http://google.github.io/truth/benefits
まず従来のJUnitスタイルを使って書きます。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertFalse(middleName.isPresent());  assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）
これがTruthを使うと次のようになります。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertThat(middleName).isAbsent();  assertThatはTruthに定義されているメソッドです。middleNameがabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。
上記のisAbsentはOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。 例えばIterableには、containsAnyInやisEmptyなどが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。
失敗メッセージがわかりやすい こちらもbenefitにあるサンプルを取り上げます。
まずは従来にJUnitスタイルから。
assertTrue(googleColors.contains(PINK));  この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。 失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。
次にTruthスタイルです。
assertThat(googleColors).contains(PINK);  &amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。
以上がTruthのメリットになります。
補足 Truth-Androidライブラリ JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。 例えば、Intentには以下のアサーションメソッドを使うことが出来ます。
hasComponent hasComponentClass hasComponentPackage hasPackage hasAction hasNoAction hasData hasType extras categories hasFlags  Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。</description>
    </item>
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>Result KEEP
Resultが1.3からstdlibに入ったので紹介をしたいと思います。
ResultはSuccess T | Failure Throwableの2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。
基本的な使い方 使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。
val i: Result&amp;lt;Int&amp;gt; = Result.success(10) val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())  また、runCatching関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。
val a = runCatching { doSomeThing() }  Resultに対する操作は以下のようにします。
// successに対して操作 val i = Result.success(10) i.getOrNull() // 10 i.isSuccess // true i.exceptionOrNull() // null i.map { 10 * 10 }.getOrNull() // 100 i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) } i.recover { 1111 }.getOrNull() // 10 // failureに対して操作 val t = Result.</description>
    </item>
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングでnamespacedRClassフラグが新しく追加されたので紹介します。 本記事では3.4.0-alpha07で試しました。
まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。 それを解決するためにnamespacedRClassが追加されました。使い方は簡単で、次の記述をgradle.propertiesに追加するだけです。
android.namespacedRClass=true  では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。 例として、appcompatに依存しているライブラリモジュールを用意します。
まずは、namespacedRClass=falseの時のRクラスです。
public final class R { private R() {} public static final class anim { private anim() {} public static final int abc_fade_in = 0x7f010000; public static final int abc_fade_out = 0x7f010001; public static final int abc_grow_fade_in_from_bottom = 0x7f010002; public static final int abc_popup_enter = 0x7f010003; ... ...  依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。
では次に、namespacedRClass=trueの時です。
public final class R { private R() {} public static final class color { private color() {} public static final int red3 = 0x7f04004b; } public static final class id { private id() {} public static final int title = 0x7f0700b1; } public static final class layout { private layout() {} public static final int base3 = 0x7f09001d; } public static final class string { private string() {} public static final int base_string3 = 0x7f0b002a; } }  このモジュールで定義したリソースの内容しか含まれていないことが分かります。appcompatのRクラスは含まれていません。 ライブラリモジュールのRクラスのサイズがかなり小さくすることが出来ました!</description>
    </item>
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>注意 この記事はapiとimplementationの説明をする類の記事ではありません。
GradleでcompileがDeprecatedになり、implementationまたはapiを使うことが推奨されています。 それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。
Dagger2でもcompileをimplementationに置き換えるPRが出されました。https://github.com/google/dagger/pull/1130
内容が興味深かったのでまとめてみようと思います。
まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。
// Add Dagger dependencies dependencies { - compile &#39;com.google.dagger:dagger:2.x&#39; + implementation &#39;com.google.dagger:dagger:2.x&#39; annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39; } - compile &#39;com.google.dagger:dagger-android:2.x&#39; - compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries + implementation &#39;com.google.dagger:dagger-android:2.x&#39; + implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries  ここでjakeさんが
 I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.</description>
    </item>
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。
それが3.4.0-alpha07以降で改善される見込みです🎉
詳細はここにあります。https://issuetracker.google.com/issues/116541301
この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。
サンプルコードはここにあります😃
エラーログの変化 まずどのようなエラーログが出力されるかを見ていきます。 適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。
まずはData Binding 3.2.1から。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root, ^ symbol: class DataBindingComponent location: class MainAct79Binding e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol boolean attachToRoot, @Nullable DataBindingComponent component) { ^ ... ... ...  Data Binding周りのエラーログが無限に出ます。悲しい😂
次に3.4.0-alpha07です。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass()  ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃</description>
    </item>
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>注意: 計測方法は実環境に全く即していないので意味がない可能性が高いです。
環境  AGP3.4.0-alpha06 Kotlin 1.3.10 Kotlinx.coroutine 1.0.1 Gradle 5.0  比較対象  kotlinx.coroutineを使ったサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている 300 * 7の2100箇所がCoroutine関連のコードになります  kotlinx.coroutineを使わないサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中で適当なメソッド（Handler().post {}）をコールしている  サンプルコード  計測コマンド Build Scanを使って計測します。その際。build-cacheはoffにします。
./gradlew clean ./gradlew build --no-build-cache --scan  両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。 また試行回数は10回程度で、最終結果のみを以下に掲載します。
kotlinx.coroutineを使う Time spent executing tasks 1m 16.034s All tasks	207	2m 42.833s Tasks avoided	12 (09.7%)	0.062s From cache	0 (00.0%)	0.000s Up-to-date	12 (09.</description>
    </item>
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>LiveDataの値を更新したい時、MutableLiveDataを使うのが一般的だと思います。
class MainViewModel { val hoge = MutableLiveData&amp;lt;Int&amp;gt;() }  この書き方だと、外のクラスから値を更新することが可能です。
val viewModel = MainViewModel() // ok viewModel.hoge.postValue(10000)  外のクラスからは更新出来ないようにするためにはLiveDataに型変換する必要があります。
例えば次のように書きます。
class MainViewModel { private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;() val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換 }  こうすることで、外のクラスからはMutableLiveDataが直接見えなくなり、明示的に型変換をしない限りLiveDataの値を更新できなくなります。
ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。 なので、それの解決策を以下で紹介します。
その1 まずコードをのせます。
abstract class ViewModel2 { protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) { postValue(value) } protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) { setValue(value) } }  // ViewModel2と同じパッケージに定義 public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; { @Override protected void postValue(T value) { super.</description>
    </item>
    
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>Retrofit 2.5.0からカスタムアノテーションが使えるようになったので、それの紹介です。
例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。
まず最初にアノテーションを定義します。
annotation class RequireAuth  次に、上記で定義したアノテーションを使い、Apiを定義します。
interface ApiService { @RequireAuth @GET(&amp;quot;login&amp;quot;) fun login(: retrofit2.Call&amp;lt;Unit&amp;gt; }  次に、RequireAuthを処理するためのokhttp3.Interceptorを定義します。
class AuthInterceptor : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { var request = chain.request() val invocation = request.tag(Invocation::class.java) val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java) if (authAnnotation != null) { request = request .newBuilder() .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic AAAAA&amp;quot;).build() } return chain.proceed(request) } }  ここでのポイントは、val invocation = request.tag(Invocation::class.java)です。 Retrofit 2.5.0からInvocationが追加され、RequestからInvocationが取得できるようになりました。 Invocationには、処理しているRequestのjava.lang.reflect.Methodが格納されており、 そこからアノテーションの情報を取得することができます。</description>
    </item>
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、 そんな夢をみたAndroidエンジニアは数多くいると思います。
この記事ではそんな夢を叶える方法を紹介します。
サンプルコードはここにあります。
FragmentFactory Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。
class MainFragment : Fragment() { @Inject lateinit var userHandler: UserHandler ... }  これをコンストラクタインジェクションにしたい。
class MainFragment @Inject constructor( private val userHandler: UserHandler ) : Fragment() { ... }  androidx.fragment:fragment:1.1.0-alpha01から、FragmentFactoryが追加されました!! これを使うことでコンストラクタインジェクションが可能になります。
MainFragmentインスタンスを生成するFragmentFactoryを作成します。
class MainFragmentFactory @Inject constructor( private val fragment: Provider&amp;lt;MainFragment&amp;gt; ) : FragmentFactory() { override fun instantiate( classLoader: ClassLoader, className: String, args: Bundle? ): Fragment { if (className == MainFragment::class.java.name) { return fragment.get() } return super.</description>
    </item>
    
    <item>
      <title>Kotlin: Contracts &#43; 拡張関数でより便利に</title>
      <link>https://satoshun.github.io/2018/11/more_convenient_contracts/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/more_convenient_contracts/</guid>
      <description>Kotlin 1.3.0からContractsが実装されました。 Contractsを使うことで、関数がどのような振る舞いをするか、どういう効果をもたらすかを定義（契約）することが出来ます。
例えば、isNullOrEmptyメソッドがfalse返すなら、 Contractsによりnullでないことが保証されます。
val a: String? = ... if (!a.isNullOrEmpty()) { println(a.length) // !!が必要ない }  Contractsがない時代だと呼び出し元でisNullOrEmptyがどんな振る舞いをするかを知るすべがなかったので、 !!をつける必要があったのですが、Contractsによりnullでないことが保証できるので、!!を省略できます。
isNullOrEmptyの実装は次のようになります。
@kotlin.internal.InlineOnly public inline fun CharSequence?.isNullOrEmpty(): Boolean { contract { returns(false) implies (this@isNullOrEmpty != null) } return this == null || this.length == 0 }  contractはDSL（関数）として定義されています。 これを呼び出し、そのブロックの中でこの関数が満たす振る舞いを定義する事ができます。
isNullOrEmptyの場合はreturns(false) implies (this@isNullOrEmpty != null)が契約として定義されています。
これは、「returns(false): falseを返すなら (this@isNullOrEmpty != null): 自分自身がnullじゃない」という意味になります。 なので呼び出し元ではfalseが返ってきたら、nullではないことが保証されるので、smartcastにより!!をつける必要がなくなるわけです。
なので、例えばT.isEmpty(t: T?): Booleanのようなメソッドがあり、ついでにnullチェックもこの関数の中でやっているようなときは、 contractを定義することでより使いやすい関数にすることが出来ます。
他の例を見てみます。スコープ関数applyの実装は次になります。
@kotlin.internal.InlineOnly public inline fun &amp;lt;T&amp;gt; T.</description>
    </item>
    
    <item>
      <title>Android: デバッグ時にMoshi、Daggerリフレクションライブラリを使いビルド時間を短縮する</title>
      <link>https://satoshun.github.io/2018/11/debug_reflection/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/debug_reflection/</guid>
      <description>ビルド時間の短縮は開発効率を上げる大きな要素です。 極力kapt（アノテーションプロセッサー）を使わなくすることで、ビルド時間を短縮出来ます。 アノテーションプロセッサーを使ったライブラリは、アノテーションプロセッサーを使わない、 リフレクションを用いたデバッグ用の機能を提供していることがあります。
今回は、MoshiとDaggerリフレクションライブラリの紹介をします。 Daggerリフレクションは絶賛開発中 + 公式ではないので、機能がかなり制限されている、どういう未来が待っているかわからない点に注意してください。
検証に用いたサンプルコードはここにあります。
Moshiリフレクション Moshiにはmoshi-codegenと呼ばれる、アノテーションプロセッサーでコード生成してくれるライブラリがあります。 これは実行時のパフォーマンスには優れているのですが、アノテーションプロセッサーを使っているため、ビルドに時間がかかってしまいます。
そこで、Moshiではmoshi-reflectionと呼ばれるライブラリを提供しており、これはアノテーションプロセッサーを使うことなく、 moshi-codegenと同等の機能を提供してくれます。 ただし、moshi-reflectionは内部でリフレクションを使っているため、実行時のパフォーマンスには優れていません。あくまでデバッグ用、という立ち位置だと思います。
デバッグ時にmoshi-reflectionを使い、リリース時にmoshi-codegenを使うことで、ビルド速度と実効速度の天秤を勝ち取ることが出来ます。
具体的には、デバッグ時、リリース時にbuild.gradleで指定するライブラリを、Moshiに登録するAdapterを変更します。
// bulid.gradle implementation &amp;quot;com.squareup.moshi:moshi:1.8.0&amp;quot; debugImplementation &amp;quot;com.squareup.moshi:moshi-kotlin:1.8.0&amp;quot; kaptRelease &amp;quot;com.squareup.moshi:moshi-kotlin-codegen:1.8.0&amp;quot;  // debug時 fun createMoshiBuilder() = Moshi.Builder() .add(KotlinJsonAdapterFactory()) // KotlinJsonAdapterFactoryを指定する .build() // release時 fun createMoshiBuilder() = Moshi.Builder() .build()  このように書くことで、リリース時のみkaptを実行するようになります。
Daggerリフレクション これはSdkSearch内で開発が行われているライブラリです。有名なAndroidエンジニアであるJake Whartonさんが開発をしています。
これもMoshiと同様に、リフレクションを使っています。 Daggerリフレクションでは、必要最低限のクラスはアノテーションプロセッサーで作成するようになっています。 アノテーションプロセッサーの完全除去というわけではありません。例えば、アノテーションプロセッサーでDaggerAppComponentは作られます。 しかし、かなりの数のクラスを作成しないようになっています。
具体的なコードは、以下のようになります。 Mavenにアップデートされていないので、SdkSearchからソースコードをコピーして使います。
implementation &amp;quot;com.google.dagger:dagger:2.18&amp;quot; debugImplementation project(&#39;:dagger-reflect:reflect&#39;) // SdkSearchからコピー kaptDebug project(&#39;:dagger-reflect:reflect-compiler&#39;) // SdkSearchからコピー kaptRelease &amp;quot;com.google.dagger:dagger-compiler:2.18&amp;quot;  デバッグ時にはDaggerリフレクションを使い、リリース時にはdagger-compilerを使っています。 変更差分はbuild.gradleのみです。コードは全く修正する必要はありません。</description>
    </item>
    
    <item>
      <title>KotlinのNon-Null型にnullを代入する方法</title>
      <link>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</guid>
      <description>Kotlinではnullを扱いやすくするためにNullable、Non-Nullを型で制限することが出来ます。 KotlinのNon-Null型に対してnullを代入しようとすると、代入するタイミングで例外を吐きます。 JavaとKotlinを一緒に使っていると、この例外に遭遇することがあると思います。
具体的には以下の挙動をします。
public class Hoge { // nullを返すメソッド static String getName() { return null; } }  val d: String = Hoge.getName() // ここで例外が投げられる println(d.length) // これは実行されない  このコードは、val d: String = Hoge.getName()でIllegalStateExceptionを投げます。 Non-Null型にnullを代入しようとしているからです。
次に、代入するタイミングで例外を投げなくする方法を紹介します。
具体的には以下のコードで達成できます。
fun &amp;lt;T&amp;gt; castNull(): T = null as T val d: String = castNull() // ここでは例外が投げられない println(d.length) // ここで例外が投げられる  なぜこのような挙動になるのかを説明します。まず castNull()メソッドに定義されたジェネリック型TはAny?をupperに持ちます。 Kotlinはジェネリックを使い、かつNullable型をupperに持つとき、nullかどうかのチェックをしません。これはバイトコードを見れば分かります。
GETSTATIC sample/SampleTestsJVMKt.a : Ljava/lang/String; CHECKCAST java/lang/Object  CHECKCASTしかしておらず、nullかどうかのチェックをしていません。 なので、val d: String = castNull()ではnullチェックがされないため例外が投げられず、実際にメソッドをコールするprintln(d.</description>
    </item>
    
    <item>
      <title>拡張関数 &#43; ジェネリック型でよりタイプセーフを得る</title>
      <link>https://satoshun.github.io/2018/11/extension-typesafe/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/extension-typesafe/</guid>
      <description>Kotlinの拡張関数の話です。
以下のクラスがあったとします。
class A&amp;lt;T&amp;gt;(val value: T) { fun isNull(): Boolean { return value != null } } fun main() { val a1: A&amp;lt;Int&amp;gt; = ... a1.isNull() }  このとき、a1.isNull()の結果は自明です。なぜならA&amp;lt;Int&amp;gt;で宣言している時点でnonNullが確定しているためです。
fun main() { val a2: A&amp;lt;Int?&amp;gt; = ... a2.isNull() }  このとき、a2.isNull()の結果は自明ではありません。 なぜならA&amp;lt;Int?&amp;gt;でジェネリック型を宣言しているので、nullableな値が入ってくる可能性があるためです。
この2つの例から、a1.isNull()はそもそもnonNullなのでisNull()メソッドをコールできないほうが良いのではないか？という考えが浮かびます。
Kotlinの拡張関数を使うことで達成できます。
class A&amp;lt;T&amp;gt;(val value: T) // nullableのときにコールできるようにする fun &amp;lt;T : Any&amp;gt; A&amp;lt;T?&amp;gt;.isNull(): Boolean { return value != null } fun main() { val a1: A&amp;lt;Int&amp;gt; = .</description>
    </item>
    
    <item>
      <title>Kotlinで3つの関数のパラメータを省略する</title>
      <link>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</guid>
      <description>Kotlinでは拡張関数が定義されており、拡張関数を使うことで1つ関数のパラメータを省略できます。
fun hoge(a: String) { println(a) } -&amp;gt; fun String.hoge() { println(this) }  次に、インターフェース（クラス）内で拡張関数を定義することで、さらに1つの関数のパラメータを省略できます。
interface User fun hoge(a: String, b: User) { println(a) println(b) } -&amp;gt; interface User { fun String.hoge() { println(this) println(this@User) } }  さらに、reified type parameterを使うことで、関数のパラメータを省略できます。
fun &amp;lt;T&amp;gt; hoge(a: String, b: User, c: Class&amp;lt;T&amp;gt;) { println(a) println(b) println(c) } -&amp;gt; class User { inline fun &amp;lt;reified T&amp;gt; String.hoge() { println(this) println(this@User) println(T::class) } }  interfaceだと、inline関数が使えないのでクラスで定義してあります。</description>
    </item>
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description> ふとAACのViewModelのonClearedメソッドをテストしたくなったので、 2つのやりかたを紹介します。
環境は
&amp;quot;junit:junit:4.12&amp;quot; &amp;quot;androidx.test:rules:1.1.0-beta02&amp;quot; &amp;quot;androidx.test:runner:1.1.0-beta02&amp;quot; &amp;quot;androidx.test.ext:junit:1.0.0-beta02&amp;quot; &amp;quot;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;quot; &amp;quot;org.robolectric:robolectric:4.0-beta-1&amp;quot;  になります。
また、サンプルコードは GitHubにあるので、参考してください😊
1. ViewModelStoreを使う ViewModelProviders.of(activity).get(class)からViewModelを取得したときに、取得したViewModelはViewModelStoreにキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。
@RunWith(AndroidJUnit4::class) class BaseViewModelTest { @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java) @Test fun `dispose a coroutine when finished lifecycle of ViewModel`() { activityRule.activity.viewModelStore.clear() // ViewModelが開放される } }  このテストはコード的には簡単ですが、ViewModelStoreがViewModelのライフサイクルを管理しているということを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。
なので、素直にonDestroyをコールするテストも書いてみます。
2. Instrumentation.callActivityOnDestroyを使う Instrumentationクラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。 InstrumentationはInstrumentationRegistryクラスから取得することができ、次のように書くことで、onDestroyをコールすることができます。
@Test fun `dispose a coroutine when finished lifecycle of ViewModel 2`() { // onDestroyがコールされViewModelが開放される InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity) }  これで、UnitテストでViewModel.onClearedのテストをすることが出来ます。
以上です。Happy Testing☆彡
 サンプルコード  </description>
    </item>
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>（この記事は1.3-M2を使っています。）
Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。
例えば、次のように書くことが出来ます。
inline class UserId(val id: String) { val url get() = &amp;quot;http://$id&amp;quot; } val userId = UserId(&amp;quot;user-dayo&amp;quot;) println(userId.url)  このコードは一見、UserIdインスタンスが生成されそうです。 しかし、コンパイルされたコードではUserIdインスタンスは生成されません。
public static final class UserId$Erased { ... @NotNull public static final String getUrl(String $this) { return &amp;quot;http://&amp;quot; + $this; } ... } String userId = &amp;quot;user-dayo&amp;quot;; String var1 = UserId$Erased.getUrl(userId); System.out.println(var1);  UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成されたUserId$Erasedクラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。
ここからが本題です。 Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。
例えば、次のコードがあったとします。
data class Response( @SerializedName(&amp;quot;user_id&amp;quot;) val userId: String, @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: String )  これはuserIdとfriendIdをStringで受け取っており、このStringが何のStringかの情報が欠落しています。型による分類が出来てない状態です。</description>
    </item>
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>みなさんこんにちは
今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として@Inject lateinit var になってしまうところがあると思います。
class HogeActivity { @Inject lateinit var hoge: Hoge }  これをなんとか出来ないかなと思って考えてみました。
結論から言うと最終形はこのようになります。
class HogeActivity { private val hoge: Hoge by inject() }  private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。
今回はIntoMapを使って実装することにしました。
IntoMapとはその名の通りMapにバインドするためのアノテーションです。 詳しくはドキュメントを見てください。
サンプルコードで説明していきます。
まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。
@Module interface HogeModule { @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any } class Hoge1 @Inject constructor() class Hoge2 @Inject constructor() @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) @MapKey annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)  Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。</description>
    </item>
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これはMessage#setAsynchronousを使うことで、UIのパフォーマンス向上を狙った機能です。 下のリンクに詳細な内容が書かれています。
RxAndroid’s New Async API
この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。
検証に使用したサンプルプロジェクトは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample
サンプルプロジェクトをかいつまんで説明します。
まず2つのスケジューラを作成し、
private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false) private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true)  作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。
// asyncがfalseの場合 Observable .fromCallable { System.currentTimeMillis() } .delay(index, TimeUnit.MILLISECONDS) .observeOn(mainScheduler) .subscribe(...) // asyncがtrueの場合 Observable .fromCallable { System.currentTimeMillis() } .delay(index, TimeUnit.MILLISECONDS) .observeOn(asyncMainScheduler) .subscribe(...)  フルコードは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt
結果は、以下のようになりました。
// API27 エミュレータ main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和 main=130857ms, async=126582ms main=131401ms, async=126909ms main=130763ms, async=126504ms main=132758ms, async=127972ms // API21 エミュレータ main=129869ms, async=125795ms main=130050ms, async=125888ms main=129935ms, async=125853ms main=129908ms, async=125838ms main=129927ms, async=125824ms  asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。</description>
    </item>
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>Dagge 2.17でfastInitオプションが追加されました。 https://google.github.io/dagger/compiler-options
これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。
確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。
確認に使用したシェルスクリプト adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。
for i in {0..10} do adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt sleep 10 done  下記を参考にしました。
 https://developer.android.com/topic/performance/vitals/launch-time  fastInit有効の場合 下記をbuild.gradleに追加します。
kapt { javacOptions { option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;) } }  結果:
平均: 1609ms  fastInit無効の場合 結果:
平均: 1607ms  まとめ ほぼ変わらない数字が出てきてしまいました。悲しい。 Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。
芳しくない結果になった推測として
 担当アプリのDaggerの書き方が正しくないからこの結果になった?  要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず  確認に使用したコマンドが良くないのかも?  なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊</description>
    </item>
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>結論  R8/Proguardをちゃんと使う  背景 Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。
実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。
まずは、R8無しで調べてみます。
fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  当然メソッドカウントが1増えています。
次に、inlineを付けてみます。
inline fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  こちらもメソッドカウントが1増えました。 show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。
@Metadata( mv = {1, 1, 10}, bv = {1, 0, 2}, k = 2, d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;}, d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;} ) public final class MainActivityKt { public static final void hoge() { String var1 = &amp;quot;hogehoge&amp;quot;; System.</description>
    </item>
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。 この記事ではSpaceを使ったネガティブマージンの実現について説明します。
例 ネガティブマージンと同等の大きさを持ったSpaceを定義して、そこにConstraintを設定するだけです。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; android:clipToPadding=&amp;quot;false&amp;quot; android:padding=&amp;quot;80dp&amp;quot;&amp;gt; &amp;lt;Space android:id=&amp;quot;@+id/negative&amp;quot; android:layout_width=&amp;quot;15dp&amp;quot; android:layout_height=&amp;quot;15dp&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt; &amp;lt;ImageView android:id=&amp;quot;@+id/icon&amp;quot; android:layout_width=&amp;quot;30dp&amp;quot; android:layout_height=&amp;quot;30dp&amp;quot; android:contentDescription=&amp;quot;icon&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot; tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;  簡単に説明すると、Spaceに15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。 上記の例だと、
 android:layout_marginStart=&amp;quot;-15px&amp;quot; android:layout_marginTop=&amp;quot;-15px&amp;quot;  と同等の振る舞いをしています。
まとめ ConstraintLayoutではネイティブでネガティブマージンに対応していないため、Spaceを使った、ややテクニカルな方法で実現するのが良いと思われます。</description>
    </item>
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。 https://kotlinlang.org/docs/reference/type-aliases.html
典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。
typealias MyHandler = (Int, String, Any) -&amp;gt; Unit  さらにtypealiasは、アノテーションをつけることも出来ます。
typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;  JvmSuppressWildcardsはDagger(参考リンク)やretrofit(参考リンク)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。</description>
    </item>
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>Daggerを使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。 Androidでは、すべてのActivityで共通のインスタンスを使うには SingletonスコープとAppComponentを組み合わせて使う方法がよく知られています。 しかし、特定のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。SingletonだとすべてのActivity間で共通のインスタンスが使えてしまいます。
この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。 また、基本的なDaggerの使い方は知っている前提で説明していきます。
サンプルコードはこちらになります。 コードを見ると理解がより深まると思うので、ぜひご覧になってください😊
では説明していきます。今回のサンプルコードの目指すところは
 UserScopeを定義し、MainActivity、UserScopedActivityで同一のUserManagerインスタンスを使用する  とします。
まず最初にUserScopeを定義します。
@Scope @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) annotation class UserScope  次にUserSubcomponentを作ります。
@UserScope @Subcomponent interface UserSubcomponent { @Subcomponent.Builder interface Builder { fun build(): UserSubcomponent } val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; }  ここでは、UserSubcomponentにUserScopeスコープを持たせています。 このように書くことで、SubcomponentとScopeを結びつけることが出来ます。
次にAppComponentを作ります。
@Singleton @Component( modules = [ AndroidSupportInjectionModule::class ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; { @Component.Builder interface Builder { @BindsInstance fun application(application: App): Builder fun build(): AppComponent } override fun inject(app: App) // AppComponentとUserSubcomponentを結びつける val userComponentBuilder: UserSubcomponent.</description>
    </item>
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。 ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。
このライブラリの機能に、safeargsというものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。
safeargsを使ってみる 一般的にFragmentに適当な値を渡すときはBundleを通して渡します。
// 呼び出し側 val bundle = Bundle() bundle.putInt(&amp;quot;step&amp;quot;, 10) // 呼び出され側 val step = arguments?.getInt(&amp;quot;step&amp;quot;)  これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&amp;quot;step2&amp;quot;にしてしまうと、ランタイムエラーになります。
これを解決にするためにNavigationではsafe argsという機能を提供しています。 これは、DataBindingのように、クラスを生成することでtypesafeを実現します。
&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt; &amp;lt;fragment android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot; android:label=&amp;quot;Hoge&amp;quot;&amp;gt; &amp;lt;argument android:name=&amp;quot;step&amp;quot; app:type=&amp;quot;integer&amp;quot; android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt; &amp;lt;/fragment&amp;gt; &amp;lt;/navigation&amp;gt;  とnavigationを記述すると、
public class HogeFragmentArgs { private int step = 1; private HogeFragmentArgs() { } public static HogeFragmentArgs fromBundle(Bundle bundle) { HogeFragmentArgs result = new HogeFragmentArgs(); if (bundle.containsKey(&amp;quot;step&amp;quot;)) { result.</description>
    </item>
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。 適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。
定義は以下のようになります。
fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; { // skip用の初期値を入れておく return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null } } fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) { // 最初の値は常にskipすることで、キャッシュを無視する val firstIgnore = AtomicBoolean(true) this.observe(owner, Observer { if (firstIgnore.getAndSet(false)) return@Observer observer(it) }) }  使う時はこんな感じで使います。
// TestViewModel.kt class TestViewModel: ViewModel() { val errorEvent = singleLiveData&amp;lt;String&amp;gt;() } // TestActivity.kt testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java) testViewModel.errorEvent.observeSingle(activity) { Log.d(&amp;quot;one&amp;quot;, it.toString()) }  メリットはサブクラスを作らずに済むところです。
参考  https://github.</description>
    </item>
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description> CoroutineBindingライブラリを作ったのでその紹介です。 https://github.com/satoshun/CoroutineBinding
Android開発でCoroutineの流れが来ていると思っていて、RxBindingのような感じで、 CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。
使い方 例えばclickのイベントを受け取りたいとします。 CoroutineBindingでは以下のように書くことが出来ます。
val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root) launch(UI) { for (click in root.clicks()) { Log.d(&amp;quot;clicked&amp;quot;, click.toString()) } }  RxBindingのように使うことが出来ます! 他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。
まとめ  Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい! https://github.com/satoshun/CoroutineBinding 何かあればissueや、PRを貰えると嬉しいです  </description>
    </item>
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。
まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。 振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。
型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。
人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。

to be continued.</description>
    </item>
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description> ポエムです。
結論 基本的にローカルで明示的に型を宣言するのは好ましくない
問題 Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。
val userName = dataSource.getUserName()  型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。
Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。
まとめ  ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする  </description>
    </item>
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>問題 Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。
理由としては、Data Bindingの生成が失敗すると、MainActivityBindingみたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。 デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)
解決法 全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです
kapt { javacOptions { option(&amp;quot;-Xmaxerrs&amp;quot;, 5000) } }  これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。
これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。
before(一部ログ修正しています)
... // 長いエラーログ ... ... symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:91: error: cannot find symbol @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:102: error: cannot find symbol @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding :app:kaptProductDebugKotlin FAILED  after</description>
    </item>
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。
例えば以下のようなActivityがあるとします。
class HogeActivity : Activity() { ... ... private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  これを見た時、「なんで loginCount &amp;lt;= 100にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。
class HogeActivity : Activity() { private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。
ただ、自分の考えでは上記のコードは根本的に間違っていると思っていて、そもそもActivityでコメントが必要なほど複雑なことをしているのが問題だと思います。 なんでActivityで複雑なことをしてはいけないかというと、ActivtyはContextにアクセスできたりと、なんでも出来るからです。なんでも出来る層でいろいろやってしまうと、 いわゆるfat activity問題が起こってしまいます。</description>
    </item>
    
    <item>
      <title>DroidKaigi2018で「なんとなく動いているProguardから脱出するために」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2018/02/droidkaigi-2018/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/02/droidkaigi-2018/</guid>
      <description>DroidKaigi2018でセッションが採択されたので発表しました。
 https://goo.gl/S95MJs
正直、Proguardは目新しいトピックでないのでそんなに聞きに来てくれないだろうなと思っていました。 しかし、Room3という広い部屋が割り当てられて、さらに当日はかなりの人が聞きに来てくれました。本当に聞きに来てくれた人ありがとうございます😊😊😊
Twitterの反応を見る限りだと、分かりやすいと言っている人が多くいたので嬉しかったです。 Proguardは苦手意識を持っている人が多いと思っていて、なのでstep by stepで順序良く聞けるような発表を心掛けたのでその効果が少しは出たのかなと思っています。
反省点としては、自分が想定したより時間に余裕があったので何か面白いことを喋ろうとしたら何も思いつかないでフガフガしてしまったところです。 今後はフガフガせずに、アドリブ力みたいなものを身につけていきたいと思います!
あと、もう一つ反省点としてすべるのが怖くて積極的にネタみたいなものをスライドに入れられなかったことです。一応考えていたものは
 「Self-Styled Proguardエバンジェリストです」と自己紹介しようとした。 僕の発表資料はProguardに失敗してやや冗長になってしまいましたけど、みなさんのAPKサイズはProguardに成功して小さくなることを期待しています。みたいなことを言おうとした。  みたいなことを言って笑いを取りたかったなと後悔しています(笑いを取れるとは言っていない)。
来年もDroidKaigiあるとしたらCfP出してまた登壇できるように頑張ります。 そして運営の皆さん本当にありがとうございました。凄い楽しかったです(•ө•)♡</description>
    </item>
    
    <item>
      <title>Android: ViewがどのFragmentに属しているかをViewから取得する</title>
      <link>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</guid>
      <description>ViewがどのFragmentに属しているかを取得する方法の紹介になります。 前々からtag、id以外の仕組みで取得出来ないかなと考えていたら、GlideでViewからFragmentを取得するコードがありました。
@Nullable private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) { tempViewToSupportFragment.clear(); findAllSupportFragmentsWithViews( activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment); Fragment result = null; View activityRoot = activity.findViewById(android.R.id.content); View current = target; while (!current.equals(activityRoot)) { result = tempViewToSupportFragment.get(current); if (result != null) { break; } if (current.getParent() instanceof View) { current = (View) current.getParent(); } else { break; } } tempViewToSupportFragment.clear(); return result; } private static void findAllSupportFragmentsWithViews( @Nullable Collection&amp;lt;Fragment&amp;gt; topLevelFragments, @NonNull Map&amp;lt;View, Fragment&amp;gt; result) { if (topLevelFragments == null) { return; } for (Fragment fragment : topLevelFragments) { // getFragment()s in the support FragmentManager may contain null values, see #1991.</description>
    </item>
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description> LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。
package android.arch.lifecycle; public abstract class LiveData&amp;lt;T&amp;gt; { protected void onActive() { } }  onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。
package android.arch.lifecycle fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる }  同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。
package android.arch fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // コンパイルエラー &amp;quot;Cannot access &#39;onActive&#39;: it is protected in &#39;LiveData&#39;&amp;quot; }  なぜかこのような挙動になるか? protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。
まとめ protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう
参考  https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a  </description>
    </item>
    
    <item>
      <title>Android: MVP, Dagger2, Retrofitなどなどでアプリを作りました</title>
      <link>https://satoshun.github.io/2015/09/android-app-events/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/09/android-app-events/</guid>
      <description>イベントを検索するAndroidアプリを作成したので, 使った技術のまとめです.
アプリの技術的機能, 特徴は以下になります.
 HTTPを介してイベントのデータを取得する  検索対象のサーバは複数あるため(今回は3つ), どこかでそれらのレスポンスデータを同期する必要がある それら複数のサーバーはJSONを返すが, 微妙にJSONの構造が異なる  Data-Bindingライブラリを使う MVP(Model-View-Presenter)パターンを使う  Activity(Fragment)に機能が集中しないようにしたい!   上記を中心にどのように実装をしたかを説明をしていきます.
フルソースコードはここにあります. https://github.com/satoshun/AndroidEvents
HTTPを介してイベントのデータを取得する connpass, Atnd, Zusaarの3つのAPIを使うことにしました. RetrofitでAPIを定義し, JSONのパースにはGson, データの処理にはRxJavaを使いました.
例えば, connpass APIは以下のように定義しました.
/** Get data from Conpass */ public interface Connpass { @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;keyword&amp;quot;) String keyword, @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); }  keywordとymdを指定してリクエストを生成します. 「2015/12/31のAndroidのイベント」のように使う想定です. Retrofitを使うと, このようにinterfaceとして, APIを定義することが出来ます. (https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/network/Connpass.java#L10)
次に, RxJavaの説明をします. RxJava(Observable)を使うと, 非同期にデータが扱いやすくなります. またデータのマージ(merge)や, フィルタリング(filter)などを簡単に行うことが出来ます.</description>
    </item>
    
    <item>
      <title>Improving Android: 列挙にはenumではなくIntDef, StringDef annotationを使う</title>
      <link>https://satoshun.github.io/2015/08/improve-android-performance1/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/08/improve-android-performance1/</guid>
      <description>enumの典型的な使い方として, 月(month)や, ネットワークプロコトルなどの, 特定の種類を列挙するために使用されます.
列挙型としてのenumは, 以下のように書くことが出来ます.
enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER } /** 指定した月が何日まであるかを返す */ int getDate(Month month) { //// }  また, enumではなく定数を使うとしたら以下のように書くことが出来ます.
static final int JANUARY = 1; static final int FEBRUARY = 2; static final int MARCH = 3; static final int APRIL = 4; ... static final int NOVEMBER = 11; static final int DECEMBER = 12; /** 指定した月が何日まであるかを返す */ int getDate(int month) { //// }  定数を使うバージョンだと, getDate(int)のため, 予期せぬ値が入ってきてしまう可能性があります.</description>
    </item>
    
    <item>
      <title>Android: Picassoで使われているデザインパターン</title>
      <link>https://satoshun.github.io/2015/06/reading_picasso/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/reading_picasso/</guid>
      <description>Picassoで使われているデザインパターンを紹介する記事です.
Singletonパターン Singletonパターンは, インスタンスの生成を1つに制限するパターンになります.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L672
public static Picasso with(Context context) { if (singleton == null) { synchronized (Picasso.class) { if (singleton == null) { singleton = new Builder(context).build(); } } } return singleton; }  Picasso#withは, すでにPicassoのインスタンス singleton が生成されていればそれを返し, 生成されていなければ, インスタンスを生成して返します.
このパターンのメリットは, インスタンスを多くても1つしか作らないのでメモリ的に有利な点です(使い回せる) しかし, singletonなインスタンスは, 複数のクラスから使われる可能性があるので, スレッドセーフである必要があります.
スレッドセーフにするためには, 全てのfieldの値をfinalにする. 排他的制御を入れるなどの方法があります.
Builderパターン Builderパターンはインスタンス生成時に多数のパラメータが必要なときに便利なパターンです.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L702
public static class Builder { private final Context context; private Downloader downloader; private ExecutorService service; private Cache cache; private Listener listener; private RequestTransformer transformer; private List&amp;lt;RequestHandler&amp;gt; requestHandlers; private Bitmap.</description>
    </item>
    
    <item>
      <title>心理学: 人間は合理的な判断は出来ない</title>
      <link>https://satoshun.github.io/2015/06/anchoring_effect/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/anchoring_effect/</guid>
      <description>人間は合理的な判断をしているようで, 実はそんなにしていないという話をします.
例: 値引き商品 普段, 1,000円のとんかつ定食があるとします. その日は割引セールで40%OFFの600円になっていました. この時に本来は, 「このとんかつ定食が600円」が高いかどうかで判断を下さないといけません. しかし, 脳では「普段より400円安い!お得!!」と判断し, お得なとんかつ定食を選ぶ可能性があがります.
この現象を, アンカリング効果(Anchoring effect)と呼びます. 1,000円がアンカー(一種の基準)になり, 600円を非常にお得と判断してしまいます. 例えば, 隣の店で全く同じとんかつ定食が600円で売られているとしても, こちらのとんかつ定食がお得だと判断します. これは合理的な判断とはいえません.
ものを販売する時はアンカーを意識して値段設定すると, ユーザの心を揺さぶることが出来ます.
合理的に判断するなら, 割引前の値段には影響を受けてはダメです. メーカーは定価を高めに設定しています. 冷凍食品なんかは常に割引セールをしています.
例: 全く無関係な数字 「値引き商品だったら, なんとなく影響を受けている気がする」という人は多いと思います. しかし, 全く無関係な数字にも人間は影響を受けます.
事前に10 or 50という数字を見せられているとします. 次にAndroid5.0のシェア率答えてもらいます. この時, Android5.0のシェア率に関してなんら情報を持っていなければ, 10 or 50という数字に大きく影響を受けることが分かっています. これは10 or 50という数字が基準(アンカリング)とし, 正解だと思う数字に調整するためです.
これは, 直感的には「そんなことないよと」言いたいところですが, 多くの人間が無関係な数字に影響を受けるようです.
合理的に判断するなら, 事前の数字に影響を受けてはダメです. しかし, よほど意識しない限り人間の脳は無関係な数字にも影響を受けてしまいます.
例: いろいろなレンジ帯の商品群 ある高級マットレスA,Bがあるとします. マットレスAは78,000円, マットレスBは128,000円の時に, マットレスBを選ばせるためにはどうするのがよいでしょうか? それは, マットレスC 488,000円を売り出すことです.
マットレスA 78,000円, マットレスB 128,000円, マットレスC 488,000円とあると, マットレスAだと安すぎて不安, マットレスCだと高すぎるし, ちょうど中間帯のマットレスBを買おうと誘導することが出来ます.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>概要 この記事では, JakeWhartonさんのu2020から, AndroidでDagger2を使うときの実践的な方法を紹介します. u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.
DI, Dagger2の基本について知りたい方は, Part1を見て下さい.
目次
 debugとproductionでModuleを切り替える Debug専用のViewを作る Mockモードの定義 -　まとめ  debugとproductionでModuleを切り替える gradleは, productFlavorsを設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります. そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています. 具体的には,
 /src/production/java/com/jakewharton/u2020/Modules.java /src/internalDebug/java/com/jakewharton/u2020/Modules.java /src/internalRelease/java/com/jakewharton/u2020/Modules.javaに  それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています. これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.
こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.
 Debugのみログを有効にしたい APIのエンドポイントを変えたい debug専用のViewを出したい Test用のインスタンスをinjectしたい etc, etc&amp;hellip;  以下では, より細かく説明していきます.
Debug専用のViewを作る u2020では, Debug専用のView DebugAppContainerがあります. Debug専用のView はこんな感じです. Debugビルドの時は, このContainerをinjectしています.
DebugAppContainerは簡単にいえば, DrawerLayoutを1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.
Mockモードの定義 u2020ではMockモードがあり, Mockデータを表示機能があります.
public final class DebugDataModule { .</description>
    </item>
    
    <item>
      <title>ReactiveX: Hot, Coldの違い</title>
      <link>https://satoshun.github.io/2015/05/hot_cold/</link>
      <pubDate>Fri, 22 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/hot_cold/</guid>
      <description>ReactiveXにおける, Cold/Hot Observableの違いを説明します.
(本文中の「subscribeする」と, 「Observerを登録する」は同義です.)
Cold Observable Cold ObservableはSubscribeされると動作を開始します.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });  例えば, 上のコードだと, sourceを定義した時点ではストリームが生成されておらず, source.subscribeされた時に, 初めてストリームが生成されます. 遅延評価(lazy evaluation)のような振る舞いをします.
次に, 1つのCold Observableに対して複数subscribeしたとします.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); source.subscribe(function(x) { console.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. 基本編 Part1</title>
      <link>https://satoshun.github.io/2015/05/dagger2/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2/</guid>
      <description>概要 この記事では, 最初にDIとは何かについて説明します. DIを理解した後にDagger2の基本的な使い方を紹介します. Dagger2はDI(Dependency Injection)をするライブラリです.
DIとは? DIとはDependency Injectionの略で, 訳すと「依存性の注入」です. ここでいう依存とは クラス同士の依存関係のことを表します. クラス同士の依存関係は, 委譲パターンの時に現れます.
例えば, 以下のコードがあったとします.
class Blogger { public Blogger() { } public void post(String title) { // 何かメインの処理 // ... // fileにlogを取る FileLogger logger = new FileLogger(title); logger.logging(); } } class FileLogger implements Logger { @Override public void logging(String... messages) { // fileにmessagesを書き出す File file = new File(&amp;quot;hoge.txt&amp;quot;); ... } } interface Logger { void logging(String messgae); }  クラスBloggerはクラスFileLoggerに依存している.</description>
    </item>
    
    <item>
      <title>Python: Pythonライクな書き方 Part1</title>
      <link>https://satoshun.github.io/2015/04/python-beautiful/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/python-beautiful/</guid>
      <description>Pythonライクな書き方について紹介します. Part1です.
for文関連 indexを使いたいとき Bad: range, lenを使う
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] for i in range(len(names)): print i, names[i]  Good: enumerateを使う
for i, name in enumerate(names): print i, name  2つのコレクションを扱うとき Bad: indexを使ってアクセスする
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] ages = [12, 19, 11] for i in range(min(len(names), len(ages))): print names[i], ages[i]  Good: 組み込み関数zipを使う
for name, age in zip(names, ages): print name, age  dictionaryでkey, valueを使う Bad: keyでアクセス, valueを取得する</description>
    </item>
    
    <item>
      <title>Android: AndroidKaigiまとめ</title>
      <link>https://satoshun.github.io/2015/04/droid-kaigi/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/droid-kaigi/</guid>
      <description>AndroidKaigiの記事まとめです.
DroidKaigi - Welcome talk   DroidKaigi - Welcome talk  from mhidaka
エンジニアのための勉強会をやるよ!みたいな内容
Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法   Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法 -  from Yuki Anzai 
CardboardのUXをカメラで向上する   CardboardのUXをカメラで向上する (droidkaigi 2015&amp;frasl;04)  from Kenichi Takahashi 
絶対落ちないアプリの作り方 あるゲームアプリケーションの構成とアップデートサイクル   あるゲームアプリケーションの構成とアップデートサイクル  from Kentaro Iizuka 
開発を効率的に進めるられるまでの道程   開発を効率的に進めるられるまでの道程  from Takao Sumitomo 
アプリの企画、プロトタイプからリリースに至るまで   初学者に嬉しいAndroid開発環境   【DroidKaigi2015】初学者に嬉しいAndroid開発環境(あとMVCとか)  from Hiroyuki Kusu</description>
    </item>
    
    <item>
      <title>データベース: RDBと第1~3正規形について</title>
      <link>https://satoshun.github.io/2015/04/normalization/</link>
      <pubDate>Sun, 19 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/normalization/</guid>
      <description>正規形は, リレーショナルデータベース設計における理論の1つです. 正規化を行うことで, データの重複をなくし, 効率良くデータを保持することが出来ます.
この記事では, リレーショナルデータベースについて説明し, 第1-3正規化について説明します.(BCNF, 第4-6正規化は次の記事で説明します)
リレーショナルデータベースモデル(RDB)について 最初にリレーションについて説明します. リレーションは見出し(heading)と本体(body)からなります. 見出しは, SQLでいうところの属性に相当します. 例えば, 生徒なら下のようなデータを持つと考えられます.
   学生番号 名前 年齢     001 田中 17   002 多田野 19   003 木下 19   004 西岡 18    上記表がリレーションの一例になります. {学生番号, 名前, 年齢}が見出し, {{001, 田中, 17}, {002, 多田野, 19}, {003, 木下, 19}, {004, 西岡, 18}}が本体になります. ここで{}を使っているのは, リレーショナルにおける見出し, 本体はそれぞれタプルで表現されるためです. そのため各要素には順序が存在せず, 重複が許されません(重複があっても意味がない).
ここで集合という言葉が出てきましたが, RDBは集合論 に基づいた理論です.</description>
    </item>
    
    <item>
      <title>データベース: 履歴データについて</title>
      <link>https://satoshun.github.io/2015/04/history_data/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/history_data/</guid>
      <description>RDBで履歴データを保持する方法についてまとめました. そもそも履歴データは, リレーショナルモデルとは相性が悪いので, これが正解!みたいなものはないです.
履歴データとは? スーパーの商品の値段のように, 時間の経過とともに属性の値が変化していくデータがあります. そのようなデータを履歴データと呼びます.
フラグを付ける 最初に一番オーソドックス?な, フラグをつけて管理する方法です.
productsテーブル
   id name price active     1 卵 200 0   2 卵 250 1   3 肉 100 1    activeなデータを取得するときは, SELECT * FROM products WHERE active = 1; とします.
この方法の利点はパッと見に分かりやすいことだと思います. しかし, この方法はバッドノウハウだとされています. 理由を以下にあげます.
 activeフラグはカーディナリティが低く効率が悪い テーブルサイズが時間ともに肥大化し, 検索効率が下がる恐れがある activeの更新は, アプリ側 もしくは, トリガーで制御しなければいけない  単純で分かりやすいですが, あまり使わないほうが良い方法のようです.
範囲を指定する 次は範囲を指定する方法です.</description>
    </item>
    
    <item>
      <title>[ERROR] InnoDB: Cannot allocate memory for the buffer pool の対処法</title>
      <link>https://satoshun.github.io/2015/04/mysql_memory_error/</link>
      <pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/mysql_memory_error/</guid>
      <description>上記のエラーが出たらメモリ不足なので, スワップ領域を作るのが良いと思います.
## swap領域の確認 $ swapon -s Filename Type Size Used Priority ## swap領域の確保 $ sudo dd if=/dev/zero of=/swapfile bs=1024 count=1024k ## swap領域の作成 $ sudo mkswap /swapfile ## swap領域の割り当て $ sudo swapon /swapfile $ swapon -s Filename Type Size Used Priority /swapfile file 1048572 4320 -1 $ free total used free shared buffers cached Mem: 760132 689248 70884 4672 7740 48944 -/+ buffers/cache: 632564 127568 Swap: 1048572 88556 960016 ## 再起動時にもswapを割り当てるように設定 $ sudo vi /etc/fstab  これでおｋ.</description>
    </item>
    
    <item>
      <title>Android: FragmentPagerAdapterでハマった話</title>
      <link>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</guid>
      <description>ハマったのでメモ. 以下のことをしたかった.
 データ取得するまで, Fragment内でProgress Barを出力 ネットワークからデータを取得し, Fragment内にあるAdapterのデータ更新 UIに反映  notifyDataSetChangedメソッドが効かない データが更新した後に FragmentPagerAdapter#notifyDataSetChangedメソッドを叩けばFramentが再生成されるんでしょ?と思っていた時期が僕にもありました. notifyDataSetChangedメソッドを叩いても, データがUIに反映されず, ProgressBarが表示されたままでした.
FragmentPagerAdapterでは, 基本的に一度作られたFragmentは削除されず, notifyDataSetChangedメソッドでデータを更新したよーと知らせても, Fragmentを再生成してくれません.(仕様通り)
これはどうしたものかと思っていろいろ調べたところ, FragmentStatePagerAdapterクラスにいきつきました.
FragmentStatePagerAdapterを使う FragmentPagerAdapterでなくて, FragmentStatePagerAdapterを使えばUIにデータが反映されました.
以下, 実装例になります. まずは, ダメパターンです. FragmentPagerAdapterクラスを使い, Activityでデータを受け取ったら, refreshメソッドを叩くようになっています.
public class PagerAdapter extends FragmentPagerAdapter { ... ... public void refresh() { notifyDataSetChanged(); } }  FragmentPagerAdapterがスーパークラスになっているため, notifyDataSetChangedを何度叩いても, Fragmentが再生成されることはありません. つまり, データを更新した後にUIにデータが反映されません.
次にOKパターンです. FragmentStatePagerAdapterを使い, getItemPositionをOverrideするのがポイントです.
public class PagerAdapter extends FragmentStatePagerAdapter { private List&amp;lt;Fragment&amp;gt; mFragments; ... ... @Override public int getItemPosition(Object object) { Fragment target = (Fragment) object; if (mFragments.</description>
    </item>
    
    <item>
      <title>HTML5: Shadow DOMについて</title>
      <link>https://satoshun.github.io/2015/03/shadow_dom/</link>
      <pubDate>Sat, 14 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/shadow_dom/</guid>
      <description>Web Componentsの機能の一つ Shadow DOMについて説明します.
Shadow DOMとは? 外部から影響を受けない, 外部に影響を与えない隔離された要素です. 「カプセル化されたHTML要素」みたいな感じです.
Shadow DOMの誕生背景 なぜShadow DOMが出てきたかについて説明します.
CSS, JavaScriptは, 全要素に対して影響が及ぶという性質があります.(グローバルに影響を与える) ある箇所を修正したら, 予期せぬ箇所にも影響が出てしまうことがよく起こりますが, これはバグを生み出しやすくとてもよくないです. 例をあげると,
.hoge { font-size: 30px; }  と書くと, hogeをclass属性に持つ要素の文字サイズが30pxになります. 偶然にも他の部分でhogeクラスセレクターを使っていたとしたらそのセレクターにも影響を与えてしまいます. 仮に, 他の人が作ったコンテンツが隔離されて使用できれば, 同じセレクターを使ったとしても, 問題がなくなります.
フロント側が年々複雑になったことにより, スタイルシート, JavaScriptが肥大化した結果, コンテンツを互いに隔離したいという要望が高まり, Shadow DOMが誕生しました.
使い方 Shadow DOMを作るにはcreateShadowRootAPIを使います. 以下, Shadow DOM版Hello Worldです.
&amp;lt;div id=&amp;quot;shadow&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function insertShadow() { // Shadow DOMの作成 var shadow = document.querySelector(&#39;#shadow&#39;).createShadowRoot(); shadow.textContent = &#39;Hello world&#39;; } insertShadow(); &amp;lt;/script&amp;gt;  Shadow DOMが挿入され, Hello Worldと表示されます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Value Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-valueobject/</link>
      <pubDate>Sun, 22 Feb 2015 04:53:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-valueobject/</guid>
      <description>Value Object(値オブジェクト)は, メンバとメソッドを持ちクラスとしての特徴を持つが, immutableであり, identityキー(RDSでいうところのautoincremental id)を持たないオブジェクトのことです. 異なるオブジェクト同士であっても値が等しければ等しいとみなされます. immutableなので, primitive(int, floatなど)な値と同等に扱うことが出来ます.
immutableであるメリット immutableであるメリットとしては
 状態を持たないので, 呼び出し順序を考慮しなくて良い 値が書き換わらないため, thread safeである プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来ることが多い  1, 2つ目は理解できると思うので, 「プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来る」をJavaのコードをあげて説明します.
public static Calendar getYesterday() { Calendar rightnow = Calendar.getInstance(); // ここの時点ではrightnowは, 今の時間を示している rightnow.add(Calendar.DATE, -1); // ここの時点ではrightnowは, 昨日を示している. 変数名rightnowは相応しくない return rightnow; }  上記コードは, 変数rightnowを定義した段階では, 相応しい変数名なのですが, rightnow.add(Calendar.DATE, -1)を実行した段階で, 相応しくない変数名に変わります. これは, Calendarインスタンスが, mutableなためです. このようなコードは混乱を招きます. オブジェクトは初期化したら, セッターなどで値は変更しないほうが, コードをreadableに保つことができ, バグを防ぐことが出来ます.
indentityキーを持たないメリット Value Objectは, 名前の通り, Value(値)に注目しているパターンです. 量などの属性値が重要であり, identityキーには注目していないため, 除去しています. 逆に, identityキーに注目しているパターンのことを, エンティティ(Entity)と言います.</description>
    </item>
    
    <item>
      <title>Go: GojiにPRした話</title>
      <link>https://satoshun.github.io/2015/02/go-pr_goji/</link>
      <pubDate>Sun, 22 Feb 2015 04:11:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-pr_goji/</guid>
      <description>Goにハマりつつあります. 最近家ではGo or Androidって感じです.
最近, GoのWEBフレームのソースコードをちょいちょい読んでいて, GojiにPRをしたのでその話.
Goji? Goji is a minimalistic web framework that values composability and simplicity です. SinatraのようなMicro Frameworkになっています.
どこにPRしたか? バグではなくて, こっちのほうがGoライクにだよ!と思ったのでPRをしました. 計2回PRしたので, それぞれ紹介します.
switch type assertion 1つ目は, switch type assertionについてです. switch文の冒頭にある, type assertionの結果を使うようにしました.
--- a/web/pattern.go +++ b/web/pattern.go @@ -32,13 +32,13 @@ type Pattern interface { } func parsePattern(p interface{}) Pattern { - switch p.(type) { + switch v := p.(type) { case Pattern: - return p.</description>
    </item>
    
    <item>
      <title>Android: strings.xmlのまとめ</title>
      <link>https://satoshun.github.io/2015/02/android-resource_string/</link>
      <pubDate>Sun, 22 Feb 2015 04:10:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-resource_string/</guid>
      <description>res/values/strings.xmlは, 文字列関連のリソースを管理するファイルです. 文字列をプログラム外で定義することで, 多国語の対応, デバッグブルドの時にサーバのURLを変更する等が, コードをいじらずに容易に行えます.
また, 意外といろいろな機能があったので, 紹介したいと思います.
基本的な使い方 &amp;lt;string name=&amp;quot;app_name&amp;quot;&amp;gt;Application&amp;lt;/string&amp;gt;  のように記述して使います. アプリケーション側では, 下のように取得します.
getString(R.string.app_name); or context.getString(R.string.app_name);  特に, 説明はいらないと思います.
arrayの定義 strings.xmlでは単純なkey-valueだけでなく, arrayも定義することができます.
string-array要素で定義してあげます.
&amp;lt;string-array name=&amp;quot;sports&amp;quot;&amp;gt; &amp;lt;item&amp;gt;マラソン&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;野球&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;サッカー&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;卓球&amp;lt;/item&amp;gt; &amp;lt;/string-array&amp;gt;  アプリケーション側では下のように取得します.
getResources().getStringArray(R.array.sports) or context.getResources().getStringArray(R.array.sports)  Contextから直接取得することが出来ないので, 一旦Resourcesを取得し, そこからarrayを取り出します.
値展開 strings.xmlでは, 文字列展開することが出来ます. printf formatのように使います.
&amp;lt;!-- %1: 引数1, $d: 数字 --&amp;gt; &amp;lt;string name=&amp;quot;hoge&amp;quot;&amp;gt;Hello %1$d&amp;lt;/string&amp;gt; &amp;lt;!-- %1: 引数1, %2: 引数2, $s: 文字列 --&amp;gt; &amp;lt;string name=&amp;quot;hogestr&amp;quot;&amp;gt;%1$s %2$d %1$s&amp;lt;/string&amp;gt;  アプリケーション側では, 下のように指定します.</description>
    </item>
    
    <item>
      <title>Android: Pull to Refreshの実装(SwipeRefreshLayout)</title>
      <link>https://satoshun.github.io/2015/02/android-pull_to_refresh/</link>
      <pubDate>Sun, 22 Feb 2015 04:09:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-pull_to_refresh/</guid>
      <description>AndroidでPull to Refreshの実装方法です. ListViewなどを下方向に引っ張ると, データを更新するように出来ます. Gmailとかで使われているあれです.
具体的には, SwipeRefreshLayoutを使って実装します. 以下でコードで説明していきます.
XML側の記述 ListViewに覆いかぶさるように定義します.
&amp;lt;android.support.v4.widget.SwipeRefreshLayout android:id=&amp;quot;@+id/refresh&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt; &amp;lt;ListView android:id=&amp;quot;@android:id/list&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt; &amp;lt;/android.support.v4.widget.SwipeRefreshLayout&amp;gt;  XML側はこれで完了です. これで, ListViewを引っ張ると「Pull to Refresh」のアニメーションが起こります.
Activity側の記述 Pull to Refreshをした時に, イベントが発生するのでListenerを記述します.
実装例です. setOnRefreshListenerでListenerを登録します.
private SwipeRefreshLayout mSwipe; @Override protected void onCreate(Bundle savedInstanceState) { ... mSwipe = (SwipeRefreshLayout) findViewById(R.id.refresh); // Callback登録 mSwipe.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { /* ここに適当な処理を書く */ mSwipe.setRefreshing(false); } }); }  ListViewを引っ張ると, setOnRefreshListenerメソッドがコールされます. setOnRefreshListenerの最後に, setRefreshing(false)をコールします.</description>
    </item>
    
    <item>
      <title>tips: 気軽にローカルにサーバを立てる</title>
      <link>https://satoshun.github.io/2015/02/tips-ser/</link>
      <pubDate>Sun, 22 Feb 2015 02:40:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/tips-ser/</guid>
      <description>サクッとローカルサーバを立てるためのTipsを紹介します.
下記コマンドは, Pythonが入っていれば, 問題なく動きます.
$ python -m CGIHTTPServer Serving HTTP on 0.0.0.0 port 8000 ...  僕は, 上記コマンドをaliasに登録しています.
alias ser=&#39;python -m CGIHTTPServer&#39;  これで, serでサーバが立つようになりました.
ちなみに, Portを指定することも出来ます.
$ ser Serving HTTP on 0.0.0.0 port 8000 ... $ ser 8001 Serving HTTP on 0.0.0.0 port 8001 ...  簡単にローカルサーバを立てることが出来るようになりました.</description>
    </item>
    
    <item>
      <title>CSS: Clearfixについて</title>
      <link>https://satoshun.github.io/2015/02/css-clearfix/</link>
      <pubDate>Sun, 22 Feb 2015 02:32:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/css-clearfix/</guid>
      <description>CSSには「clearfix」と呼ばれるテクニックがあります.
この記事では, なぜclearfixを使うのか, clearfixとは何なのかについて説明します.
floatの問題点 clearfixを説明する前に, floatプロパティの問題点について説明します.
まず例をあげます.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  上記HTMLは, imgが右に寄り, その左側にtest1, test2と表示されます. floatは, 指定したエレメント以降のエレメントを反対側に回りこませることが出来ます.
回りこみを止めたいときは, clear: both;プロパティを指定します.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- clear:bothがないと, このdivも左側に回りこむ --&amp;gt; &amp;lt;div style=&amp;quot;clear:both;&amp;quot;&amp;gt; hogehoge &amp;lt;/div&amp;gt;  clear:both;の記述を忘れると, 後続の意図しないエレメントにも影響を及ぼしてしまうので, 忘れずに指定しなければいけません.
とは言っても, floatingの解除は忘れてしまいがちです. そこでclearfixと呼ばれるテクニックを使います.
clearfixとは clearfixとは, after擬似要素を使いfloatを解除するテクニックです.
具体的には以下のように記述します.
.clearfix:after { content: &amp;quot;&amp;quot;; clear: both; display: block; }  clear: both;をしてくれる要素をafter擬似要素で挿入しているだけです. これを, 親エレメントにつけておけば, floatを解除してくれます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Null Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-null_object/</link>
      <pubDate>Sun, 22 Feb 2015 02:22:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-null_object/</guid>
      <description>Null Objectパターンは, オブジェクト自身にNullかどうかの判定をしてもらうデザインパターンです.
このパターンのメリットは, if (obj == null)のような面倒臭い記述を除去出来るところです. また, ポリモーフィズムにより, nullの時の処理をObjectに委譲することが出来ます. (nullの時の処理を, Objectに持たせることが出来るパターン)
例 例があった方が分かり易いので, 簡単なサンプルプログラムです.
まずは, Null Objectを使わない場合になります.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.format(self.id)) student = Student.get_student(1) if student is not None: student.show() else: print(&#39;not student&#39;)  次にNull objectパターンを使い, if student is not None: を除去します.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.</description>
    </item>
    
    <item>
      <title>AnsibleでGhostアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</guid>
      <description>VPSにGhostを, Ansibleでデプロイしている話.
サーバー側で使っているソフトウェアは, supervisor, nodeです.
GitHubでソース管理 CSS, HTMLを少し弄りたいので, Ghostをforkし, それを編集してデプロイしています.(https://github.com/satoshun/ghost)
このリポジトリを, デプロイしていきます.
デプロイ時の手順 サーバで以下のタスクを行います.
 Gitリポジトリを最新の状態にする(git pull origin master) npm moduleの更新(npm install) gruntの実行(grunt init &amp;amp;&amp;amp; grunt prod) ghostプロセスの再起動(supervisorctl restart ghost)  Playbookは以下になります.
--- - hosts: all user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_source.yml - include: update_package.yml - include: restart.yml  各タスクについて説明していきます.
Git pullする Gitモジュールがあるので, それを使います.
- name: Update Git repository git: repo=&amp;lt;git url&amp;gt; dest=&amp;lt;path to project&amp;gt;  npm moduleの更新 npmモジュールがあるので, それを使います.</description>
    </item>
    
    <item>
      <title>Golang: nil pointer receiverの話</title>
      <link>https://satoshun.github.io/2015/02/go-nil_receiver/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-nil_receiver/</guid>
      <description>nil pointer receiverについてお話しようと思います. 具体例をあげたほうが分かりやすいので, コードを元に説明していきます.
gist: https://gist.github.com/satoshun/3dc1302dbc163c9a9245
にソースコードがあります.
nil pointer receiver nilについて. 下のコードを見てください.
package main import &amp;quot;fmt&amp;quot; type A struct { } func (a *A) b() { fmt.Println(1000) } func main() { var a *A = nil a.b() }  どう考えても, runtime error: nil pointer access 的なものが出るだろうと思っていました.
sato$ go run main.go 1000  ちゃんと実行できました. Goではnilにも型情報があるので, nilの場合でもPointer receiverの場合は実行できるのです! この機能を使えば, Pointer receiverの中でnilの場合に処理を変えることが可能です. 覚えておくと便利だと思います.
ちなみに, Value receiverの場合はエラーが出ます.
package main import &amp;quot;fmt&amp;quot; type A struct { } // b is value receiver func (a A) b() { fmt.</description>
    </item>
    
    <item>
      <title>AnsibleでGoアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-go_deploy/</link>
      <pubDate>Sun, 22 Feb 2015 01:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-go_deploy/</guid>
      <description>ローカルでバイナリを作成し, デプロイするような, Ansible Playbookを書きました. Supervisorでプロセスの管理を行っています.
下の手順でデプロイを行っています.
 Macでコンパイルして, Linux-amd64用のバイナリ生成(注意1) バイナリをサーバにデプロイ(コピー) アプリのリスタート(supervisorで再起動)  実際のPlaybookは以下のようになります.
deploy.yml
--- - hosts: local connection: local tasks: - include: build.yml - hosts: app user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_binary.yml - include: restart.yml  各タスクについて, 説明してきます.
Linux-amd64用のバイナリ生成 Goはデフォルトで, クロスコンパイル出来る機能を持っているので, その機能を使います.
やり方はいろいろあると思うのですが, Makefileを作成して, それをAnsibleから叩くようにして実装しました. Makefileを作る必要ないと思います.
Makefile
get: go get -v build-amd64: get GOOS=linux GOARCH=amd64 go build .  build.yml
--- - name: build src command: make build-amd64 chdir={{ local_home }}  local_homeは変数で, Makefileがあるディレクトリを定義しています.</description>
    </item>
    
    <item>
      <title>様々な言語のフィボナッチ関数</title>
      <link>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</guid>
      <description>Java, JavaScript, Go, Python, Bashでfibonacciを書いてみました.
極力, その言語特有の機能を使って実装するようにしました.
Go type fibonacci intで, int型にfibonacci用の関数を生やしました. せっかくなので, goroutineも使ってみました.
package main import &amp;quot;fmt&amp;quot; type fibonacci int func (self fibonacci) value() chan int { ch := make(chan int, 1) a, b := 0, 1 index := 0 go func() { defer close(ch) for { if int(self) &amp;lt; index { break } a, b = b, a+b index++ ch &amp;lt;- a } }() return ch } func main() { var i fibonacci i = 10 for v := range i.</description>
    </item>
    
  </channel>
</rss>