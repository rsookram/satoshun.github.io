<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on stsnブログ</title>
    <link>https://satoshun.github.io/blog/</link>
    <description>Recent content in Blogs on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sat, 20 Jul 2019 02:57:15 +0000</lastBuildDate>
    
	<atom:link href="https://satoshun.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GitHubのNotificationsで、androidxライブラリのリリースの通知を受け取れるリポジトリを作りました</title>
      <link>https://satoshun.github.io/2019/07/androidx-releases/</link>
      <pubDate>Sat, 20 Jul 2019 02:57:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/androidx-releases/</guid>
      <description> androidxのライブラリのリリースをGitHubのReleases onlyを使って検知するためのリポジトリを作りました。 androidx-releasesにそれぞれのリポジトリがあります。
例えば、Appcompatのリリースを検知したかったら、次の画像のように、androidx-releases/appcompatのNotificationsのReleases Onlyをチェックします。


この状態で、Appcompatに新しいリリースがあったら、GitHubに登録してあるメールアドレスにメールが届きます。


まとめ  作ってみたものの、これが便利なのかは良く分かってないです:D 他のandroidxライブラリのリリースの通知を受けたいなら、androidx-releasesから登録を。 何か他に欲しいandroidxリポジトリがあったら教えてください😃  </description>
    </item>
    
    <item>
      <title>Material Components: MaterialTextViewでlineHeightがTextAppearanceから指定出来るようになりました</title>
      <link>https://satoshun.github.io/2019/07/material-textview/</link>
      <pubDate>Mon, 15 Jul 2019 03:09:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/material-textview/</guid>
      <description> 従来のTextView（AppCompatTextView）では、lineHeightの指定をTextAppearanceから出来ませんでした。
それが、material-component 1.1.0-alpha08にMaterialTextViewが爆誕し、lineHeightがTextAppearanceから指定出来るようになりました🎉
使い方 まずはstyleを定義します。
&amp;lt;style name=&amp;quot;TextAppearance.LineHeight&amp;quot;&amp;gt; &amp;lt;item name=&amp;quot;lineHeight&amp;quot;&amp;gt;20sp&amp;lt;/item&amp;gt; &amp;lt;/style&amp;gt;  次に、TextViewから指定します。
&amp;lt;TextView android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:text=&amp;quot;テスト&amp;quot; android:textAppearance=&amp;quot;@style/TextAppearance.LineHeight&amp;quot; /&amp;gt;  これで完了です😃
MaterialTextViewをXMLから直接指定してもいいのですが、AppCompatActivityを使っていれば、自動的にMaterialTextViewがinflateされるようになっています。 詳しくはMaterialComponentsViewInflater.javaをご覧下さい。
まとめ  material-component 1.1.0-alpha08にアップデートすると、自動的にMaterialTextViewが使われ、TextAppearanceからlineHeightが指定できる😃  </description>
    </item>
    
    <item>
      <title>Android: RestrictToアノテーションのIDE上での振る舞い</title>
      <link>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</link>
      <pubDate>Wed, 03 Jul 2019 12:30:11 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/jetpack-annotation-restrict-to/</guid>
      <description>androidx.annotation:annotationには、RestrictToアノテーションクラスが定義されています。 このアノテーションは次の用途を持ちます。
 Denotes that the annotated element should only be accessed from within a specific scope (as defined by Scope).
 指定したScope以外からのアクセスを制限するアノテーションです。
この記事では、このRestrictToアノテーションがついたクラスに様々な場所からアクセスしたときに、どのようにIDE上で警告が出るかについて見ていきます。
また、Android Studio 3.5.0-beta05で検証しました。
この記事内に出てくるRestrictTo関連のコードは以下のライセンスに従います。
/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.</description>
    </item>
    
    <item>
      <title>Retrofit: Coroutineを使うときの、Response&lt;T&gt;と生のTの使い分け</title>
      <link>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</link>
      <pubDate>Tue, 02 Jul 2019 13:46:54 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/07/retrofit-coroutine-return-type/</guid>
      <description>psideさんの、Retrofit2でRxJavaを使う時の Result, Response, そのままT の使い分け所感のCoroutineバージョンの記事となります。
上記の記事に書いてある、Rxとは違い、Result型は用意されていないので、Response型で包むか、生で値ｗ受け取るかのどちらかが基本となります。
interface HogeService { suspend fun getHoge(): Hoge or suspend fun getHoge(): Response&amp;lt;Hoge&amp;gt; }  Retrofitの2.6.0で、挙動の違いを確認しました。
    生 Response     200 成功 成功   404 例外 成功   ネットワークに繋がっていない 例外 例外   シリアライズが出来ない（型がおかしい） 例外 例外     生の場合、HTTPのstatus Code的に失敗とされるものは例外になる Response型で包めば、HTTPのstatus Code的に失敗だとしても例外が発生しない  っていう感じの挙動になります。
どっちを使えばいいの? サーバがエラーコードを返してきた時に、特別な振る舞いをしたいエンドポイントってあると思うので、そういうときはResponseで包んであげて、それ以外は生でいいんじゃない？って思ってます（小並感</description>
    </item>
    
    <item>
      <title>RxJava 3.xの開発が本格的に始まりました</title>
      <link>https://satoshun.github.io/2019/06/rxjava3-preview/</link>
      <pubDate>Mon, 24 Jun 2019 13:52:14 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/rxjava3-preview/</guid>
      <description>現状での差異をまとめておきます。
RxJava2との差異 READMEから README.md
RxJava2 との差分は以下のようになっています。
 fixed API mistakes and many limits of RxJava 2  RxJava2のいくつかのAPIのミス、制限を直している  intended to be a replacement for RxJava 2 with relatively few binary incompatible changes  APIに多少の変更があり、バイナリ互換がない  test and diagnostic support via test schedulers, test consumers and plugin hooks  テストのサポートの充実   3.x different docsから 3.x different docs
asメソッドとtoメソッド toメソッドはFunction型を引数から取っていた。しかし、あらゆるReactive型でFunction型を受け取っていたので、共通のConverterを作ることが出来なかった。
// Obsevable.java public final &amp;lt;R&amp;gt; R to(Function&amp;lt;? super Observable&amp;lt;T&amp;gt;, R&amp;gt; converter) // Single.</description>
    </item>
    
    <item>
      <title>Kotlinのwildcard importと拡張関数</title>
      <link>https://satoshun.github.io/2019/06/kotlin-wildcard-import-extension-method/</link>
      <pubDate>Wed, 19 Jun 2019 00:48:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/kotlin-wildcard-import-extension-method/</guid>
      <description> Kotlinの公式?ではwildcard importを多様しているなって思っていました。
Roman Elizarovさんが、Extension-oriented design中でちらっとメリットについて話していました。
 You might notice that our Kotlin code usually uses wildcard imports like import com.example.*. It is handy in Kotlin, because importing just a class in Kotlin is rarely enough. All the useful, convenient, utility functions are typically defined in the same package but outside of the class as extension functions.
 まとめると、Javaとは違い、Kotlinでは拡張関数があります。拡張関数の多くは、クラスと同じパッケージに定義されますが、拡張関数なのでクラスの外側に配置されます。wildcard importでは外側に配置された、拡張関数もまとめてimportすることが出来るため便利です。
という理由らしいです。
雑談: wildcard importのデメリット  名前衝突が起きやすい どのような依存があるのかが分かりにくい  レビューのしずらさ  無駄なクラスへの依存が生まれる  </description>
    </item>
    
    <item>
      <title>Google I/O&#39;19: Build a Modular Android App Architectureのまとめ・感想</title>
      <link>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</link>
      <pubDate>Sun, 09 Jun 2019 12:04:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/build-a-modular-android-app-architecture/</guid>
      <description>以下の動画のまとめです。
Build a Modular Android App Architecture (Google I/O&amp;rsquo;19)
なぜモジュール化をするか? スケール モジュール化することで、開発者が独立して開発出来るようになる
 人数が増えてきた時、アプリが大きくなってきた時にモジュール化は有効  保守性 例えば、モノリシックアプリだとレイアウトファイルを1つのディレクトリに持つことになる
 何をしているのか、何をしたいのかが理解しにくい 長いレイアウトファイル名になりがち  ビルド時間の短縮 変更があったモジュール + その依存関係にあるモジュールが再ビルドされるため、ビルド時間が短くなる
CIの高速化 再ビルドが必要なモジュールのみテストをすれば良いので、テスト時間が短くなる
 androidx/dependencyTrackerを使うといい感じにテストが出来る（らしい）  APKサイズの縮小 App Bundle、Dynamic Deliveryの恩恵を受けられる
モジュール どのようにモジュール分けをするか?
1. Feature（機能）ごとに分ける ライブラリモジュールとDynamic Featureモジュールの2種類がある。
 ライブラリモジュール  com.android.libraryを指定する  Dynamic Featureモジュール  onDemand trueとfalseがある  Paidのような一部のユーザが使う機能の場合はtrueが良い Onboardingのように、後でいらなくなる機能の場合はfalseが良い    Plaidでは以下のようなモジュール構成にした。
dribbleと、designernewsがDynamic Featureモジュールになっている。
2. Layer（層、階層）ごとに分ける Plaidでは以下のように分けた。
 Web Servicesの知識はUIはいらないので、implementationを指定する  そうすることで、UIがDTOやRetrofitの知識を知らないですむ  Entitiesの知識はUIが必要なので、apiを指定する  ただし、この場合、DAOsの知識までUIが知ってしまうので微妙  そこでCommon Value Objectsの導入    こうすることで、UIがDAOの知識を知らずに済む</description>
    </item>
    
    <item>
      <title>Dagger2: 2.23に入ったHasAndroidInjectorについて</title>
      <link>https://satoshun.github.io/2019/06/dagger-android-injector/</link>
      <pubDate>Sun, 02 Jun 2019 09:08:57 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/06/dagger-android-injector/</guid>
      <description>Dagger 2.23に新しく、HasAndroidInjectorインターフェースが入りました。 これは、従来のHasActivityInjectorやHasFragmentInjectorなどを置き換えるために作られました。
この記事では、どのように置き換えるかを説明していきたいと思います。
また、DaggerApplicationやDaggerActivityなどの基底クラスは使っていないものとします。
置き換えていく AppComponent AndroidSupportInjectionModuleを使っているなら、AndroidInjectionModuleに置き換えます。 今後は、AndroidSupportInjectionModuleを使う必要はありません。
@Singleton @dagger.Component( modules = [ AndroidInjectionModule::class, // AndroidInjectionModuleを使う ... ] ) interface AppComponent ...  Application Applicationで実装している、HasActivityInjector、HasServiceInjectorなどのHasxxxInjectorをHasAndroidInjectorに置き換えます。
class App : Application(), // HasAndroidInjectorのみでおｋ HasAndroidInjector { // 型変数がAnyになる @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt; // 返り値の型変数がAnyになる override fun androidInjector(): AndroidInjector&amp;lt;Any&amp;gt; { DaggerAppComponent.factory().create(this).inject(this) return androidInjector } }  今まではActivity用、Fragment用、Service用などのクラスごとにDispatchingAndroidInjectorがありましたが、それが1つのDispatchingAndroidInjector&amp;lt;Any&amp;gt;まとまりました。
Activity, Fragment HasSupportFragmentInjectorなどのInjectorは、HasAndroidInjectorに置き換えます。
class MainActivity : AppCompatActivity(), // HasSupportFragmentInjectorの代わりに、HasAndroidInjectorを使う HasAndroidInjector { @Inject lateinit var androidInjector: DispatchingAndroidInjector&amp;lt;Any&amp;gt; override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>ViewModel SavedState &#43; Dagger</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</link>
      <pubDate>Sat, 25 May 2019 10:38:15 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate-dagger/</guid>
      <description>ViewModel + SavedStateでDaggerを使う方法を考えてみました。
前提知識・課題 SavedStateを使う場合、ViewModelにSavedStateHandleインスタンスを渡さなければいけません。
class MyViewModel( private val state: SavedStateHandle ) : ViewModel() { ... }  SavedStateHandleインスタンスを作るために、SavedStateVMFactoryもしくは、AbstractSavedStateVMFactoryを使う必要があります。
生成したいViewModelのコンストラクタの引数がSavedStateHandleのみなら、SavedStateVMFactoryを使います。
// thisはFragmentActivity ViewModelProvider(this, MyViewModel(this)) .get(MyViewModel::class.java)  コンストラクタの引数がSavedStateHandle以外にもあるなら、AbstractSavedStateVMFactoryを拡張します。
class TestViewModel( private val state: SavedStateHandle, private val name: String ) : ViewModel() class TestViewModelFactory( owner: SavedStateRegistryOwner, defaultArgs: Bundle? = null ) : AbstractSavedStateVMFactory(owner, defaultArgs) { override fun &amp;lt;T : ViewModel&amp;gt; create( key: String, modelClass: Class&amp;lt;T&amp;gt;, handle: SavedStateHandle ): T { return TestViewModel(handle, &amp;quot;test&amp;quot;) as T } } // 以下、生成コード ViewModelProvider(this, TestViewModelFactory(this)) .</description>
    </item>
    
    <item>
      <title>雑メモ: ViewModel SavedStateのコードリーディング</title>
      <link>https://satoshun.github.io/2019/05/viewmodel-savedstate/</link>
      <pubDate>Tue, 21 May 2019 23:59:53 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewmodel-savedstate/</guid>
      <description>ViewModelのSavedStateがどのように実現しているのか、内部でどのように動作しているのか気になったので、ソースコードを読んでみました。
この記事のソースコードは全て、下記のライセンスに従います。
/* * Copyright 2019 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ViewPager2 with TabLayout</title>
      <link>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</link>
      <pubDate>Fri, 17 May 2019 04:08:42 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/viewpager2-with-tablayout/</guid>
      <description> Material ComponentsでViewPager2 + TabLayoutのコードが入ったのでそれの紹介。まだalphaへのリリースもされていないので、APIは大きく変わるかもしれません。おそらく1.1.0-alpha07に入ってくると思います。
TabLayoutはViewPagerでサポートされていましたが、それがViewPager2にも来たって感じです。
使い方 新しく追加されたTabLayoutMediatorを使います。
まず、TabLayoutMediatorインスタンスを生成します。
val viewPager: ViewPager2 = findViewById(R.id.viewpager) val tabLayout: TabLayout = findViewById(R.id.tab) val mediator = TabLayoutMediator(tabLayout, viewPager) { tab: TabLayout.Tab, position: Int -&amp;gt; tab.text = &amp;quot;test $position&amp;quot; // タブにタイトルをセット }  コンストラクタには、TabLayout、ViewPager2、OnConfigureTabCallbackを渡します。 OnConfigureTabCallbackは、tabとpositionを受け取り、tabに対して、タイトルをセットします。 ViewPagerのPageAdapterとは違い、RecyclerViewのAdapterからはタイトルを取得できないので、このような変更になったと思われます。
最後にattach関数を呼び出します。
mediator.attach()  これで、ViewPager2 + TabLayoutを実現できます。とても簡単！！
まとめ  ViewPager2もエコシステムが整いつつある😊 今回試したサンプルコードは satoshun-android-example/ViewPager2にあります😃  </description>
    </item>
    
    <item>
      <title>Data Binding 3.5と3.6のまとめ/感想</title>
      <link>https://satoshun.github.io/2019/05/databinding-3dot5/</link>
      <pubDate>Thu, 16 May 2019 00:33:48 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/databinding-3dot5/</guid>
      <description>Google I/O 2019でDataBindingについて少し話されていたので感想とまとめを。 動画だとここらへんになります。
改善系 ビルドの高速化!  20%くらいビルドが早くなった distributed build cache対応 Incremental annotation processing対応  android.databinding.incremental=true を設定にすると使えます   Android Studioとの連携強化!!  Live Class Generation  XMLを変更したら、コンパイルせずともクラス、フィールドにアクセスすることが出来る  リファクタリング系  フィールド名の変更リファクタリングなどをしたときに、XML、コードの両方に反映される   Errorメッセージの改善!!!  DataBinding用のエラーセクションが出来たことで、どこでエラーが出たか特定しやすくなった  新規系 View Binding 簡易版Data Bindingのような立ち位置で、findViewByIdを省略 + コンパイルセーフ + コンパイルを高速にすることを目的に作られました。3.6で入るみたいです。
Data Bindingと比較したときの、メリット、デメリット以下になります。（ただし、まだalphaも出ていない段階なのでI/O動画から見る限りの感想です）
メリット  コンパイルが早くなる  Data Bindingより機能が少なくなるのでそれはそう  &amp;lt;layout&amp;gt;で囲う必要がなくなった  これ個人的には好きでなかったので嬉しい。ネストが減る   デメリット  &amp;lt;data&amp;gt;セクションがなくなる  モデルの値とViewのマッピングはコード側ですることになりそう  多分BindingAdapterは使えない  これもコード側ですることになりそう  双方向バインディングとか使えない  おそらくなんですけど、Data Binding、View Bindingは1つにプロジェクトに混在させることが出来るので、基本View Bindingで、双方向使いたいときはData Bindingみたいな使い方も出来るはずです。</description>
    </item>
    
    <item>
      <title>CameraX: CameraView触ってみた</title>
      <link>https://satoshun.github.io/2019/05/camerax-camera-view/</link>
      <pubDate>Mon, 06 May 2019 05:47:14 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/camerax-camera-view/</guid>
      <description>CameraXのコードが公開されていたので、その中にあったCameraViewを触ってみました。まだ、alphaであることからAPIは大きく変わる可能性があります。
内部の実装であったり、細かい部分はpsideさんの「CameraXのコードがきたので気合い入れて読んでみた」が詳しいです。
環境構築 CameraViewはまだ公開されていないため、ソースコードからビルドする必要があります。また、設定でpublishフラグがfalseになっているので、trueにしてビルドします。
 androidx { name = &amp;quot;Jetpack Camera View Library&amp;quot; - publish = false + publish = true mavenVersion = LibraryVersions.CAMERA mavenGroup = LibraryGroups.CAMERA inceptionYear = &amp;quot;2019&amp;quot; }  使い方 CameraViewは普通のViewのように使うことができます。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout ...&amp;gt; &amp;lt;androidx.camera.view.CameraView android:layout_width=&amp;quot;0dp&amp;quot; android:layout_height=&amp;quot;0dp&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;  次に初期化をします。
cameraView.bindToLifecycle(this) // thisはLifecycleOwner  LifecycleOwnerとCameraViewを結びつけることでLifecycleに合わせて自動でリソースを調整してくれます。 CameraViewはLifecycle-Aware Componentとなっています。非常に扱いやすそうです。
これだけでカメラ機能が使えるようになります！とても簡単！!
以下、CameraViewで現状使えるAPIについて紹介します。
CameraViewで使えるAPI達 モードの変更 CameraViewでは次の3つのモードがあります。
 Image: 写真を取る Video: ビデオを取る Mixed: 両方。ただし、動かない端末もあるらしい  次のように使います。
// Image cameraView.</description>
    </item>
    
    <item>
      <title>MvRxの雑な感想</title>
      <link>https://satoshun.github.io/2019/05/mvrx-architecture/</link>
      <pubDate>Sun, 05 May 2019 05:05:09 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/05/mvrx-architecture/</guid>
      <description> 雑多なことを書いただけのブログになります。内容はあまりないよう〜。
MvRxはAirbnbが開発をしているOSSフレームワークです。
特徴としては
 Kotlinファースト RxJavaを使っている AAC（Android Architecture Components）をベースにしている  AACをRxJavaであったり、便利関数、クラス群で補佐している感じ  多くの部分でReactのAPIを参考にしてる  State、renderなど  Epoxyと相性が良い  一緒に使うことを推奨している ReactのComponentのように振る舞わうことが出来る  ViewModelが保持しているState（状態）に対して、Viewがpure functionのように振る舞う  副作用がない（減らしたい）   ボイラープレートなコードを減らすことが期待できます😃
個人的に気になった部分、好きなとこ StateでView状態を管理するところ Stateを定義することのメリットは以下かなと思ってます。
 Stateを見れば、Viewの構成要素が分かる  MVPアーキテクチャのViewインターフェースのような役割を果たす  状態の管理が楽  Androidでは、configuration changes時の状態の保持が難しいが、Stateだけをケアすれば良い  MvRxの流儀に習って、正しく実装すればよしなに状態の管理をしてくれる   Viewからロジックを取ることが出来る  もちろん実装次第なのですが、StateでViewの状態を表現するようにすれば、Viewはマッピングするだけで良くなる   Asyncがすごい良い MvRxではAsyncというsealed classが定義されていて、
 Uninitialized Loading Success Fail  の4状態を表現することができます。画面の初期値は上記4状態で、大体のケースはケア出来ると思います。
プロジェクトに、Asyncだけ取り入れるのもアリだと思います。
Single Eventの処理をどうするのか State内で保持すると、毎回発火してしまうので、Stateとは違う、他のstreamで表現することになると思う
 invalidateメソッドではなく、直接ViewModelに定義したフィールドを、observeすることになるので、他のページと比較したときに違和感があるかも  やっぱりSingle Eventの取り扱いって大変なんやなって とはいえ、sealed classで定義すれば、同じように見えることが出来ると思うので、大きな話ではない   参考  Tivi  プロジェクトも大きく、Coroutineなども使っている これ見れば、なんとなく肌感は分かると思います   </description>
    </item>
    
    <item>
      <title>Material Components: MotionSpecを使ってアニメーションをカスタマイズする</title>
      <link>https://satoshun.github.io/2019/04/fab-motion-spec/</link>
      <pubDate>Tue, 30 Apr 2019 05:59:41 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/fab-motion-spec/</guid>
      <description>MotionSpecはAndroid material componentsに定義されている1クラスになります。 MotionSpecを使うことで、次のアニメーション属性をカスタマイズすることができます。
 startOffset duration interpolator repeatCount repeatMode  例えば、アニメーションを長くしたいときは、durationの値を長く、アニメーションの開始時間を遅らせたいなら、startOffsetの値を長くします。
FloatingActionButtonを例に、実際にMotionSpecの値をいじってみます。
最初にMotionSpec用のanimator XMLを定義する デフォルトのXMLをコピペしてきて、それをベースにカスタマイズするのが良いと思います。
FloatingActionButton用のXMLはソースコードを読んでいくと、design_fab_show_motion_spec.xmlとdesign_fab_hide_motion_spec.xmlで定義されていることが分かります。MotionSpecは、show/hide用の2種類があり、カスタマイズしたいときは両方とも変更する必要があります。
まずはshow用のMotionSpecを変更していきます。以下がデフォルトで定義されているdesign_fab_show_motion_spec.xmlの中身になります。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!-- Copyright 2017 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    
    <item>
      <title>ConstraintLayout Flowの紹介</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-flow/</link>
      <pubDate>Sun, 28 Apr 2019 11:13:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/constraintlayout-flow/</guid>
      <description>ConstraintLayoutの2.0.0 alpha 5にFlow Virtual Layoutが導入されました🎉 Flowを使うことで、対象のViewを様々なルールで並べることができます。
メリットとしては、次のようなものがあります。
 Viewの階層をフラットに保つことが出来る Flowは普通のViewのように扱う事ができる MotionLayoutと相性が良い  では、どのように書くのかを見ていきます。
1. 配置する方向を決める android:orientationから、horizontal or verticalを指定できます。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt; &amp;lt;androidx.constraintlayout.helper.widget.Flow android:id=&amp;quot;@+id/flow&amp;quot; android:layout_width=&amp;quot;0dp&amp;quot; android:layout_height=&amp;quot;0dp&amp;quot; android:orientation=&amp;quot;horizontal&amp;quot; android:background=&amp;quot;@android:color/white&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt; ...  これはorientationにhorizontalを持ちます。また、通常のViewのように各constraintsを指定し、配置することができます。
2. wrapModeを決める flow_wrapModeで指定することができます。
wrapModeでは、どのようにViewを並べるかを指定でき、3種類のmodeがあります。
 none  単純にsingle lineに並べる  chain  単純に順番に配置していく。その行（列）に収まらない場合は次の行（列）に配置する  aligned  各要素を整列するように配置していく。テーブルのようなイメージ   &amp;lt;androidx.constraintlayout.helper.widget.Flow android:id=&amp;quot;@+id/flow&amp;quot; android:layout_width=&amp;quot;0dp&amp;quot; android:layout_height=&amp;quot;0dp&amp;quot; android:orientation=&amp;quot;horizontal&amp;quot; android:background=&amp;quot;@android:color/white&amp;quot; app:flow_wrapMode=&amp;quot;chain&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt;  これはchainで対象のViewを配置します。
3. 対象のViewを指定する constraint_referenced_idsから指定します。</description>
    </item>
    
    <item>
      <title>Kotlin: プロパティの変更を検知する</title>
      <link>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</link>
      <pubDate>Wed, 24 Apr 2019 02:21:47 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/kotlin-watch-property-change/</guid>
      <description>オブジェクト自身の変更ではなく、対象のオブジェクトが持つプロパティの変更を汎用的に検知する方法の紹介です。
次が、この記事で紹介したいコードです。
// 1つのプロパティの変更を検知したい fun &amp;lt;S, A1&amp;gt; LiveData&amp;lt;S&amp;gt;.watch(prop1: KProperty1&amp;lt;S, A1&amp;gt;): LiveData&amp;lt;A1&amp;gt; = this .map { prop1.get(it) } .distinctUntilChanged() // 2つのプロパティの変更を検知したい fun &amp;lt;S, A1, A2&amp;gt; LiveData&amp;lt;S&amp;gt;.watch( prop1: KProperty1&amp;lt;S, A1&amp;gt;, prop2: KProperty1&amp;lt;S, A2&amp;gt; ): LiveData&amp;lt;Pair&amp;lt;A1, A2&amp;gt;&amp;gt; = this .map { prop1.get(it) to prop2.get(it) } .distinctUntilChanged() // 3つのプロパティの変更を検知したい fun &amp;lt;S, A1, A2, A3&amp;gt; LiveData&amp;lt;S&amp;gt;.watch( prop1: KProperty1&amp;lt;S, A1&amp;gt;, prop2: KProperty1&amp;lt;S, A2&amp;gt;, prop3: KProperty1&amp;lt;S, A3&amp;gt; ): LiveData&amp;lt;Triple&amp;lt;A1, A2, A3&amp;gt;&amp;gt; = this .map { Triple(prop1.get(it), prop2.</description>
    </item>
    
    <item>
      <title>ConstraintLayoutのImageFilterViewって単体でも使えるんやなって</title>
      <link>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</link>
      <pubDate>Mon, 15 Apr 2019 13:17:53 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/constraintlayout-imagefilterview/</guid>
      <description> ConstraintLayout 2.0.0-alphaからImageFilterViewクラスが追加されました。今まで、MotionLayoutと一緒に使うものだから、使い所限られそうだなぁ〜と思っていたのですが、単体でも使えそうだったので、その報告記事になります。
この記事ではConstraintLayout 2.0.0-alpha4を使っています。
角丸にする round属性から指定する事ができます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView android:id=&amp;quot;@+id/image&amp;quot; android:layout_width=&amp;quot;100dp&amp;quot; android:layout_height=&amp;quot;100dp&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;parent&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;parent&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;  彩度 saturation属性から設定することが出来ます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView android:id=&amp;quot;@+id/image&amp;quot; android:layout_width=&amp;quot;100dp&amp;quot; android:layout_height=&amp;quot;100dp&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; app:round=&amp;quot;0.5dp&amp;quot; app:saturation=&amp;quot;0.1&amp;quot; /&amp;gt;  コントラスト contrast属性から設定することが出来ます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView android:id=&amp;quot;@+id/image&amp;quot; android:layout_width=&amp;quot;100dp&amp;quot; android:layout_height=&amp;quot;100dp&amp;quot; app:contrast=&amp;quot;0.5&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; app:round=&amp;quot;0.5dp&amp;quot; /&amp;gt;  暖色、寒色 warmth属性から、暖色、寒色？を設定することできます。
&amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView android:id=&amp;quot;@+id/image&amp;quot; android:layout_width=&amp;quot;100dp&amp;quot; android:layout_height=&amp;quot;100dp&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; app:round=&amp;quot;0.5dp&amp;quot; app:warmth=&amp;quot;2&amp;quot; /&amp;gt;  &amp;lt;androidx.constraintlayout.utils.widget.ImageFilterView android:id=&amp;quot;@+id/image&amp;quot; android:layout_width=&amp;quot;100dp&amp;quot; android:layout_height=&amp;quot;100dp&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; app:round=&amp;quot;0.5dp&amp;quot; app:warmth=&amp;quot;0.5&amp;quot; /&amp;gt;  クロスフェード crossfade属性から設定することが出来ます。ただ、この属性はMotionLayoutと一緒に使うもので、単体では使わないと思います。
まとめ  ImageFilterView、単体でも結構使いどころあるかも😃  </description>
    </item>
    
    <item>
      <title>Dagger 2.22にFactoryクラスが導入されました</title>
      <link>https://satoshun.github.io/2019/04/dagger-component-factory/</link>
      <pubDate>Sun, 07 Apr 2019 06:04:22 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/dagger-component-factory/</guid>
      <description>Dagger 2.22からComponent.Factoryクラスが導入されました。この記事では、簡単な使い方とユースケースを見ていきたいと思います。
Component.Factoryとは? 実は、Component.FactoryでやれることはComponent.Builderクラスとほぼ変わりません。
例えば、次のArticlePresenterインスタンスを生成する2つのコードは本質的にやっていることは同等です。
// Factoryを使う場合 @Component interface AppComponent { val presenter: ArticlePresenter @Component.Factory interface Factory { fun create( @BindsInstance id: Long ): AppComponent } } val component = DaggerAppComponent .factory() .create(50) val presenter = component.presentere --- // Builderを使う場合 @Component interface AppComponent { val presenter: ArticlePresenter @Component.Builder interface Builder { @BindsInstance fun bindId(id: Long): Builder fun build(): AppComponent } } val component = DaggerAppComponent .builder() .bindId(50) .build() val presenter = component.</description>
    </item>
    
    <item>
      <title>DataBindingとActivityのコンストラクタ Layout Id指定を一緒に使う</title>
      <link>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</link>
      <pubDate>Thu, 04 Apr 2019 00:46:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/04/jetpack-coroutine-support/</guid>
      <description>JetpackのActivityとFragmentのコンストラクタに、Layout Idが指定できるようになりました。
 Activity Version 1.0.0-alpha06 Fragment Version 1.1.0-alpha06  これは、次のように使うことが出来ます。
class MainActivity : AppCompatActivity(R.layout.main_act) class MainFragment : Fragment(R.layout.main_frag)  Activityの場合は、setConentViewが。Fragmentの場合はonCreateViewがそれぞれ省略することが出来ます。
ここからが本題です。これをDataBindingと一緒に使うなら、次のようになるかなと思います。
Activityの場合 まずはActvityの例です。
// 拡張関数を定義しておく fun &amp;lt;T : ViewDataBinding&amp;gt; ComponentActivity.bindView(): T = DataBindingUtil.bind(getContentView())!! private fun Activity.getContentView(): View = findViewById&amp;lt;ViewGroup&amp;gt;(android.R.id.content)[0] // MainActivity.kt class MainActivity : AppCompatActivity(R.layout.main_act) { private lateinit var binding: MainActBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = bindView() ... } }  また、Activityの場合に限り、by lazyと組み合わせることも可能です。
class MainActivity : AppCompatActivity(R.</description>
    </item>
    
    <item>
      <title>OkHttp: Java to KotlinのPRを見て勉強する</title>
      <link>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</link>
      <pubDate>Sun, 24 Mar 2019 02:36:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</guid>
      <description>OkHttpがKotlin化をするというISSUEが立てられました。 Upgrade OkHttp 3 to Kotlin and call it OkHttp 4
これの是非についてはさておき。現状、いくつかのJavaコードがKotlinへと置き換わっているので、それらのレビューで気になったこと、知らなかったこと、忘れがちなことを勉強がてらまとめたいと思います。
checkNotNullを使うかどうか could also be code no preference myself
Kotlinの標準ライブラリに、checkNotNullがあります。 これは、値がnullならIllegalStateException例外を投げるものです。
以下のコードは同じ意味を持ちます。
val state = someState ?: throw IllegalStateException(&amp;quot;State must be set beforehand&amp;quot;) val state = checkNotNull(someState) { &amp;quot;State must be set beforehand&amp;quot; }  ただ、no preference myselfと言っている通り、使うかどうかはプロジェクトで分かれそうです。 事前に使うかどうかを、決めておくと揉めなく良さそうだと思いました。
命名はto***が慣用的 idiomatic naming would be toUrl on the Kotlin side
OkHttpでは、HttpUrlをURLに変換するためのメソッドとしてfun url(): URLが定義されています。しかし、fun toUrl(): URLのほうがKotlinっぽいよと指摘がありました。
確かに、言われてみるとAtoBクラス変換のメソッド名は、to***が多い気がします。ただし、今回は下位互換を保つために、一旦この修正は入りませんでした。
constを使う discussion link</description>
    </item>
    
    <item>
      <title>Kotlin: コンストラクタ呼び出しっぽく関数やcompanion objectを使う</title>
      <link>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</link>
      <pubDate>Tue, 19 Mar 2019 12:31:05 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</guid>
      <description> KotlinではJavaと異なり、コンストラクタ呼び出しの時にnewキーワードが必要ありません。
class A ... val a = A()  よって、次のように関数をコンストラクタのように使うことが出来ます。
// Coroutine Jobの定義 @Suppress(&amp;quot;FunctionName&amp;quot;) public fun Job(parent: Job? = null): Job = JobImpl(parent) ... val job = Job()  また、次のようにcompanion object + operator invokeを使うことも出来ます。
// ref: https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter class CoroutineCallAdapterFactory private constructor() : CallAdapter.Factory() { companion object { @JvmStatic @JvmName(&amp;quot;create&amp;quot;) operator fun invoke() = CoroutineCallAdapterFactory() } } ... val factory = CoroutineCallAdapterFactory()  まとめ  JobImplのような実装クラスを隠したいときに便利  </description>
    </item>
    
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。
launch { val task1 = async { MainService.task1() } val task2 = async { MainService.task2() } println(&amp;quot;${task1.await()}\n${task2.await()}&amp;quot;) }  asyncで包むことで、並列に処理をすることができます。
次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元でrunCatchingを使います。
launch { val task1 = async { runCatching { MainService.task1() } } val task2 = async { runCatching { MainService.task2() } } val result1 = task1.await() val result2 = task2.await() println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;) }  runCatchingを使うことで、呼び出し先で例外が起こったとしても、処理を継続することが出来ます。
また、次のように書くことは出来ません。
launch { val task1 = async { MainService.task1() } val task2 = async { MainService.</description>
    </item>
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、 どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。
以下、2019年3月10日 2019年3月11日の調査結果になります。 また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。
Lifecycle
// Lifecycleに従うCoroutineScopeの生成 val Lifecycle.coroutineScope: CoroutineScope  LifecycleOwner
// LifecycleOwnerに従うCoroutineScopeの生成 val LifecycleOwner.lifecycleScope: CoroutineScope  ViewModel
// ViewModelに従うCoroutineScopeの生成 val ViewModel.viewModelScope: CoroutineScope  WorkManager
abstract class CoroutineWorker( appContext: Context, params: WorkerParameters ) : ListenableWorker(appContext, params) { // suspendメソッドで定義された abstract suspend fun doWork(): Result }  Room
// Dao内でsuspendメソッドが使える @Dao interface HogesDao { @Insert suspend fun add(hoge: Hoge) @Query(&amp;quot;SELECT * FROM hoge WHERE id = :id&amp;quot;) suspend fun get(id: String): Hoge .</description>
    </item>
    
    <item>
      <title>Dagger2: ProvidesはKotlin extension methodと一緒に使うことが出来る</title>
      <link>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</link>
      <pubDate>Tue, 05 Mar 2019 00:10:42 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/dagger-provide-with-extension-method/</guid>
      <description>Dagger2のちょっとしたtipsです。
次の2つのメソッドは同じ振る舞いをします。
@Module class MainActivityModule { // 普通の書き方 @Provides fun provideMainContractView(activity: MainActivity): MainContract.View { return activity } // 拡張関数を使った書き方 @Provides fun MainActivity.provideMainContractView(): MainContract.View { return this } }  なぜなら、拡張関数はコンパイルされると次のように解釈されるためです。
... @Provides @NotNull public final MainContract.View provideMainContractView(@NotNull MainActivity $receiver) { Intrinsics.checkParameterIsNotNull($receiver, &amp;quot;receiver$0&amp;quot;); return (MainContract.View)$receiver; } ...  拡張関数として定義したMainActivityは$receiverとなり、引数に入っていることが分かります。拡張関数は上記のように解釈されるため、@Providesと組み合わせて使うことが出来ます。
まとめ 多分、使い所ないと思います😃😃😃</description>
    </item>
    
    <item>
      <title>RxAndroidにPull Requestを出した話</title>
      <link>https://satoshun.github.io/2019/03/rx-android-pull-request/</link>
      <pubDate>Sat, 02 Mar 2019 13:21:05 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/rx-android-pull-request/</guid>
      <description>RxAndroidにIssueを立てて、PRを出した話です。広く使われているOSSプロジェクトに対して、Issueを立てて、テストもセットでPRを出したことがなかったので、それの記念記事になります。
Issueの内容 実際のIssueは HandlerScheduler.scheduleDirect supports async option? になります。
Issueの概要は、RxAndroidは2.1.0でasync messageに対応しました。しかし、これはWorker.scheduleのスケジュールからのみのサポートでした。RxJavaではScheduler.scheduleDirectでもスケジュールされるので、こちらも対応したほうが良いのでは？と思いIssueを立てました。
そもそもこの問題に気づいたきっかけ RxAndroidが2.1.0でasync messageに対応した時に、サンプルで効果を測定したところ、いくつかのオペレータではパフォーマンスの向上が見られないことに気づきました。このときは、サンプルが悪いのか、それとも環境がおかしいのか、またまたこれが意図した挙動なのかが分かりませんでした。とりあえず、自分のタスク管理をしているtodoistに「良く分からないけどパフォーマンスが向上しないパターンがある」みたいなタスクを作って、あとで調べることにしました。
調べ方 クラッシュするわけでもないので、パフォーマンスが向上するパターンと、向上しないパターンでスケジュールのされかたに違いがないかをデバッガーを使い、地道にコードを追いかけました。
結果、Observable.observeOnではWorker.scheduleメソッドでタスクのスケジューリングをし、Maybe.observeOnではScheduler.scheduleDirectメソッドでスケジューリングする違いがあることが分かりました。後は、それぞれのパスでのasync messageの挙動の違いを特定し、修正するだけです。
その他・感想 JakeさんとZacさんにレビューをしてもらった 二人のコードは良く読んでいて、尊敬しているAndroidエンジニアなので、その2人にレビューをしてもらえたのは嬉しかったです😃</description>
    </item>
    
    <item>
      <title>Robolectric &#43; JetpackでActivityのonActivityResultメソッドをテストする</title>
      <link>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</link>
      <pubDate>Sat, 23 Feb 2019 02:47:59 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/androidx-onactivityresult-testing/</guid>
      <description>Robolectric4.xからユニットテスト環境で、android testと（ほぼ?）同じテストコードを動かすことが可能になりました。 まだ、完全に互換性があるとはいえませんが、Espressoライブラリが動く、AndroidJUnit4ランナーが使えるなど、かなりの部分が共通化出来ます。
この記事では、ユニットテストでActivity.onActivityResultのテストをどこまでandroid testのように書けるかを検証します。
テスト対象コード まず最初に、テスト対象コードは次のようになっています。
class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... button.setOnClickListener { startActivityForResult( Intent(this, Sub2Activity::class.java).apply { putExtra(&amp;quot;fuga&amp;quot;, &amp;quot;hoge&amp;quot;) }, 1 ) } } override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent? ) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == 1) { if (resultCode == Activity.RESULT_OK) { val value = data!!.getIntExtra(&amp;quot;test&amp;quot;, -1) button.text = value.toString() } } } }  class Sub2Activity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>マルチモジュールの遷移について考える Part2</title>
      <link>https://satoshun.github.io/2019/02/multi-module_transition_part2/</link>
      <pubDate>Fri, 15 Feb 2019 00:14:56 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/multi-module_transition_part2/</guid>
      <description>マルチモジュール遷移方法Part2です。Part1はここになります😌
Part2では、Navigation Componentを使うパターンを考えてみます。今回はDynamic Feature(DFM)には触れません。いわゆる一般的なライブラリモジュールでの遷移になります。
また、今回の検証に用いたコードはsatoshun/MultiModuleNavigationComponentExampleにあります。
モジュール構成について 細かい実装に入る前に、全体的なモジュール構成を説明します。今回はappモジュールがトップにあり、2つのfeatureモジュールがあるとします。
各featureモジュールでは遷移用インターフェースを持っており、それを用いて他のfeature画面へ遷移をします。遷移用インターフェースの実装はapp内のrouterモジュールで行います。
このモジュール構成のポイントは、各featureモジュール内で自身が使う遷移インターフェースを定義し、appがそのインターフェースの実装を行う点です。このようにすることで、feature間で直接の依存を持つことを防ぐことができます。これは循環依存を避けるためです。
では、実装に入っていきます。今回はDagger2を使って実装をします。
featureモジュール側の遷移用インターフェースの定義 前述の図の通り、各featureモジュール内で遷移用のインターフェースを定義します。ここでは、featureモジュール内で使用するインターフェースを定義します。
main画面からsub1画面に移動したいとします。次のようなインターフェース定義になります。
interface MainModuleRouter { // sub1画面へ移動する fun routeToSub1() }  Mainモジュール用のインターフェースなので、MainModuleRouterという名前にし、sub1画面へ遷移するためのメソッドを定義しています。
そしてこのインターフェースを、MainFragmentで使います。
class MainFragment : Fragment() { @Inject lateinit var moduleRouter: MainModuleRouter ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById&amp;lt;View&amp;gt;(R.id.route).setOnClickListener { moduleRouter.routeToSub1() } } }  これでfeatureモジュールでの遷移用インターフェースの定義は完了です。
次にこのインターフェースの実装をします。
routerモジュール側の遷移用インターフェースの実装 今回は、遷移用インタフェースの実装をrouterモジュールで行います。まずは、Navigation Componentを用いて、Graphを作ります。
&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; android:id=&amp;quot;@+id/nav_graph&amp;quot; app:startDestination=&amp;quot;@id/nav_main_frag&amp;quot;&amp;gt; &amp;lt;fragment android:id=&amp;quot;@+id/nav_main_frag&amp;quot; android:name=&amp;quot;com.github.satoshun.example.feature.main.MainFragment&amp;quot;&amp;gt; &amp;lt;action android:id=&amp;quot;@+id/main_to_sub1&amp;quot; app:destination=&amp;quot;@id/nav_sub1_frag&amp;quot; /&amp;gt; &amp;lt;/fragment&amp;gt; .</description>
    </item>
    
    <item>
      <title>でかいappモジュールがあるときに、中間モジュールを入れることで差分ビルドを上手く効かせる</title>
      <link>https://satoshun.github.io/2019/02/multi-module-speedup/</link>
      <pubDate>Mon, 11 Feb 2019 01:40:29 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/multi-module-speedup/</guid>
      <description>マルチモジュール構成のメリットに差分ビルドの効率化というものがあります。しかし、モノシリックなappモジュールから、マルチモジュール構成に変更していく過程ではappモジュールがでかいままなので、差分ビルドによる恩恵が受けにくいという問題があります。（最終段階まで進めばappモジュールは十分に小さくなるので、差分ビルドの恩恵を受けられます）
例えば、以下のモジュール構成を考えます。
頑張って2つのモジュールを切り出しました。ただし、これではどこのモジュールを変更してもかなりのビルド時間がかかります。なぜなら、Gradleでは依存関係にあるモジュールが変更されたときに、自分自身も（ある程度?）再ビルドされるためです。なので、上記のモジュール構成だと、どこのモジュールを修正しても、常に大きいappモジュールが再ビルドされてしまうため、ビルド時間がかかってしまいます。
そこで、間に中間モジュールを挟むテクニックを紹介します。このテクニックを使うと以下のようになります。
途中に適当なモジュールを挟むことで、サブ1、サブ2が変更されたときにappモジュールの再ビルドを防ぐことができます。
ただし、いくつか条件があります。
1. 中間モジュールで公開可能なものに限る 例えばサブ1でSubActivityを公開していて、これを直接appから参照している場合は駄目です。 これをSubActivityとしてではなく、Activityとして参照できるなら大丈夫です。サブ1モジュールで定義されているクラスがappモジュールから見れないための制約です。
中間モジュールのコードイメージとしては以下のようになります。
fun createUserFragment(userName: String, age: Int): Fragment { return UserFragment.createFragment(userName, age) } fun createUserIntent(context: Context): Intent { return Intent(context, UserActivity::class.java) }  UserActivity、UserFragmentが公開されていないことが分かります。Androidのいわゆるfeatureモジュールでは、Activity、Fragmentを公開する場合が多いと思うので、その場合には有効に使うことができます。
2. implementationで依存を定義する apiを使うと、依存が推移するため再ビルドが行われてしまうためです。implementationで依存を記述する必要があります。
3. Dagger2使ってると多分無理 Dagger2では、解決する依存をAppComponentで知っている必要があります。上記の構成だと、appでAppComponentを持つことになるので、appからsub1、sub2が見えていないと最終的にDagger2で解決できません。なので、中間モジュールで、appからsubの依存が見えなくなるこのパターンは使えません。
詳しくはDagger/#970にあります。
まとめ  やりすぎ感はある  ただでさえ複雑な、モジュール構成がさらに煩雑になりそう。ただし、最終的には消えるので、差分ビルドの恩恵を受けるためのステップだとすれば許せるかも? Dagger2を使っていると推移的依存が必要になり、使えない、もしくは工夫が必要になる  サンプルはsatoshun/ApplicationModulesSpeedUpExampleにあります  サブモジュールを変更したときのビルドは爆速でした😊   Daggerの部分のいい解決方法を知っている人がいたら、教えて頂けると幸いです😊😊😊</description>
    </item>
    
    <item>
      <title>DroidKaigi2019で「R8/ProGuard 徹底比較」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2019/02/droidkaigi-2019/</link>
      <pubDate>Thu, 07 Feb 2019 13:19:13 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/02/droidkaigi-2019/</guid>
      <description>DroidKaigi2019でセッションが採択されたので発表しました。
 https://speakerdeck.com/satoshun/proguard-che-di-bi-jiao
最初に発表の反省点です。
 多く詰め込みすぎて、1つ1つの掘り下げが疎かになった  結果的に広く浅い発表になってしまったため、1つの1つがあまり丁寧に説明できていなかったように感じています。重要な部分はもう少し丁寧に発表すべきでした。  早口すぎ、俺は生き急いでるのか？  本当に申し訳ありませんでした。前日に最終確認したところ20分近くオーバーしてしまい、そこからある程度は間引いたんですが、早口でいくという戦略を取ってしまいました😂 他の方の発表のように聞きやすい発表を今後は意識していきます！   次に良かった点です。
 発表前の休憩時間に、司会の@neonankitiさんの助けで、アイスブレイク?のようなことができた  @neonankitiさんとは初対面だったんですが、謎の掛け合いができ、会場の雰囲気も良くなったように思います😊  なんだかんだとR8のコードを触れたのは良かった  R8コンパイラのコードに触れるかどうか悩んだのですが、printデバッグなどを駆使して、理解が間違っていないことが確認できたので、載せてみました。概要だけですが、個人的には良かったと思っています。  最後に話した実践編のウケが良くてよかった  R8の凄さが分かりやすく伝えられたのかなと思います😊   最後に、僕の発表を聞きに来てくれた人、運営のみなさんありがとうございました😊
また来年もあれば登壇できるように頑張ります💪</description>
    </item>
    
    <item>
      <title>R8/Proguard: JarファイルからProGuard設定ファイルを読み込んでくれるようになりました</title>
      <link>https://satoshun.github.io/2019/01/r8-proguard-metainf/</link>
      <pubDate>Mon, 28 Jan 2019 00:08:35 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-proguard-metainf/</guid>
      <description>AGP3.3.0ProGuardはAGP3.3.0、R8は導入されたAGP3.2.0から、JarファイルのProGuard設定ファイルを組み込めるようになりました。その機能紹介です。 今まで、aarではconsumerProguardFilesで、ライブラリのProGuard設定を指定できました。それのJar、Javaバージョンとなります。
ライブラリ開発者側の設定 RetrofitなどのSquare社のライブラリでは、早くもこの機能に対応しているので、それを例にして説明します。
まず、resources/META-INF/prougardディレクトリの中にProGuardの設定ファイルを置きます。
square/retrofit
ライブラリ側の設定はこれで完了です。
使う側の設定 AGP3.3.0にアップデートするだけで使えます。META-INF/ProGuardはRetrofitの2.5.0から入っているので、まずはMETA-INFが入っていない、2.4.0でビルドをしてみます。
implementation &amp;quot;com.squareup.retrofit2:retrofit:2.4.0&amp;quot; &amp;gt; ./gradlew installRelease ... Warning: there were 267 unresolved references to classes or interfaces. You may need to add missing library jars or update their versions. If your code works fine without the missing classes, you can suppress the warnings with &#39;-dontwarn&#39; options. (http://proguard.sourceforge.net/manual/troubleshooting.html#unresolvedclass) Warning: Exception while processing task java.io.IOException: Please correct the above warnings first. Thread(Tasks limiter_2): destruction  失敗しました😂</description>
    </item>
    
    <item>
      <title>FluxのDispatcherをRoomのin memoryで実装するのは、冗長なコードが多くなるので良くない</title>
      <link>https://satoshun.github.io/2019/01/room-with-flux/</link>
      <pubDate>Thu, 24 Jan 2019 00:43:33 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/room-with-flux/</guid>
      <description>FluxのDispatcherをRoom in memoryで実装すれば最高なのでは?と思い、ちょっと試してみました。
結論から申しますと冗長なコードが多く、良くないと感じました。EventBusや、他のライブラリを使って実装したほうが良いと思います😂
また、オリジナルFluxは「Dispatcherがアプリ内で1つだけ存在する」という原則があったと思いますが、それを破っています。Fluxですらない可能性があります。
Room in memory? Roomではin memoryでデータベースを作ることが出来ます。正確に言えば、SQLiteの機能をRoomのAPIとして開放しています。
使い方は次のようになります。
Room .inMemoryDatabaseBuilder(context, MyDatabase::class.java) .build()  in memoryを使う理由としては、
 ディスパッチするアクションを永続化する必要はないだろう マイグレーションが必要ない  になります。
実装に入っていく では、実装の説明をしていきます。
まずはActionをRoomのEntityとして定義します。
sealed class AuthorAction @Entity(tableName = &amp;quot;author1&amp;quot;) data class Author1( @PrimaryKey val _id: Long = 0, // always 0 val name: String, val age: Int ) : AuthorAction() @Entity(tableName = &amp;quot;author2&amp;quot;) data class Author2( @PrimaryKey val _id: Long = 0, // always 0 val name: String, val age: Int ) : AuthorAction()  Primary keyは常に一定にして、アクションは0 or 1つしか存在しないようにしておきます。仮にアクションの履歴が欲しいなら、@PrimaryKey(autoGenerate = true)を使っても良いと思います。</description>
    </item>
    
    <item>
      <title>R8/Proguard: Daggerの生成コードがR8でどのように変わるかを見る</title>
      <link>https://satoshun.github.io/2019/01/r8-dagger-optimize/</link>
      <pubDate>Sun, 20 Jan 2019 13:55:46 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-dagger-optimize/</guid>
      <description>コードの最適化の話です。この記事では実践に寄せて、Daggerの生成コードがR8によってどのように変化するかを見ます。
まずはサンプルコードです。
@Component( modules = [ AppModule1::class, AppModule2::class ] ) interface AppComponent { @Component.Builder interface Builder { fun build(): AppComponent } fun inject(activity: MainActivity) } @Module class AppModule1 { @Provides fun provideService(): AppService { val retrofit = Retrofit.Builder() ... return retrofit.create() } } @Module object AppModule2 { @JvmStatic @Provides fun provideService2(): AppService2 { val retrofit = Retrofit.Builder() ... return retrofit.create() } } --- class MainActivity : AppCompatActivity() { @Inject lateinit var appService: AppService @Inject lateinit var appService2: AppService2 override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。
Kotlin lambda Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。
例えば、次のコードを最適化なしでコンパイルしてみます。
fun main() { lambdaTest1 { println(&amp;quot;Kotlin lambda1&amp;quot;) } lambdaTest1 { println(&amp;quot;Kotlin lambda2&amp;quot;) } lambdaTest1 { println(&amp;quot;Kotlin lambda3&amp;quot;) } ... } private fun lambdaTest1(body: () -&amp;gt; Unit) { ... body() ... }  // コンパイル後 public static final void main() { LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE); LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE); LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE); ... } final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; { public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1(); LambdaTestKt$main$1() { super(0); } public final void invoke() { System.</description>
    </item>
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。
この記事は、R8 Optimization: Staticizationにとても影響を受けています。
Companion object 例えば、次のコードがあるとします。
class CompanionTest { companion object { fun show(i: Int) { ... } } }  これを最適化なしで変換すると次のようになります。
public final class CompanionTest { public static final Companion Companion = new Companion(); public static final class Companion { private Companion() { } public final void show(int i) { ... } } }  Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。
そこでR8による最適化を行うと次のようになります。
public abstract class CompanionTest { public static final void show(int i) { .</description>
    </item>
    
    <item>
      <title>R8/Proguard: Class Mergingについて</title>
      <link>https://satoshun.github.io/2019/01/r8-merge-method/</link>
      <pubDate>Sun, 20 Jan 2019 02:16:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-merge-method/</guid>
      <description>コードの最適化の話です。この記事ではClass Mergingについて紹介します。
Class Merging? その名の通り、Classをマージする最適化です。最終的なクラス数減らすことが期待出来ます。 Class Mergingには縦方向（Vertical）と、横方向（Horizontal）があります。
まずは縦方向のClass Mergingについて説明します。
縦方向? 縦方向とはスーパータイプの実装が1つだったときに、そのスーパータイプと実装であるサブタイプを1つにまとめる最適化です。
例えば、次の実装は最適化によって1つにまとめられます。
interface IVertical { fun show(i: Int) } class Vertical( private val a: Int ) : IVertical { override fun show(i: Int) { println(&amp;quot;start called $i $a&amp;quot;) } }  &amp;ndash;&amp;gt; Proguard/R8による最適化後 &amp;ndash;&amp;gt;
public final class Vertical { ... public final void show(int i) { ... } }  IVerticalインターフェースが見事に消されていることが分かります。
また、インターフェースではなくabstractクラスの場合はR8の場合のみ上手くマージされました。
 R8: Vertical Merger Proguard: Vertical Merger  次に横方向のマージを紹介します。</description>
    </item>
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>Dependency injection in a multi module projectを見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。
結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。
また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。
検証に用いたコードはsatoshun-android-example/DynamicFeatureDaggerExampleにあります😊
前提知識 通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。 ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。
この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。
そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。
ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。
実装 Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。 実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。
では、実装を始めます。
最初に、SubActivityをDaggerApplicationのように振る舞わさせるためにModuleRootActivityクラスを定義します。 それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。
abstract class ModuleRootActivity : AppCompatActivity(), HasModuleInjector { @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt; private lateinit var injector: ModuleActivityInjector override fun onCreate(savedInstanceState: Bundle?) { injector = moduleComponent.moduleInjector injector.activity.inject(this) super.onCreate(savedInstanceState) } protected abstract val moduleComponent: ModuleActivityComponent override fun supportFragmentInjector(): AndroidInjector&amp;lt;Fragment&amp;gt; = fragmentInjector } class ModuleActivityInjector @Inject constructor( internal val activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; ) interface ModuleActivityComponent { val moduleInjector: ModuleActivityInjector } interface HasModuleInjector : HasSupportFragmentInjector abstract class ModuleChildFragment : Fragment() { override fun onAttach(context: Context) { AndroidSupportInjection.</description>
    </item>
    
    <item>
      <title>dexdumpメモ</title>
      <link>https://satoshun.github.io/2019/01/reading_dexdump_result/</link>
      <pubDate>Sat, 05 Jan 2019 02:15:50 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/reading_dexdump_result/</guid>
      <description>Android build-toolsにはdexdumpというdexファイルを逆アセンブルするツールがあります。 逆アセンブルしたファイルを読みたかったのでそれのメモです。
内容はまとまっていません。自分用のメモレベルの記事になります。
dexファイルをコマンドから作るにはjavacとd8コマンドを使います。d8コマンドは https://r8.googlesource.com/r8 の手順通りにビルドします。
javac *.java // or kotlinc *.kt java -jar $R8_HOME/build/libs/d8.jar --lib $ANDROID_HOME/platforms/android-28/android.jar --release *.class  d8コマンドで出来たdexファイルをdexdumpで逆アセンブルします。
$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex  例えば次のJavaコードを逆アセンブルしてみます。
class Test { public void main() { show(1, 10.0); String[] array = {&amp;quot;&amp;quot;}; toggle(array); fade(); drag(); hide(); click(); hover(); } public String show(int a, double d) { System.out.println(a); return &amp;quot;showed&amp;quot;; } void toggle(String[] args) { System.out.println(&amp;quot;toggle&amp;quot;); } protected void fade() { System.out.println(&amp;quot;fade&amp;quot;); } final protected void drag() { System.</description>
    </item>
    
    <item>
      <title>マルチモジュールの遷移について考える Part1</title>
      <link>https://satoshun.github.io/2018/12/multi-module_transition_part1/</link>
      <pubDate>Mon, 31 Dec 2018 06:19:39 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/multi-module_transition_part1/</guid>
      <description>Androidのトレンドの1つにマルチモジュール構成があります。 マルチモジュールによるメリットとして、
 ビルド時間の短縮 依存関係を各モジュールに閉じ込めることでコードをクリーンに保つことが期待できる  などがあります。大規模なプロジェクトでは上記のメリットは大きいため、マルチモジュールに移行していくことになると思います。
この記事は、マルチモジュールにした際のActivity間の遷移について考えたいと思います。目指すゴールとしては、
 型安全にしたい、もしくはコンパイル時にチェックする機構が欲しい コード量を減らしたい  Part1では、遷移専用のモジュールを作る方法を考えてみます。
サンプルコード: satoshun-android-example/MultiActivityRouterExample
遷移専用のモジュールを作る まず依存関係の構築の原則に、Circular Dependency、循環依存を作り出してはいけないというものがあります。
例えば、メイン画面とサブ画面の2画面があり、それらの画面は相互に行き来するとします。それらをメイン画面モジュール、サブ画面モジュールとして切り出すと次のようになります。
 メインではサブ画面が必要なのでサブモジュールに依存する サブではメイン画面が必要なのでメインモジュールに依存する  これでは循環参照になり、依存関係が壊れてしまうので駄目です。そこでDIP、依存関係逆転の原則を用います。 直接Activityを参照しているのが問題なので、各画面に遷移できる遷移用のインターフェースを定義することで解決を目指します。
そこで、
 メイン画面に遷移するメインルーターモジュール サブ画面に遷移するサブルーターモジュール  の2つのモジュールを作ります。
メインルーターモジュールでは次の遷移専用インターフェースを定義します。
interface MainRouter { fun routeToMain(context: Context): Intent }  そして、メインモジュールで実装します。また、今回はDaggerを使って依存を解決します。
internal class MainRouterImpl @Inject constructor() : MainRouter { override fun routeToMain(context: Context): Intent { return Intent(context, MainActivity::class.java) } } --- @Module internal interface MainActivityModule { @Binds fun bindMainRouter(impl: MainRouterImpl): MainRouter }  これで、使う側であるサブ画面は、メインモジュールに依存するのではなく、メインルーターモジュールに依存し遷移することが出来ます。</description>
    </item>
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、ContinuationInterceptorを使えば上手くいきそうです。
ContinuationInterceptorとは? ContinuationInterceptorは次のようなインターフェースです。
/** * Marks coroutine context element that intercepts coroutine continuations. * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and * intercepts all coroutine continuations with [interceptContinuation] invocations. */ @SinceKotlin(&amp;quot;1.3&amp;quot;) public interface ContinuationInterceptor : CoroutineContext.Element { public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;) ... }  interceptContinuationからContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。
class LifecycleContinuationInterceptor( private val lifecycle: Lifecycle ) : ContinuationInterceptor { override val key: CoroutineContext.</description>
    </item>
    
    <item>
      <title>FragmentとgetViewLifecycleの話</title>
      <link>https://satoshun.github.io/2018/12/view_lifecycle/</link>
      <pubDate>Fri, 21 Dec 2018 07:08:34 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/view_lifecycle/</guid>
      <description>この記事ではFragmentでLiveDataにObserverを登録するときはFragment#getViewLifecycleを使うと良いという話をします。
まず、Fragmentのおおまかなライフサイクルは次のようになっています。
 onAttach onCreate  onCreateView onViewCreated  &amp;hellip;  onDestoryView  onDestroy onDetach  ここで重要なのは、onDestroyが呼ばれることなく、複数回onCreateViewが呼ばれる可能性がある点です。
例えば、次のコードは間違っている可能性があります。
class MainFragment: Fragment() { ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewModel.data.observe(this, Observer { ... }) } }  なぜなら、LiveDataに渡したthis（LifecycleOwner）は、自身のライフサイクルに駆動するためです。 このObserverが開放されるタイミングは、Fragment#onDestroyがコールされたタイミングになります。 しかし前述したとおり、Fragment#onDestroyがコールされずに、複数回onCreateViewがコールされる可能性があるため、前のObserverが開放されずに残ってしまいます。
前述のコードのObserverはFragment本体のLifecycleに駆動されるのではなく、FragmentのViewに駆動するため、この問題が起こります。 よって、FragmentにはView用のLifecycleが用意されています。それが、Fragment#getViewLifecycleです。
前述のコードは次のように書くことが出来ます。
class MainFragment: Fragment() { ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // ViewのLifecycleOwnerを渡す viewModel.data.observe(viewLifecycleOwner, Observer { ... }) } }  このように書くことで、ObserverがViewのライフサイクルに駆動するため、複数のObserverが登録される問題を回避することが出来ます！！</description>
    </item>
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃
基本編 一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。
例えば、次のコードは間違っています。
class MainViewModel @Inject constructor(...): ViewModel() class MainActivity { @Inject lateinit var viewModel: MainViewModel ... }  この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。
class MainViewModel(...): ViewModel() @Module class MainActivityModule { @Provides fun provideMainViewModel(...) : MainViewModel { // ViewModelProviderを使ってインスタンスを生成する return ViewModelProviders.of(...).get(MainViewModel::class.java) } } class MainActivity { @Inject lateinit var viewModel: MainViewModel ... }  @Providesを使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。
また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。 このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。
class MainViewModel(...): ViewModel() or class MainViewModel @Inject constructor(...): ViewModel() @Module class MainActivityModule { @Provides fun provideViewModelFactory(.</description>
    </item>
    
    <item>
      <title>GradleのMatching repositories to dependenciesを使ってライブラリのダウンロード先を指定する</title>
      <link>https://satoshun.github.io/2018/12/gradle_deps_match/</link>
      <pubDate>Thu, 13 Dec 2018 11:16:06 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle_deps_match/</guid>
      <description>JitPackからライブラリをインストールしたかったところ、JCenterからライブラリをインストールしてしまう事件がありました。 詳しくは次のリンクを参照してください。A Confusing Dependency
従来のGradle4系ではおそらく、上記の問題を解決することは出来ない、もしくは非常に困難でした。しかし新しくGradle5.1に Matching repositories to dependencies が導入され、上記の問題を解決できます。（Gradle5.1はまだrcです）
まず最初に従来の書き方を説明して、次に新機能を使った書き方を紹介します。今回は例として、cloudflareのSDKを依存関係に入れることを目指します。 また、今回の検証にはGradle 5.1-rc-1を使いました。サンプルコードはここにあります
まずは従来の書き方です。
// topのbuild.gradle allprojects { repositories { ... maven { url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot; } } } --- // projectのbuild.gradle dependencies { ... implementation &amp;quot;com.cloudflare:cloudflare-mobile-sdk:2.1.0@aar&amp;quot; }  これだと全てのライブラリに対して、repositoriesで指定したhttps://storage.googleapis.com/cloudflare-maven/public/へチェックをしにいきます。このUrlはcloudflareのライブラリにしか使われないことが想定されるので、他のライブラリに対してはダウンロード制限をかけたいところです。
次に新機能を使った書き方です。
// topのbuild.gradle allprojects { repositories { ... maven { url &amp;quot;https://storage.googleapis.com/cloudflare-maven/public/&amp;quot; content { // group idがcom.cloudflareのライブラリだけこのURLが有効になる includeGroup &amp;quot;com.cloudflare&amp;quot; } } } } --- // projectのbuild.gradleは一緒 dependencies { ... implementation &amp;quot;com.</description>
    </item>
    
    <item>
      <title>Truthのメリット、特徴について</title>
      <link>https://satoshun.github.io/2018/12/truth_getting_started/</link>
      <pubDate>Wed, 12 Dec 2018 00:21:12 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/truth_getting_started/</guid>
      <description>TruthはGoogleが開発をしているテストアサーションライブラリです。
従来のJUnitスタイルのアサーションに比べ、大きく2つの利点があります。
 readableにアサーションが書ける デフォルトの失敗メッセージがわかりやすい  それぞれについて説明していきます。
readableにアサーションが書ける ドキュメントのbenefitにあるサンプルを取り上げ説明します。 http://google.github.io/truth/benefits
まず従来のJUnitスタイルを使って書きます。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertFalse(middleName.isPresent());  assertFalse、isPresentを使っており、否定のアサーションなので直感的でなく理解するのに少し時間がかかります。（個人差はあります）
これがTruthを使うと次のようになります。
Optional&amp;lt;String&amp;gt; middleName = user.getMiddleName(); assertThat(middleName).isAbsent();  assertThatはTruthに定義されているメソッドです。middleNameがabsent、値が存在しないことをテストしていることが、JUnitスタイルより強く伝わります。
上記のisAbsentはOptionalのために用意されたアサーションメソッドです。assertThatに渡した引数に適したアサーションを使うことが出来ます。 例えばIterableには、containsAnyInやisEmptyなどが用意されています。型ごとに一般的なテストで行うであろうアサーションが用意されており、readableにconciseに書くことが出来ます。
失敗メッセージがわかりやすい こちらもbenefitにあるサンプルを取り上げます。
まずは従来にJUnitスタイルから。
assertTrue(googleColors.contains(PINK));  この場合、失敗メッセージは特にありません。「trueを表明してる部分にfalseが来た」程度のものしかなく、原因特定するのが大変です。 失敗メッセージをカスタムすることは出来ますが、すべてのアサーションに対して定義するのは骨が折れます。
次にTruthスタイルです。
assertThat(googleColors).contains(PINK);  &amp;lt;[BLUE, RED, YELLOW, BLUE, GREEN, RED]&amp;gt; should have contained &amp;lt;PINK&amp;gt; のようなメッセージが出ます。インスタンス情報や、こうなるべきというメッセージが含まれており原因特定がしやすくなっています。デフォルトの段階でかなり見やすい、わかりやすい失敗メッセージを出力してくれます。
以上がTruthのメリットになります。
補足 Truth-Androidライブラリ JetPackにTruth + Android用のライブラリが追加されました。これを使うことでBundle、IntentなどのAndroid固有のクラスのテストが書きやすくなります。 例えば、Intentには以下のアサーションメソッドを使うことが出来ます。
hasComponent hasComponentClass hasComponentPackage hasPackage hasAction hasNoAction hasData hasType extras categories hasFlags  Intentの中身を確認する便利メソッドが定義されています。Truth-Androidを使うことで、よりAndroid環境でテストが書きやすくなることが期待出来ます。</description>
    </item>
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>Result KEEP
Resultが1.3からstdlibに入ったので紹介をしたいと思います。
ResultはSuccess T | Failure Throwableの2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。
基本的な使い方 使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。
val i: Result&amp;lt;Int&amp;gt; = Result.success(10) val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())  また、runCatching関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。
val a = runCatching { doSomeThing() }  Resultに対する操作は以下のようにします。
// successに対して操作 val i = Result.success(10) i.getOrNull() // 10 i.isSuccess // true i.exceptionOrNull() // null i.map { 10 * 10 }.getOrNull() // 100 i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) } i.recover { 1111 }.getOrNull() // 10 // failureに対して操作 val t = Result.</description>
    </item>
    
    <item>
      <title>Android: namespacedRClassフラグでRクラスを小さく保つ</title>
      <link>https://satoshun.github.io/2018/12/namespacedrclass/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/namespacedrclass/</guid>
      <description>Android Gradle Plugin（以下AGP）3.3のalphaのどこかのタイミングでnamespacedRClassフラグが新しく追加されたので紹介します。 本記事では3.4.0-alpha07で試しました。
まず現状の問題点として、ライブラリモジュールのRクラスのサイズが大きくなる課題があります。それは、ライブラリのRクラスは依存関係にあるRクラスがどんどんマージされていくためです。 それを解決するためにnamespacedRClassが追加されました。使い方は簡単で、次の記述をgradle.propertiesに追加するだけです。
android.namespacedRClass=true  では、これからこのフラグがtrueとfalseでどのようにRクラスの内容が変わるか見ていきます。 例として、appcompatに依存しているライブラリモジュールを用意します。
まずは、namespacedRClass=falseの時のRクラスです。
public final class R { private R() {} public static final class anim { private anim() {} public static final int abc_fade_in = 0x7f010000; public static final int abc_fade_out = 0x7f010001; public static final int abc_grow_fade_in_from_bottom = 0x7f010002; public static final int abc_popup_enter = 0x7f010003; ... ...  依存関係にあるappcompatのRクラスの内容が含まれていることが分かります。
では次に、namespacedRClass=trueの時です。
public final class R { private R() {} public static final class color { private color() {} public static final int red3 = 0x7f04004b; } public static final class id { private id() {} public static final int title = 0x7f0700b1; } public static final class layout { private layout() {} public static final int base3 = 0x7f09001d; } public static final class string { private string() {} public static final int base_string3 = 0x7f0b002a; } }  このモジュールで定義したリソースの内容しか含まれていないことが分かります。appcompatのRクラスは含まれていません。 ライブラリモジュールのRクラスのサイズがかなり小さくすることが出来ました!</description>
    </item>
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>注意 この記事はapiとimplementationの説明をする類の記事ではありません。
GradleでcompileがDeprecatedになり、implementationまたはapiを使うことが推奨されています。 それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。
Dagger2でもcompileをimplementationに置き換えるPRが出されました。https://github.com/google/dagger/pull/1130
内容が興味深かったのでまとめてみようと思います。
まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。
// Add Dagger dependencies dependencies { - compile &#39;com.google.dagger:dagger:2.x&#39; + implementation &#39;com.google.dagger:dagger:2.x&#39; annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39; } - compile &#39;com.google.dagger:dagger-android:2.x&#39; - compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries + implementation &#39;com.google.dagger:dagger-android:2.x&#39; + implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries  ここでjakeさんが
 I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.</description>
    </item>
    
    <item>
      <title>Data Bindingのエラーログが3.4.0-alpha07から見やすくなる</title>
      <link>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/databinding_decrease_error_log/</guid>
      <description>Data BindingとDagger2などのアノテーションプロセッサー系のライブラリを組わせて使うとエラーログが膨大になる問題があります。
それが3.4.0-alpha07以降で改善される見込みです🎉
詳細はここにあります。https://issuetracker.google.com/issues/116541301
この記事ではサンプルコードをベースに、エラーログの変化がどのように変わったかを紹介し、実際にアプリ側のコードをどのように変更するかについて説明します。
サンプルコードはここにあります😃
エラーログの変化 まずどのようなエラーログが出力されるかを見ていきます。 適当にサンプルコードを修正し、Dagger周りのコードでエラーを出して確認してみます。
まずはData Binding 3.2.1から。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:17: error: cannot find symbol protected MainAct79Binding(DataBindingComponent _bindingComponent, View _root, ^ symbol: class DataBindingComponent location: class MainAct79Binding e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/generated/data_binding_base_class_source_out/debug/dataBindingGenBaseClassesDebug/out/com/github/satoshun/example/sample/databinding/MainAct79Binding.java:31: error: cannot find symbol boolean attachToRoot, @Nullable DataBindingComponent component) { ^ ... ... ...  Data Binding周りのエラーログが無限に出ます。悲しい😂
次に3.4.0-alpha07です。
&amp;gt; Task :app:kaptGenerateStubsDebugKotlin e: /Users/stsn/git/github.com/satoshun-android-example/DataBindingApiDeprecateExample/app/build/tmp/kapt3/stubs/debug/com/github/satoshun/example/sample/MainActivityBuilder.java:6: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass()  ちゃんと問題があるコード箇所のみでエラーログが出ました！！Data Binding周りのエラーは出ていません！！嬉しい😃</description>
    </item>
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>注意: 計測方法は実環境に全く即していないので意味がない可能性が高いです。
環境  AGP3.4.0-alpha06 Kotlin 1.3.10 Kotlinx.coroutine 1.0.1 Gradle 5.0  比較対象  kotlinx.coroutineを使ったサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている 300 * 7の2100箇所がCoroutine関連のコードになります  kotlinx.coroutineを使わないサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中で適当なメソッド（Handler().post {}）をコールしている  サンプルコード  計測コマンド Build Scanを使って計測します。その際。build-cacheはoffにします。
./gradlew clean ./gradlew build --no-build-cache --scan  両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。 また試行回数は10回程度で、最終結果のみを以下に掲載します。
kotlinx.coroutineを使う Time spent executing tasks 1m 16.034s All tasks	207	2m 42.833s Tasks avoided	12 (09.7%)	0.062s From cache	0 (00.0%)	0.000s Up-to-date	12 (09.</description>
    </item>
    
    <item>
      <title>MutableなLiveDataを特定のクラス外から更新できなくする</title>
      <link>https://satoshun.github.io/2018/12/livedata_helper/</link>
      <pubDate>Sat, 01 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/livedata_helper/</guid>
      <description>LiveDataの値を更新したい時、MutableLiveDataを使うのが一般的だと思います。
class MainViewModel { val hoge = MutableLiveData&amp;lt;Int&amp;gt;() }  この書き方だと、外のクラスから値を更新することが可能です。
val viewModel = MainViewModel() // ok viewModel.hoge.postValue(10000)  外のクラスからは更新出来ないようにするためにはLiveDataに型変換する必要があります。
例えば次のように書きます。
class MainViewModel { private val _hoge = MutableLiveData&amp;lt;Int&amp;gt;() val hoge: LiveData&amp;lt;Int&amp;gt; = _hoge // ここでLiveDataに型変換 }  こうすることで、外のクラスからはMutableLiveDataが直接見えなくなり、明示的に型変換をしない限りLiveDataの値を更新できなくなります。
ただこの書き方はフィールドの定義が増えるのでとてもめんどくさいです。 なので、それの解決策を以下で紹介します。
その1 まずコードをのせます。
abstract class ViewModel2 { protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.postValue(value: T) { postValue(value) } protected fun &amp;lt;T&amp;gt; ViewModelLiveData2&amp;lt;T&amp;gt;.setValue(value: T) { setValue(value) } }  // ViewModel2と同じパッケージに定義 public class ViewModelLiveData2&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; { @Override protected void postValue(T value) { super.</description>
    </item>
    
    <item>
      <title>Retrofitでカスタムアノテーションを使う</title>
      <link>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/retrofit_custom_annotation/</guid>
      <description>Retrofit 2.5.0からカスタムアノテーションが使えるようになったので、それの紹介です。
例をあげて説明します。特定のリクエストのヘッダーに認証情報を付与したいとします。
まず最初にアノテーションを定義します。
annotation class RequireAuth  次に、上記で定義したアノテーションを使い、Apiを定義します。
interface ApiService { @RequireAuth @GET(&amp;quot;login&amp;quot;) fun login(: retrofit2.Call&amp;lt;Unit&amp;gt; }  次に、RequireAuthを処理するためのokhttp3.Interceptorを定義します。
class AuthInterceptor : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { var request = chain.request() val invocation = request.tag(Invocation::class.java) val authAnnotation = invocation?.method()?.getAnnotation(RequireAuth::class.java) if (authAnnotation != null) { request = request .newBuilder() .addHeader(&amp;quot;Authorization&amp;quot;, &amp;quot;Basic AAAAA&amp;quot;).build() } return chain.proceed(request) } }  ここでのポイントは、val invocation = request.tag(Invocation::class.java)です。 Retrofit 2.5.0からInvocationが追加され、RequestからInvocationが取得できるようになりました。 Invocationには、処理しているRequestのjava.lang.reflect.Methodが格納されており、 そこからアノテーションの情報を取得することができます。</description>
    </item>
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、 そんな夢をみたAndroidエンジニアは数多くいると思います。
この記事ではそんな夢を叶える方法を紹介します。
サンプルコードはここにあります。
FragmentFactory Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。
class MainFragment : Fragment() { @Inject lateinit var userHandler: UserHandler ... }  これをコンストラクタインジェクションにしたい。
class MainFragment @Inject constructor( private val userHandler: UserHandler ) : Fragment() { ... }  androidx.fragment:fragment:1.1.0-alpha01から、FragmentFactoryが追加されました!! これを使うことでコンストラクタインジェクションが可能になります。
MainFragmentインスタンスを生成するFragmentFactoryを作成します。
class MainFragmentFactory @Inject constructor( private val fragment: Provider&amp;lt;MainFragment&amp;gt; ) : FragmentFactory() { override fun instantiate( classLoader: ClassLoader, className: String, args: Bundle? ): Fragment { if (className == MainFragment::class.java.name) { return fragment.get() } return super.</description>
    </item>
    
    <item>
      <title>Kotlin: Contracts &#43; 拡張関数でより便利に</title>
      <link>https://satoshun.github.io/2018/11/more_convenient_contracts/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/more_convenient_contracts/</guid>
      <description>Kotlin 1.3.0からContractsが実装されました。 Contractsを使うことで、関数がどのような振る舞いをするか、どういう効果をもたらすかを定義（契約）することが出来ます。
例えば、isNullOrEmptyメソッドがfalse返すなら、 Contractsによりnullでないことが保証されます。
val a: String? = ... if (!a.isNullOrEmpty()) { println(a.length) // !!が必要ない }  Contractsがない時代だと呼び出し元でisNullOrEmptyがどんな振る舞いをするかを知るすべがなかったので、 !!をつける必要があったのですが、Contractsによりnullでないことが保証できるので、!!を省略できます。
isNullOrEmptyの実装は次のようになります。
@kotlin.internal.InlineOnly public inline fun CharSequence?.isNullOrEmpty(): Boolean { contract { returns(false) implies (this@isNullOrEmpty != null) } return this == null || this.length == 0 }  contractはDSL（関数）として定義されています。 これを呼び出し、そのブロックの中でこの関数が満たす振る舞いを定義する事ができます。
isNullOrEmptyの場合はreturns(false) implies (this@isNullOrEmpty != null)が契約として定義されています。
これは、「returns(false): falseを返すなら (this@isNullOrEmpty != null): 自分自身がnullじゃない」という意味になります。 なので呼び出し元ではfalseが返ってきたら、nullではないことが保証されるので、smartcastにより!!をつける必要がなくなるわけです。
なので、例えばT.isEmpty(t: T?): Booleanのようなメソッドがあり、ついでにnullチェックもこの関数の中でやっているようなときは、 contractを定義することでより使いやすい関数にすることが出来ます。
他の例を見てみます。スコープ関数applyの実装は次になります。
@kotlin.internal.InlineOnly public inline fun &amp;lt;T&amp;gt; T.</description>
    </item>
    
    <item>
      <title>Android: デバッグ時にMoshi、Daggerリフレクションライブラリを使いビルド時間を短縮する</title>
      <link>https://satoshun.github.io/2018/11/debug_reflection/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/debug_reflection/</guid>
      <description>ビルド時間の短縮は開発効率を上げる大きな要素です。 極力kapt（アノテーションプロセッサー）を使わなくすることで、ビルド時間を短縮出来ます。 アノテーションプロセッサーを使ったライブラリは、アノテーションプロセッサーを使わない、 リフレクションを用いたデバッグ用の機能を提供していることがあります。
今回は、MoshiとDaggerリフレクションライブラリの紹介をします。 Daggerリフレクションは絶賛開発中 + 公式ではないので、機能がかなり制限されている、どういう未来が待っているかわからない点に注意してください。
検証に用いたサンプルコードはここにあります。
Moshiリフレクション Moshiにはmoshi-codegenと呼ばれる、アノテーションプロセッサーでコード生成してくれるライブラリがあります。 これは実行時のパフォーマンスには優れているのですが、アノテーションプロセッサーを使っているため、ビルドに時間がかかってしまいます。
そこで、Moshiではmoshi-reflectionと呼ばれるライブラリを提供しており、これはアノテーションプロセッサーを使うことなく、 moshi-codegenと同等の機能を提供してくれます。 ただし、moshi-reflectionは内部でリフレクションを使っているため、実行時のパフォーマンスには優れていません。あくまでデバッグ用、という立ち位置だと思います。
デバッグ時にmoshi-reflectionを使い、リリース時にmoshi-codegenを使うことで、ビルド速度と実効速度の天秤を勝ち取ることが出来ます。
具体的には、デバッグ時、リリース時にbuild.gradleで指定するライブラリを、Moshiに登録するAdapterを変更します。
// bulid.gradle implementation &amp;quot;com.squareup.moshi:moshi:1.8.0&amp;quot; debugImplementation &amp;quot;com.squareup.moshi:moshi-kotlin:1.8.0&amp;quot; kaptRelease &amp;quot;com.squareup.moshi:moshi-kotlin-codegen:1.8.0&amp;quot;  // debug時 fun createMoshiBuilder() = Moshi.Builder() .add(KotlinJsonAdapterFactory()) // KotlinJsonAdapterFactoryを指定する .build() // release時 fun createMoshiBuilder() = Moshi.Builder() .build()  このように書くことで、リリース時のみkaptを実行するようになります。
Daggerリフレクション これはSdkSearch内で開発が行われているライブラリです。有名なAndroidエンジニアであるJake Whartonさんが開発をしています。
これもMoshiと同様に、リフレクションを使っています。 Daggerリフレクションでは、必要最低限のクラスはアノテーションプロセッサーで作成するようになっています。 アノテーションプロセッサーの完全除去というわけではありません。例えば、アノテーションプロセッサーでDaggerAppComponentは作られます。 しかし、かなりの数のクラスを作成しないようになっています。
具体的なコードは、以下のようになります。 Mavenにアップデートされていないので、SdkSearchからソースコードをコピーして使います。
implementation &amp;quot;com.google.dagger:dagger:2.18&amp;quot; debugImplementation project(&#39;:dagger-reflect:reflect&#39;) // SdkSearchからコピー kaptDebug project(&#39;:dagger-reflect:reflect-compiler&#39;) // SdkSearchからコピー kaptRelease &amp;quot;com.google.dagger:dagger-compiler:2.18&amp;quot;  デバッグ時にはDaggerリフレクションを使い、リリース時にはdagger-compilerを使っています。 変更差分はbuild.gradleのみです。コードは全く修正する必要はありません。</description>
    </item>
    
    <item>
      <title>KotlinのNon-Null型にnullを代入する方法</title>
      <link>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</guid>
      <description>Kotlinではnullを扱いやすくするためにNullable、Non-Nullを型で制限することが出来ます。 KotlinのNon-Null型に対してnullを代入しようとすると、代入するタイミングで例外を吐きます。 JavaとKotlinを一緒に使っていると、この例外に遭遇することがあると思います。
具体的には以下の挙動をします。
public class Hoge { // nullを返すメソッド static String getName() { return null; } }  val d: String = Hoge.getName() // ここで例外が投げられる println(d.length) // これは実行されない  このコードは、val d: String = Hoge.getName()でIllegalStateExceptionを投げます。 Non-Null型にnullを代入しようとしているからです。
次に、代入するタイミングで例外を投げなくする方法を紹介します。
具体的には以下のコードで達成できます。
fun &amp;lt;T&amp;gt; castNull(): T = null as T val d: String = castNull() // ここでは例外が投げられない println(d.length) // ここで例外が投げられる  なぜこのような挙動になるのかを説明します。まず castNull()メソッドに定義されたジェネリック型TはAny?をupperに持ちます。 Kotlinはジェネリックを使い、かつNullable型をupperに持つとき、nullかどうかのチェックをしません。これはバイトコードを見れば分かります。
GETSTATIC sample/SampleTestsJVMKt.a : Ljava/lang/String; CHECKCAST java/lang/Object  CHECKCASTしかしておらず、nullかどうかのチェックをしていません。 なので、val d: String = castNull()ではnullチェックがされないため例外が投げられず、実際にメソッドをコールするprintln(d.</description>
    </item>
    
    <item>
      <title>拡張関数 &#43; ジェネリック型でよりタイプセーフを得る</title>
      <link>https://satoshun.github.io/2018/11/extension-typesafe/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/extension-typesafe/</guid>
      <description>Kotlinの拡張関数の話です。
以下のクラスがあったとします。
class A&amp;lt;T&amp;gt;(val value: T) { fun isNull(): Boolean { return value != null } } fun main() { val a1: A&amp;lt;Int&amp;gt; = ... a1.isNull() }  このとき、a1.isNull()の結果は自明です。なぜならA&amp;lt;Int&amp;gt;で宣言している時点でnonNullが確定しているためです。
fun main() { val a2: A&amp;lt;Int?&amp;gt; = ... a2.isNull() }  このとき、a2.isNull()の結果は自明ではありません。 なぜならA&amp;lt;Int?&amp;gt;でジェネリック型を宣言しているので、nullableな値が入ってくる可能性があるためです。
この2つの例から、a1.isNull()はそもそもnonNullなのでisNull()メソッドをコールできないほうが良いのではないか？という考えが浮かびます。
Kotlinの拡張関数を使うことで達成できます。
class A&amp;lt;T&amp;gt;(val value: T) // nullableのときにコールできるようにする fun &amp;lt;T : Any&amp;gt; A&amp;lt;T?&amp;gt;.isNull(): Boolean { return value != null } fun main() { val a1: A&amp;lt;Int&amp;gt; = .</description>
    </item>
    
    <item>
      <title>Kotlinで3つの関数のパラメータを省略する</title>
      <link>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</guid>
      <description>Kotlinでは拡張関数が定義されており、拡張関数を使うことで1つ関数のパラメータを省略できます。
fun hoge(a: String) { println(a) } -&amp;gt; fun String.hoge() { println(this) }  次に、インターフェース（クラス）内で拡張関数を定義することで、さらに1つの関数のパラメータを省略できます。
interface User fun hoge(a: String, b: User) { println(a) println(b) } -&amp;gt; interface User { fun String.hoge() { println(this) println(this@User) } }  さらに、reified type parameterを使うことで、関数のパラメータを省略できます。
fun &amp;lt;T&amp;gt; hoge(a: String, b: User, c: Class&amp;lt;T&amp;gt;) { println(a) println(b) println(c) } -&amp;gt; class User { inline fun &amp;lt;reified T&amp;gt; String.hoge() { println(this) println(this@User) println(T::class) } }  interfaceだと、inline関数が使えないのでクラスで定義してあります。</description>
    </item>
    
    <item>
      <title>UnitテストでViewModelのonClearedをテストする</title>
      <link>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/unittest-viewodel_oncleared/</guid>
      <description>ふとAACのViewModelのonClearedメソッドをテストしたくなったので、 3つのやりかたを紹介します。
環境は
&amp;quot;junit:junit:4.12&amp;quot; &amp;quot;androidx.test:rules:1.1.1&amp;quot; &amp;quot;androidx.test:runner:1.1.1&amp;quot; &amp;quot;androidx.test.ext:junit:1.1.0&amp;quot; &amp;quot;com.nhaarman:mockito-kotlin-kt1.1:1.5.0&amp;quot; &amp;quot;org.robolectric:robolectric:4.1&amp;quot;  になります。
また、サンプルコードは satoshun-android-example/Testsにあるので、参考してください😊
1. ViewModelStoreを使う ViewModelProviders.of(activity).get(class)からViewModelを取得したときに、取得したViewModelはViewModelStoreにキャッシュされます。このViewModelStoreはFragmentActivityから取得できるので、次のように書くことでViewModelのonClearedをテストすることが出来ます。
@RunWith(AndroidJUnit4::class) class BaseViewModelTest { @get:Rule val activityRule = ActivityTestRule(FragmentActivity::class.java) @Test fun `dispose a coroutine when finished lifecycle of ViewModel`() { activityRule.activity.viewModelStore.clear() // ViewModelが開放される } }  このテストはコード的には簡単ですが、ViewModelStoreがViewModelを管理していることを知っている、内部実装の詳細まで知っているため、テストとしてふさわしくない可能性があります。
なので、素直にonDestroyをコールするテストも書いてみます。
2. Instrumentation.callActivityOnDestroyを使う Instrumentationクラスを使うことでActivityのライフサイクルをコントロールすることが出来ます。 InstrumentationはInstrumentationRegistryクラスから取得することができ、次のように書くことで、onDestroyをコールすることができます。
@Test fun `dispose a coroutine when finished lifecycle of ViewModel 2`() { // onDestroyがコールされViewModelが開放される InstrumentationRegistry.getInstrumentation().callActivityOnDestroy(activityRule.activity) }  ActivityのonDestroyがコールされ、ViewModelのonClearedもコールされます！
以下追記
3. ActivityScenarioを使う 新しく追加されたActivityScenarioを使うとよりすっきりとonDestroyを表現することが出来ます。</description>
    </item>
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>（この記事は1.3-M2を使っています。）
Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。
例えば、次のように書くことが出来ます。
inline class UserId(val id: String) { val url get() = &amp;quot;http://$id&amp;quot; } val userId = UserId(&amp;quot;user-dayo&amp;quot;) println(userId.url)  このコードは一見、UserIdインスタンスが生成されそうです。 しかし、コンパイルされたコードではUserIdインスタンスは生成されません。
public static final class UserId$Erased { ... @NotNull public static final String getUrl(String $this) { return &amp;quot;http://&amp;quot; + $this; } ... } String userId = &amp;quot;user-dayo&amp;quot;; String var1 = UserId$Erased.getUrl(userId); System.out.println(var1);  UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成されたUserId$Erasedクラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。
ここからが本題です。 Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。
例えば、次のコードがあったとします。
data class Response( @SerializedName(&amp;quot;user_id&amp;quot;) val userId: String, @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: String )  これはuserIdとfriendIdをStringで受け取っており、このStringが何のStringかの情報が欠落しています。型による分類が出来てない状態です。</description>
    </item>
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>みなさんこんにちは
今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として@Inject lateinit var になってしまうところがあると思います。
class HogeActivity { @Inject lateinit var hoge: Hoge }  これをなんとか出来ないかなと思って考えてみました。
結論から言うと最終形はこのようになります。
class HogeActivity { private val hoge: Hoge by inject() }  private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。
今回はIntoMapを使って実装することにしました。
IntoMapとはその名の通りMapにバインドするためのアノテーションです。 詳しくはドキュメントを見てください。
サンプルコードで説明していきます。
まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。
@Module interface HogeModule { @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any } class Hoge1 @Inject constructor() class Hoge2 @Inject constructor() @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) @MapKey annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)  Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。</description>
    </item>
    
    <item>
      <title>RxAndroidのasyncパラメータを試してみた</title>
      <link>https://satoshun.github.io/2018/08/rx-android-async-parameter/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/rx-android-async-parameter/</guid>
      <description>RxAndroid 2.1.0で新しくasyncパラメータが追加されました。これはMessage#setAsynchronousを使うことで、UIのパフォーマンス向上を狙った機能です。 下のリンクに詳細な内容が書かれています。
RxAndroid’s New Async API
この記事では、asyncがfalseの場合とtrueの場合でどれくらいの差が出るかを検証してみました。
検証に使用したサンプルプロジェクトは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample
サンプルプロジェクトをかいつまんで説明します。
まず2つのスケジューラを作成し、
private val mainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), false) private val asyncMainScheduler = AndroidSchedulers.from(Looper.getMainLooper(), true)  作ったスケジューラを使ったストリームで実行完了時間に差が出るかを試してみました。
// asyncがfalseの場合 Observable .fromCallable { System.currentTimeMillis() } .delay(index, TimeUnit.MILLISECONDS) .observeOn(mainScheduler) .subscribe(...) // asyncがtrueの場合 Observable .fromCallable { System.currentTimeMillis() } .delay(index, TimeUnit.MILLISECONDS) .observeOn(asyncMainScheduler) .subscribe(...)  フルコードは以下になります。 https://github.com/satoshun-android-example/RxAndroidExample/blob/master/app/src/main/java/com/github/satoshun/example/rxandroidexample/MainActivity.kt
結果は、以下のようになりました。
// API27 エミュレータ main=130988ms, async=126713ms　// forで500回ループさせた実行時間の総和 main=130857ms, async=126582ms main=131401ms, async=126909ms main=130763ms, async=126504ms main=132758ms, async=127972ms // API21 エミュレータ main=129869ms, async=125795ms main=130050ms, async=125888ms main=129935ms, async=125853ms main=129908ms, async=125838ms main=129927ms, async=125824ms  asyncがtrueの場合、明らかに実行完了時間が短くなりました。導入するメリットがありそうです。</description>
    </item>
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>Dagge 2.17でfastInitオプションが追加されました。 https://google.github.io/dagger/compiler-options
これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。
確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。
確認に使用したシェルスクリプト adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。
for i in {0..10} do adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt sleep 10 done  下記を参考にしました。
 https://developer.android.com/topic/performance/vitals/launch-time  fastInit有効の場合 下記をbuild.gradleに追加します。
kapt { javacOptions { option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;) } }  結果:
平均: 1609ms  fastInit無効の場合 結果:
平均: 1607ms  まとめ ほぼ変わらない数字が出てきてしまいました。悲しい。 Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。
芳しくない結果になった推測として
 担当アプリのDaggerの書き方が正しくないからこの結果になった?  要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず  確認に使用したコマンドが良くないのかも?  なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊</description>
    </item>
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>結論  R8/Proguardをちゃんと使う  背景 Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。
実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。
まずは、R8無しで調べてみます。
fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  当然メソッドカウントが1増えています。
次に、inlineを付けてみます。
inline fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  こちらもメソッドカウントが1増えました。 show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。
@Metadata( mv = {1, 1, 10}, bv = {1, 0, 2}, k = 2, d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;}, d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;} ) public final class MainActivityKt { public static final void hoge() { String var1 = &amp;quot;hogehoge&amp;quot;; System.</description>
    </item>
    
    <item>
      <title>Android: ContraintLayoutでネガティブマージンを実現する</title>
      <link>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/constraintlayout-negative_margin/</guid>
      <description>ConstraintLayoutはネガティブマージンに対応していないため、少しテクニックを使う必要があります。 この記事ではSpaceを使ったネガティブマージンの実現について説明します。
例 ネガティブマージンと同等の大きさを持ったSpaceを定義して、そこにConstraintを設定するだけです。
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; android:clipToPadding=&amp;quot;false&amp;quot; android:padding=&amp;quot;80dp&amp;quot;&amp;gt; &amp;lt;Space android:id=&amp;quot;@+id/negative&amp;quot; android:layout_width=&amp;quot;15dp&amp;quot; android:layout_height=&amp;quot;15dp&amp;quot; app:layout_constraintStart_toStartOf=&amp;quot;parent&amp;quot; app:layout_constraintTop_toTopOf=&amp;quot;parent&amp;quot; /&amp;gt; &amp;lt;ImageView android:id=&amp;quot;@+id/icon&amp;quot; android:layout_width=&amp;quot;30dp&amp;quot; android:layout_height=&amp;quot;30dp&amp;quot; android:contentDescription=&amp;quot;icon&amp;quot; app:layout_constraintBottom_toBottomOf=&amp;quot;@id/negative&amp;quot; app:layout_constraintEnd_toEndOf=&amp;quot;@id/negative&amp;quot; tools:src=&amp;quot;@tools:sample/avatars&amp;quot; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;  簡単に説明すると、Spaceに15pxを指定して、bottom, endに対してconstraintを指定することで、ネガティブマージンを達成しています。 上記の例だと、
 android:layout_marginStart=&amp;quot;-15px&amp;quot; android:layout_marginTop=&amp;quot;-15px&amp;quot;  と同等の振る舞いをしています。
まとめ ConstraintLayoutではネイティブでネガティブマージンに対応していないため、Spaceを使った、ややテクニカルな方法で実現するのが良いと思われます。</description>
    </item>
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。 https://kotlinlang.org/docs/reference/type-aliases.html
典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。
typealias MyHandler = (Int, String, Any) -&amp;gt; Unit  さらにtypealiasは、アノテーションをつけることも出来ます。
typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;  JvmSuppressWildcardsはDagger(参考リンク)やretrofit(参考リンク)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。</description>
    </item>
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>Daggerを使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。 Androidでは、すべてのActivityで共通のインスタンスを使うには SingletonスコープとAppComponentを組み合わせて使う方法がよく知られています。 しかし、特定のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。SingletonだとすべてのActivity間で共通のインスタンスが使えてしまいます。
この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。 また、基本的なDaggerの使い方は知っている前提で説明していきます。
サンプルコードはこちらになります。 コードを見ると理解がより深まると思うので、ぜひご覧になってください😊
では説明していきます。今回のサンプルコードの目指すところは
 UserScopeを定義し、MainActivity、UserScopedActivityで同一のUserManagerインスタンスを使用する  とします。
まず最初にUserScopeを定義します。
@Scope @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) annotation class UserScope  次にUserSubcomponentを作ります。
@UserScope @Subcomponent interface UserSubcomponent { @Subcomponent.Builder interface Builder { fun build(): UserSubcomponent } val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; }  ここでは、UserSubcomponentにUserScopeスコープを持たせています。 このように書くことで、SubcomponentとScopeを結びつけることが出来ます。
次にAppComponentを作ります。
@Singleton @Component( modules = [ AndroidSupportInjectionModule::class ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; { @Component.Builder interface Builder { @BindsInstance fun application(application: App): Builder fun build(): AppComponent } override fun inject(app: App) // AppComponentとUserSubcomponentを結びつける val userComponentBuilder: UserSubcomponent.</description>
    </item>
    
    <item>
      <title>Android: Navigationのsafeargs Gradle pluginだけを使ってもいいかもしれない</title>
      <link>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</link>
      <pubDate>Sun, 20 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/navigation-only_use_safe_args/</guid>
      <description>Google I/O 2018でJetpackが登場し、新たにNavigationライブラリが導入されました。 ざっくりと説明すると、画面の遷移の実装を助けるライブラリになっています。実装的には、FragmentTransactionを直接いじることがなくなるといったメリットがあります。
このライブラリの機能に、safeargsというものがあります。これが便利で、最初はこの機能だけを使うのもいいのでは? と思っているのでその紹介です。
safeargsを使ってみる 一般的にFragmentに適当な値を渡すときはBundleを通して渡します。
// 呼び出し側 val bundle = Bundle() bundle.putInt(&amp;quot;step&amp;quot;, 10) // 呼び出され側 val step = arguments?.getInt(&amp;quot;step&amp;quot;)  これの問題点としては、typesafeで無いところです。例えばリファクタリングなどで、片方の文字列を&amp;quot;step2&amp;quot;にしてしまうと、ランタイムエラーになります。
これを解決にするためにNavigationではsafe argsという機能を提供しています。 これは、DataBindingのように、クラスを生成することでtypesafeを実現します。
&amp;lt;navigation xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:app=&amp;quot;http://schemas.android.com/apk/res-auto&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;&amp;gt; &amp;lt;fragment android:name=&amp;quot;com.example.android.codelabs.navigation.HogeFragment&amp;quot; android:label=&amp;quot;Hoge&amp;quot;&amp;gt; &amp;lt;argument android:name=&amp;quot;step&amp;quot; app:type=&amp;quot;integer&amp;quot; android:defaultValue=&amp;quot;1&amp;quot;/&amp;gt; &amp;lt;/fragment&amp;gt; &amp;lt;/navigation&amp;gt;  とnavigationを記述すると、
public class HogeFragmentArgs { private int step = 1; private HogeFragmentArgs() { } public static HogeFragmentArgs fromBundle(Bundle bundle) { HogeFragmentArgs result = new HogeFragmentArgs(); if (bundle.containsKey(&amp;quot;step&amp;quot;)) { result.</description>
    </item>
    
    <item>
      <title>Android: 拡張関数でLiveDataのSingle Eventを扱う</title>
      <link>https://satoshun.github.io/2018/05/singlelivedata/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/singlelivedata/</guid>
      <description>LiveDataは最新の値をキャッシュするため、エラー値の取扱などに困ることがあります。 適当なクラスを作るのもいいのですが、拡張関数で表現することも出来るのでその紹介です。
定義は以下のようになります。
fun &amp;lt;T&amp;gt; singleLiveData(): MutableLiveData&amp;lt;T&amp;gt; { // skip用の初期値を入れておく return MutableLiveData&amp;lt;T&amp;gt;().also { it.value = null } } fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.observeSingle(owner: LifecycleOwner, observer: ((T?) -&amp;gt; Unit)) { // 最初の値は常にskipすることで、キャッシュを無視する val firstIgnore = AtomicBoolean(true) this.observe(owner, Observer { if (firstIgnore.getAndSet(false)) return@Observer observer(it) }) }  使う時はこんな感じで使います。
// TestViewModel.kt class TestViewModel: ViewModel() { val errorEvent = singleLiveData&amp;lt;String&amp;gt;() } // TestActivity.kt testViewModel = ViewModelProviders.of(this).get(TestViewModel::class.java) testViewModel.errorEvent.observeSingle(activity) { Log.d(&amp;quot;one&amp;quot;, it.toString()) }  メリットはサブクラスを作らずに済むところです。
参考  https://github.</description>
    </item>
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description> CoroutineBindingライブラリを作ったのでその紹介です。 https://github.com/satoshun/CoroutineBinding
Android開発でCoroutineの流れが来ていると思っていて、RxBindingのような感じで、 CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。
使い方 例えばclickのイベントを受け取りたいとします。 CoroutineBindingでは以下のように書くことが出来ます。
val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root) launch(UI) { for (click in root.clicks()) { Log.d(&amp;quot;clicked&amp;quot;, click.toString()) } }  RxBindingのように使うことが出来ます! 他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。
まとめ  Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい! https://github.com/satoshun/CoroutineBinding 何かあればissueや、PRを貰えると嬉しいです  </description>
    </item>
    
    <item>
      <title>型の声</title>
      <link>https://satoshun.github.io/2018/05/type_feeling/</link>
      <pubDate>Sat, 05 May 2018 03:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/type_feeling/</guid>
      <description>Javaなどのクラスベースの言語でコードを書くときに、実装が最初に思い浮かぶ人は型の声を聞けていません。
まず、オブジェクト指向言語のメリットを考えましょう。メリットの1つに実装ではなく、振る舞いに対して依存できるというものがあります。ポリモーフィズムと呼ばれるテクニックです。 振る舞いは抽象、実装は具象と考えられます。具象は確定することです。未来はこの瞬間に決まります。抽象は保留することです。約束された未来は待っていません。しかし、期待した未来は作り出すことが出来ます。
型は確定ではなく、それぞれの場面で期待している未来を作り出すものです。そうすることで、柔軟性を得ることが出来ます。
人は弱い生き物です。未来を確定させたくなります。しかし、未来を確定させることはあなたの傲慢です。恐れずに型の声を聞き、抽象に注目してください。そうすれば型とつながり、世界とつながれます。あなたのコードに柔軟性、拡張性、そして無限の可能性がやどります。あなたは一人ではありません。

to be continued.</description>
    </item>
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description> ポエムです。
結論 基本的にローカルで明示的に型を宣言するのは好ましくない
問題 Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。
val userName = dataSource.getUserName()  型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。
Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。
まとめ  ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする  </description>
    </item>
    
    <item>
      <title>Android: Data Bindingを使っていると本当のエラーログが出ない話 &#43; 対処法</title>
      <link>https://satoshun.github.io/2018/04/android_improve-error-log/</link>
      <pubDate>Thu, 12 Apr 2018 07:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/android_improve-error-log/</guid>
      <description>問題 Android開発でData Bindingを使っていて、さらにDaggerなどのkaptを必要とするライブラリを使っていると、エラーログが非常に見にくい or エラーログに本当の問題が出てこないことがあります。
理由としては、Data Bindingの生成が失敗すると、MainActivityBindingみたいなクラスが生成されないので、いたるところでBinding クラスの参照エラーが出ます。 デフォルトではエラーを100行?しか出さないようになっているため、参照エラーだけでデフォルトのエラー行数を超えてしまい、本当のエラーが出力されないケースがあります。(大規模なプロジェクトだと起こりがちだと思います)
解決法 全てのエラーログが欲しい時は、build.gradleに以下の記述をすれば良いです
kapt { javacOptions { option(&amp;quot;-Xmaxerrs&amp;quot;, 5000) } }  これは、エラーの行数を増やすための設定です。5000はとりあえずでかい値を入れておけば大丈夫だろうという考えです。
これを入れたことで、弊プロダクトではSupport libraryを27.1.1に上げることに苦労していたのですが、解決することが出来ました。
before(一部ログ修正しています)
... // 長いエラーログ ... ... symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:91: error: cannot find symbol @Nullable ViewGroup root, boolean attachToRoot, @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding e: ActivityMainBinding.java:102: error: cannot find symbol @Nullable DataBindingComponent component) { ^ symbol: class DataBindingComponent location: class ActivityMainBinding :app:kaptProductDebugKotlin FAILED  after</description>
    </item>
    
    <item>
      <title>ActivityやFragmentにコメントを書くことについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_comment/</link>
      <pubDate>Thu, 05 Apr 2018 00:10:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_comment/</guid>
      <description>ポエムです。最近(2018年4月現在)思っていることなので、今後考えが変わる可能性は大いにあります。
例えば以下のようなActivityがあるとします。
class HogeActivity : Activity() { ... ... private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  これを見た時、「なんで loginCount &amp;lt;= 100にしているの? 100回以上ログインしてるんだからヘビーユーザやん?」 って思う可能性があるのでコメントを追加したくなります。
class HogeActivity : Activity() { private fun isHeavyUser(loginCount: Int, firstAccess: Boolean) : Boolean() { // 100回以上ログインした場合は超ヘビーユーザなので100以上はheavy userではない return firstAccess || (loginCount &amp;gt;= 10 &amp;amp;&amp;amp; loginCount &amp;lt;= 100) } }  「超ヘビーユーザっていうのがいて、それにヘビーユーザは含まれていないのね。」というのがコメントから理解できます。
ただ、自分の考えでは上記のコードは根本的に間違っていると思っていて、そもそもActivityでコメントが必要なほど複雑なことをしているのが問題だと思います。 なんでActivityで複雑なことをしてはいけないかというと、ActivtyはContextにアクセスできたりと、なんでも出来るからです。なんでも出来る層でいろいろやってしまうと、 いわゆるfat activity問題が起こってしまいます。</description>
    </item>
    
    <item>
      <title>DroidKaigi2018で「なんとなく動いているProguardから脱出するために」というテーマで発表しました</title>
      <link>https://satoshun.github.io/2018/02/droidkaigi-2018/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/02/droidkaigi-2018/</guid>
      <description>DroidKaigi2018でセッションが採択されたので発表しました。
 https://goo.gl/S95MJs
正直、Proguardは目新しいトピックでないのでそんなに聞きに来てくれないだろうなと思っていました。 しかし、Room3という広い部屋が割り当てられて、さらに当日はかなりの人が聞きに来てくれました。本当に聞きに来てくれた人ありがとうございます😊😊😊
Twitterの反応を見る限りだと、分かりやすいと言っている人が多くいたので嬉しかったです。 Proguardは苦手意識を持っている人が多いと思っていて、なのでstep by stepで順序良く聞けるような発表を心掛けたのでその効果が少しは出たのかなと思っています。
反省点としては、自分が想定したより時間に余裕があったので何か面白いことを喋ろうとしたら何も思いつかないでフガフガしてしまったところです。 今後はフガフガせずに、アドリブ力みたいなものを身につけていきたいと思います!
あと、もう一つ反省点としてすべるのが怖くて積極的にネタみたいなものをスライドに入れられなかったことです。一応考えていたものは
 「Self-Styled Proguardエバンジェリストです」と自己紹介しようとした。 僕の発表資料はProguardに失敗してやや冗長になってしまいましたけど、みなさんのAPKサイズはProguardに成功して小さくなることを期待しています。みたいなことを言おうとした。  みたいなことを言って笑いを取りたかったなと後悔しています(笑いを取れるとは言っていない)。
来年もDroidKaigiあるとしたらCfP出してまた登壇できるように頑張ります。 そして運営の皆さん本当にありがとうございました。凄い楽しかったです(•ө•)♡</description>
    </item>
    
    <item>
      <title>Android: ViewがどのFragmentに属しているかをViewから取得する</title>
      <link>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/android-how_to_get_fragment_from_view/</guid>
      <description>ViewがどのFragmentに属しているかを取得する方法の紹介になります。 前々からtag、id以外の仕組みで取得出来ないかなと考えていたら、GlideでViewからFragmentを取得するコードがありました。
@Nullable private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) { tempViewToSupportFragment.clear(); findAllSupportFragmentsWithViews( activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment); Fragment result = null; View activityRoot = activity.findViewById(android.R.id.content); View current = target; while (!current.equals(activityRoot)) { result = tempViewToSupportFragment.get(current); if (result != null) { break; } if (current.getParent() instanceof View) { current = (View) current.getParent(); } else { break; } } tempViewToSupportFragment.clear(); return result; } private static void findAllSupportFragmentsWithViews( @Nullable Collection&amp;lt;Fragment&amp;gt; topLevelFragments, @NonNull Map&amp;lt;View, Fragment&amp;gt; result) { if (topLevelFragments == null) { return; } for (Fragment fragment : topLevelFragments) { // getFragment()s in the support FragmentManager may contain null values, see #1991.</description>
    </item>
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description> LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。
package android.arch.lifecycle; public abstract class LiveData&amp;lt;T&amp;gt; { protected void onActive() { } }  onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。
package android.arch.lifecycle fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる }  同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。
package android.arch fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // コンパイルエラー &amp;quot;Cannot access &#39;onActive&#39;: it is protected in &#39;LiveData&#39;&amp;quot; }  なぜかこのような挙動になるか? protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。
まとめ protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう
参考  https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a  </description>
    </item>
    
    <item>
      <title>Android: MVP, Dagger2, Retrofitなどなどでアプリを作りました</title>
      <link>https://satoshun.github.io/2015/09/android-app-events/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/09/android-app-events/</guid>
      <description>イベントを検索するAndroidアプリを作成したので, 使った技術のまとめです.
アプリの技術的機能, 特徴は以下になります.
 HTTPを介してイベントのデータを取得する  検索対象のサーバは複数あるため(今回は3つ), どこかでそれらのレスポンスデータを同期する必要がある それら複数のサーバーはJSONを返すが, 微妙にJSONの構造が異なる  Data-Bindingライブラリを使う MVP(Model-View-Presenter)パターンを使う  Activity(Fragment)に機能が集中しないようにしたい!   上記を中心にどのように実装をしたかを説明をしていきます.
フルソースコードはここにあります. https://github.com/satoshun/AndroidEvents
HTTPを介してイベントのデータを取得する connpass, Atnd, Zusaarの3つのAPIを使うことにしました. RetrofitでAPIを定義し, JSONのパースにはGson, データの処理にはRxJavaを使いました.
例えば, connpass APIは以下のように定義しました.
/** Get data from Conpass */ public interface Connpass { @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); @GET(&amp;quot;/v1/event&amp;quot;) Observable&amp;lt;ConnpassResponse&amp;gt; search( @Query(&amp;quot;keyword&amp;quot;) String keyword, @Query(&amp;quot;ymd&amp;quot;) List&amp;lt;String&amp;gt; ymds); }  keywordとymdを指定してリクエストを生成します. 「2015/12/31のAndroidのイベント」のように使う想定です. Retrofitを使うと, このようにinterfaceとして, APIを定義することが出来ます. (https://github.com/satoshun/AndroidEvents/blob/master/app/src/main/java/com/github/satoshun/events/network/Connpass.java#L10)
次に, RxJavaの説明をします. RxJava(Observable)を使うと, 非同期にデータが扱いやすくなります. またデータのマージ(merge)や, フィルタリング(filter)などを簡単に行うことが出来ます.</description>
    </item>
    
    <item>
      <title>Improving Android: 列挙にはenumではなくIntDef, StringDef annotationを使う</title>
      <link>https://satoshun.github.io/2015/08/improve-android-performance1/</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/08/improve-android-performance1/</guid>
      <description>enumの典型的な使い方として, 月(month)や, ネットワークプロコトルなどの, 特定の種類を列挙するために使用されます.
列挙型としてのenumは, 以下のように書くことが出来ます.
enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER } /** 指定した月が何日まであるかを返す */ int getDate(Month month) { //// }  また, enumではなく定数を使うとしたら以下のように書くことが出来ます.
static final int JANUARY = 1; static final int FEBRUARY = 2; static final int MARCH = 3; static final int APRIL = 4; ... static final int NOVEMBER = 11; static final int DECEMBER = 12; /** 指定した月が何日まであるかを返す */ int getDate(int month) { //// }  定数を使うバージョンだと, getDate(int)のため, 予期せぬ値が入ってきてしまう可能性があります.</description>
    </item>
    
    <item>
      <title>Android: Picassoで使われているデザインパターン</title>
      <link>https://satoshun.github.io/2015/06/reading_picasso/</link>
      <pubDate>Fri, 12 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/reading_picasso/</guid>
      <description>Picassoで使われているデザインパターンを紹介する記事です.
Singletonパターン Singletonパターンは, インスタンスの生成を1つに制限するパターンになります.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L672
public static Picasso with(Context context) { if (singleton == null) { synchronized (Picasso.class) { if (singleton == null) { singleton = new Builder(context).build(); } } } return singleton; }  Picasso#withは, すでにPicassoのインスタンス singleton が生成されていればそれを返し, 生成されていなければ, インスタンスを生成して返します.
このパターンのメリットは, インスタンスを多くても1つしか作らないのでメモリ的に有利な点です(使い回せる) しかし, singletonなインスタンスは, 複数のクラスから使われる可能性があるので, スレッドセーフである必要があります.
スレッドセーフにするためには, 全てのfieldの値をfinalにする. 排他的制御を入れるなどの方法があります.
Builderパターン Builderパターンはインスタンス生成時に多数のパラメータが必要なときに便利なパターンです.
https://github.com/square/picasso/blob/d35058278cff55874d133cfd63286dd0f1ff0d50/picasso/src/main/java/com/squareup/picasso/Picasso.java#L702
public static class Builder { private final Context context; private Downloader downloader; private ExecutorService service; private Cache cache; private Listener listener; private RequestTransformer transformer; private List&amp;lt;RequestHandler&amp;gt; requestHandlers; private Bitmap.</description>
    </item>
    
    <item>
      <title>心理学: 人間は合理的な判断は出来ない</title>
      <link>https://satoshun.github.io/2015/06/anchoring_effect/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/06/anchoring_effect/</guid>
      <description>人間は合理的な判断をしているようで, 実はそんなにしていないという話をします.
例: 値引き商品 普段, 1,000円のとんかつ定食があるとします. その日は割引セールで40%OFFの600円になっていました. この時に本来は, 「このとんかつ定食が600円」が高いかどうかで判断を下さないといけません. しかし, 脳では「普段より400円安い!お得!!」と判断し, お得なとんかつ定食を選ぶ可能性があがります.
この現象を, アンカリング効果(Anchoring effect)と呼びます. 1,000円がアンカー(一種の基準)になり, 600円を非常にお得と判断してしまいます. 例えば, 隣の店で全く同じとんかつ定食が600円で売られているとしても, こちらのとんかつ定食がお得だと判断します. これは合理的な判断とはいえません.
ものを販売する時はアンカーを意識して値段設定すると, ユーザの心を揺さぶることが出来ます.
合理的に判断するなら, 割引前の値段には影響を受けてはダメです. メーカーは定価を高めに設定しています. 冷凍食品なんかは常に割引セールをしています.
例: 全く無関係な数字 「値引き商品だったら, なんとなく影響を受けている気がする」という人は多いと思います. しかし, 全く無関係な数字にも人間は影響を受けます.
事前に10 or 50という数字を見せられているとします. 次にAndroid5.0のシェア率答えてもらいます. この時, Android5.0のシェア率に関してなんら情報を持っていなければ, 10 or 50という数字に大きく影響を受けることが分かっています. これは10 or 50という数字が基準(アンカリング)とし, 正解だと思う数字に調整するためです.
これは, 直感的には「そんなことないよと」言いたいところですが, 多くの人間が無関係な数字に影響を受けるようです.
合理的に判断するなら, 事前の数字に影響を受けてはダメです. しかし, よほど意識しない限り人間の脳は無関係な数字にも影響を受けてしまいます.
例: いろいろなレンジ帯の商品群 ある高級マットレスA,Bがあるとします. マットレスAは78,000円, マットレスBは128,000円の時に, マットレスBを選ばせるためにはどうするのがよいでしょうか? それは, マットレスC 488,000円を売り出すことです.
マットレスA 78,000円, マットレスB 128,000円, マットレスC 488,000円とあると, マットレスAだと安すぎて不安, マットレスCだと高すぎるし, ちょうど中間帯のマットレスBを買おうと誘導することが出来ます.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>概要 この記事では, JakeWhartonさんのu2020から, AndroidでDagger2を使うときの実践的な方法を紹介します. u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.
DI, Dagger2の基本について知りたい方は, Part1を見て下さい.
目次
 debugとproductionでModuleを切り替える Debug専用のViewを作る Mockモードの定義 -　まとめ  debugとproductionでModuleを切り替える gradleは, productFlavorsを設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります. そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています. 具体的には,
 /src/production/java/com/jakewharton/u2020/Modules.java /src/internalDebug/java/com/jakewharton/u2020/Modules.java /src/internalRelease/java/com/jakewharton/u2020/Modules.javaに  それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています. これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.
こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.
 Debugのみログを有効にしたい APIのエンドポイントを変えたい debug専用のViewを出したい Test用のインスタンスをinjectしたい etc, etc&amp;hellip;  以下では, より細かく説明していきます.
Debug専用のViewを作る u2020では, Debug専用のView DebugAppContainerがあります. Debug専用のView はこんな感じです. Debugビルドの時は, このContainerをinjectしています.
DebugAppContainerは簡単にいえば, DrawerLayoutを1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.
Mockモードの定義 u2020ではMockモードがあり, Mockデータを表示機能があります.
public final class DebugDataModule { .</description>
    </item>
    
    <item>
      <title>ReactiveX: Hot, Coldの違い</title>
      <link>https://satoshun.github.io/2015/05/hot_cold/</link>
      <pubDate>Fri, 22 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/hot_cold/</guid>
      <description>ReactiveXにおける, Cold/Hot Observableの違いを説明します.
(本文中の「subscribeする」と, 「Observerを登録する」は同義です.)
Cold Observable Cold ObservableはSubscribeされると動作を開始します.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });  例えば, 上のコードだと, sourceを定義した時点ではストリームが生成されておらず, source.subscribeされた時に, 初めてストリームが生成されます. 遅延評価(lazy evaluation)のような振る舞いをします.
次に, 1つのCold Observableに対して複数subscribeしたとします.
var source = Rx.Observable.range(1, 10); // 何か処理 // ... source.subscribe(function(x) { console.log(x); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); source.subscribe(function(x) { console.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. 基本編 Part1</title>
      <link>https://satoshun.github.io/2015/05/dagger2/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2/</guid>
      <description>概要 この記事では, 最初にDIとは何かについて説明します. DIを理解した後にDagger2の基本的な使い方を紹介します. Dagger2はDI(Dependency Injection)をするライブラリです.
DIとは? DIとはDependency Injectionの略で, 訳すと「依存性の注入」です. ここでいう依存とは クラス同士の依存関係のことを表します. クラス同士の依存関係は, 委譲パターンの時に現れます.
例えば, 以下のコードがあったとします.
class Blogger { public Blogger() { } public void post(String title) { // 何かメインの処理 // ... // fileにlogを取る FileLogger logger = new FileLogger(title); logger.logging(); } } class FileLogger implements Logger { @Override public void logging(String... messages) { // fileにmessagesを書き出す File file = new File(&amp;quot;hoge.txt&amp;quot;); ... } } interface Logger { void logging(String messgae); }  クラスBloggerはクラスFileLoggerに依存している.</description>
    </item>
    
    <item>
      <title>Python: Pythonライクな書き方 Part1</title>
      <link>https://satoshun.github.io/2015/04/python-beautiful/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/python-beautiful/</guid>
      <description>Pythonライクな書き方について紹介します. Part1です.
for文関連 indexを使いたいとき Bad: range, lenを使う
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] for i in range(len(names)): print i, names[i]  Good: enumerateを使う
for i, name in enumerate(names): print i, name  2つのコレクションを扱うとき Bad: indexを使ってアクセスする
names = [&#39;TDN&#39;, &#39;suzuki&#39;, &#39;tom&#39;] ages = [12, 19, 11] for i in range(min(len(names), len(ages))): print names[i], ages[i]  Good: 組み込み関数zipを使う
for name, age in zip(names, ages): print name, age  dictionaryでkey, valueを使う Bad: keyでアクセス, valueを取得する</description>
    </item>
    
    <item>
      <title>Android: AndroidKaigiまとめ</title>
      <link>https://satoshun.github.io/2015/04/droid-kaigi/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/droid-kaigi/</guid>
      <description>AndroidKaigiの記事まとめです.
DroidKaigi - Welcome talk   DroidKaigi - Welcome talk  from mhidaka
エンジニアのための勉強会をやるよ!みたいな内容
Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法   Activity, Fragment, CustomView の使い分け - マッチョなActivityにさよならする方法 -  from Yuki Anzai 
CardboardのUXをカメラで向上する   CardboardのUXをカメラで向上する (droidkaigi 2015&amp;frasl;04)  from Kenichi Takahashi 
絶対落ちないアプリの作り方 あるゲームアプリケーションの構成とアップデートサイクル   あるゲームアプリケーションの構成とアップデートサイクル  from Kentaro Iizuka 
開発を効率的に進めるられるまでの道程   開発を効率的に進めるられるまでの道程  from Takao Sumitomo 
アプリの企画、プロトタイプからリリースに至るまで   初学者に嬉しいAndroid開発環境   【DroidKaigi2015】初学者に嬉しいAndroid開発環境(あとMVCとか)  from Hiroyuki Kusu</description>
    </item>
    
    <item>
      <title>データベース: RDBと第1~3正規形について</title>
      <link>https://satoshun.github.io/2015/04/normalization/</link>
      <pubDate>Sun, 19 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/normalization/</guid>
      <description>正規形は, リレーショナルデータベース設計における理論の1つです. 正規化を行うことで, データの重複をなくし, 効率良くデータを保持することが出来ます.
この記事では, リレーショナルデータベースについて説明し, 第1-3正規化について説明します.(BCNF, 第4-6正規化は次の記事で説明します)
リレーショナルデータベースモデル(RDB)について 最初にリレーションについて説明します. リレーションは見出し(heading)と本体(body)からなります. 見出しは, SQLでいうところの属性に相当します. 例えば, 生徒なら下のようなデータを持つと考えられます.
   学生番号 名前 年齢     001 田中 17   002 多田野 19   003 木下 19   004 西岡 18    上記表がリレーションの一例になります. {学生番号, 名前, 年齢}が見出し, {{001, 田中, 17}, {002, 多田野, 19}, {003, 木下, 19}, {004, 西岡, 18}}が本体になります. ここで{}を使っているのは, リレーショナルにおける見出し, 本体はそれぞれタプルで表現されるためです. そのため各要素には順序が存在せず, 重複が許されません(重複があっても意味がない).
ここで集合という言葉が出てきましたが, RDBは集合論 に基づいた理論です.</description>
    </item>
    
    <item>
      <title>データベース: 履歴データについて</title>
      <link>https://satoshun.github.io/2015/04/history_data/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/history_data/</guid>
      <description>RDBで履歴データを保持する方法についてまとめました. そもそも履歴データは, リレーショナルモデルとは相性が悪いので, これが正解!みたいなものはないです.
履歴データとは? スーパーの商品の値段のように, 時間の経過とともに属性の値が変化していくデータがあります. そのようなデータを履歴データと呼びます.
フラグを付ける 最初に一番オーソドックス?な, フラグをつけて管理する方法です.
productsテーブル
   id name price active     1 卵 200 0   2 卵 250 1   3 肉 100 1    activeなデータを取得するときは, SELECT * FROM products WHERE active = 1; とします.
この方法の利点はパッと見に分かりやすいことだと思います. しかし, この方法はバッドノウハウだとされています. 理由を以下にあげます.
 activeフラグはカーディナリティが低く効率が悪い テーブルサイズが時間ともに肥大化し, 検索効率が下がる恐れがある activeの更新は, アプリ側 もしくは, トリガーで制御しなければいけない  単純で分かりやすいですが, あまり使わないほうが良い方法のようです.
範囲を指定する 次は範囲を指定する方法です.</description>
    </item>
    
    <item>
      <title>[ERROR] InnoDB: Cannot allocate memory for the buffer pool の対処法</title>
      <link>https://satoshun.github.io/2015/04/mysql_memory_error/</link>
      <pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/04/mysql_memory_error/</guid>
      <description>上記のエラーが出たらメモリ不足なので, スワップ領域を作るのが良いと思います.
## swap領域の確認 $ swapon -s Filename Type Size Used Priority ## swap領域の確保 $ sudo dd if=/dev/zero of=/swapfile bs=1024 count=1024k ## swap領域の作成 $ sudo mkswap /swapfile ## swap領域の割り当て $ sudo swapon /swapfile $ swapon -s Filename Type Size Used Priority /swapfile file 1048572 4320 -1 $ free total used free shared buffers cached Mem: 760132 689248 70884 4672 7740 48944 -/+ buffers/cache: 632564 127568 Swap: 1048572 88556 960016 ## 再起動時にもswapを割り当てるように設定 $ sudo vi /etc/fstab  これでおｋ.</description>
    </item>
    
    <item>
      <title>Android: FragmentPagerAdapterでハマった話</title>
      <link>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/android-fragment_pager_adapter/</guid>
      <description>ハマったのでメモ. 以下のことをしたかった.
 データ取得するまで, Fragment内でProgress Barを出力 ネットワークからデータを取得し, Fragment内にあるAdapterのデータ更新 UIに反映  notifyDataSetChangedメソッドが効かない データが更新した後に FragmentPagerAdapter#notifyDataSetChangedメソッドを叩けばFramentが再生成されるんでしょ?と思っていた時期が僕にもありました. notifyDataSetChangedメソッドを叩いても, データがUIに反映されず, ProgressBarが表示されたままでした.
FragmentPagerAdapterでは, 基本的に一度作られたFragmentは削除されず, notifyDataSetChangedメソッドでデータを更新したよーと知らせても, Fragmentを再生成してくれません.(仕様通り)
これはどうしたものかと思っていろいろ調べたところ, FragmentStatePagerAdapterクラスにいきつきました.
FragmentStatePagerAdapterを使う FragmentPagerAdapterでなくて, FragmentStatePagerAdapterを使えばUIにデータが反映されました.
以下, 実装例になります. まずは, ダメパターンです. FragmentPagerAdapterクラスを使い, Activityでデータを受け取ったら, refreshメソッドを叩くようになっています.
public class PagerAdapter extends FragmentPagerAdapter { ... ... public void refresh() { notifyDataSetChanged(); } }  FragmentPagerAdapterがスーパークラスになっているため, notifyDataSetChangedを何度叩いても, Fragmentが再生成されることはありません. つまり, データを更新した後にUIにデータが反映されません.
次にOKパターンです. FragmentStatePagerAdapterを使い, getItemPositionをOverrideするのがポイントです.
public class PagerAdapter extends FragmentStatePagerAdapter { private List&amp;lt;Fragment&amp;gt; mFragments; ... ... @Override public int getItemPosition(Object object) { Fragment target = (Fragment) object; if (mFragments.</description>
    </item>
    
    <item>
      <title>HTML5: Shadow DOMについて</title>
      <link>https://satoshun.github.io/2015/03/shadow_dom/</link>
      <pubDate>Sat, 14 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/03/shadow_dom/</guid>
      <description>Web Componentsの機能の一つ Shadow DOMについて説明します.
Shadow DOMとは? 外部から影響を受けない, 外部に影響を与えない隔離された要素です. 「カプセル化されたHTML要素」みたいな感じです.
Shadow DOMの誕生背景 なぜShadow DOMが出てきたかについて説明します.
CSS, JavaScriptは, 全要素に対して影響が及ぶという性質があります.(グローバルに影響を与える) ある箇所を修正したら, 予期せぬ箇所にも影響が出てしまうことがよく起こりますが, これはバグを生み出しやすくとてもよくないです. 例をあげると,
.hoge { font-size: 30px; }  と書くと, hogeをclass属性に持つ要素の文字サイズが30pxになります. 偶然にも他の部分でhogeクラスセレクターを使っていたとしたらそのセレクターにも影響を与えてしまいます. 仮に, 他の人が作ったコンテンツが隔離されて使用できれば, 同じセレクターを使ったとしても, 問題がなくなります.
フロント側が年々複雑になったことにより, スタイルシート, JavaScriptが肥大化した結果, コンテンツを互いに隔離したいという要望が高まり, Shadow DOMが誕生しました.
使い方 Shadow DOMを作るにはcreateShadowRootAPIを使います. 以下, Shadow DOM版Hello Worldです.
&amp;lt;div id=&amp;quot;shadow&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function insertShadow() { // Shadow DOMの作成 var shadow = document.querySelector(&#39;#shadow&#39;).createShadowRoot(); shadow.textContent = &#39;Hello world&#39;; } insertShadow(); &amp;lt;/script&amp;gt;  Shadow DOMが挿入され, Hello Worldと表示されます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Value Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-valueobject/</link>
      <pubDate>Sun, 22 Feb 2015 04:53:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-valueobject/</guid>
      <description>Value Object(値オブジェクト)は, メンバとメソッドを持ちクラスとしての特徴を持つが, immutableであり, identityキー(RDSでいうところのautoincremental id)を持たないオブジェクトのことです. 異なるオブジェクト同士であっても値が等しければ等しいとみなされます. immutableなので, primitive(int, floatなど)な値と同等に扱うことが出来ます.
immutableであるメリット immutableであるメリットとしては
 状態を持たないので, 呼び出し順序を考慮しなくて良い 値が書き換わらないため, thread safeである プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来ることが多い  1, 2つ目は理解できると思うので, 「プログラムの途中でオブジェクトの特徴が変わることがないため, プログラムをreadableに保つことが出来る」をJavaのコードをあげて説明します.
public static Calendar getYesterday() { Calendar rightnow = Calendar.getInstance(); // ここの時点ではrightnowは, 今の時間を示している rightnow.add(Calendar.DATE, -1); // ここの時点ではrightnowは, 昨日を示している. 変数名rightnowは相応しくない return rightnow; }  上記コードは, 変数rightnowを定義した段階では, 相応しい変数名なのですが, rightnow.add(Calendar.DATE, -1)を実行した段階で, 相応しくない変数名に変わります. これは, Calendarインスタンスが, mutableなためです. このようなコードは混乱を招きます. オブジェクトは初期化したら, セッターなどで値は変更しないほうが, コードをreadableに保つことができ, バグを防ぐことが出来ます.
indentityキーを持たないメリット Value Objectは, 名前の通り, Value(値)に注目しているパターンです. 量などの属性値が重要であり, identityキーには注目していないため, 除去しています. 逆に, identityキーに注目しているパターンのことを, エンティティ(Entity)と言います.</description>
    </item>
    
    <item>
      <title>Go: GojiにPRした話</title>
      <link>https://satoshun.github.io/2015/02/go-pr_goji/</link>
      <pubDate>Sun, 22 Feb 2015 04:11:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-pr_goji/</guid>
      <description>Goにハマりつつあります. 最近家ではGo or Androidって感じです.
最近, GoのWEBフレームのソースコードをちょいちょい読んでいて, GojiにPRをしたのでその話.
Goji? Goji is a minimalistic web framework that values composability and simplicity です. SinatraのようなMicro Frameworkになっています.
どこにPRしたか? バグではなくて, こっちのほうがGoライクにだよ!と思ったのでPRをしました. 計2回PRしたので, それぞれ紹介します.
switch type assertion 1つ目は, switch type assertionについてです. switch文の冒頭にある, type assertionの結果を使うようにしました.
--- a/web/pattern.go +++ b/web/pattern.go @@ -32,13 +32,13 @@ type Pattern interface { } func parsePattern(p interface{}) Pattern { - switch p.(type) { + switch v := p.(type) { case Pattern: - return p.</description>
    </item>
    
    <item>
      <title>Android: strings.xmlのまとめ</title>
      <link>https://satoshun.github.io/2015/02/android-resource_string/</link>
      <pubDate>Sun, 22 Feb 2015 04:10:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-resource_string/</guid>
      <description>res/values/strings.xmlは, 文字列関連のリソースを管理するファイルです. 文字列をプログラム外で定義することで, 多国語の対応, デバッグブルドの時にサーバのURLを変更する等が, コードをいじらずに容易に行えます.
また, 意外といろいろな機能があったので, 紹介したいと思います.
基本的な使い方 &amp;lt;string name=&amp;quot;app_name&amp;quot;&amp;gt;Application&amp;lt;/string&amp;gt;  のように記述して使います. アプリケーション側では, 下のように取得します.
getString(R.string.app_name); or context.getString(R.string.app_name);  特に, 説明はいらないと思います.
arrayの定義 strings.xmlでは単純なkey-valueだけでなく, arrayも定義することができます.
string-array要素で定義してあげます.
&amp;lt;string-array name=&amp;quot;sports&amp;quot;&amp;gt; &amp;lt;item&amp;gt;マラソン&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;野球&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;サッカー&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;卓球&amp;lt;/item&amp;gt; &amp;lt;/string-array&amp;gt;  アプリケーション側では下のように取得します.
getResources().getStringArray(R.array.sports) or context.getResources().getStringArray(R.array.sports)  Contextから直接取得することが出来ないので, 一旦Resourcesを取得し, そこからarrayを取り出します.
値展開 strings.xmlでは, 文字列展開することが出来ます. printf formatのように使います.
&amp;lt;!-- %1: 引数1, $d: 数字 --&amp;gt; &amp;lt;string name=&amp;quot;hoge&amp;quot;&amp;gt;Hello %1$d&amp;lt;/string&amp;gt; &amp;lt;!-- %1: 引数1, %2: 引数2, $s: 文字列 --&amp;gt; &amp;lt;string name=&amp;quot;hogestr&amp;quot;&amp;gt;%1$s %2$d %1$s&amp;lt;/string&amp;gt;  アプリケーション側では, 下のように指定します.</description>
    </item>
    
    <item>
      <title>Android: Pull to Refreshの実装(SwipeRefreshLayout)</title>
      <link>https://satoshun.github.io/2015/02/android-pull_to_refresh/</link>
      <pubDate>Sun, 22 Feb 2015 04:09:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/android-pull_to_refresh/</guid>
      <description>AndroidでPull to Refreshの実装方法です. ListViewなどを下方向に引っ張ると, データを更新するように出来ます. Gmailとかで使われているあれです.
具体的には, SwipeRefreshLayoutを使って実装します. 以下でコードで説明していきます.
XML側の記述 ListViewに覆いかぶさるように定義します.
&amp;lt;android.support.v4.widget.SwipeRefreshLayout android:id=&amp;quot;@+id/refresh&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; &amp;gt; &amp;lt;ListView android:id=&amp;quot;@android:id/list&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt; &amp;lt;/android.support.v4.widget.SwipeRefreshLayout&amp;gt;  XML側はこれで完了です. これで, ListViewを引っ張ると「Pull to Refresh」のアニメーションが起こります.
Activity側の記述 Pull to Refreshをした時に, イベントが発生するのでListenerを記述します.
実装例です. setOnRefreshListenerでListenerを登録します.
private SwipeRefreshLayout mSwipe; @Override protected void onCreate(Bundle savedInstanceState) { ... mSwipe = (SwipeRefreshLayout) findViewById(R.id.refresh); // Callback登録 mSwipe.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { /* ここに適当な処理を書く */ mSwipe.setRefreshing(false); } }); }  ListViewを引っ張ると, setOnRefreshListenerメソッドがコールされます. setOnRefreshListenerの最後に, setRefreshing(false)をコールします.</description>
    </item>
    
    <item>
      <title>tips: 気軽にローカルにサーバを立てる</title>
      <link>https://satoshun.github.io/2015/02/tips-ser/</link>
      <pubDate>Sun, 22 Feb 2015 02:40:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/tips-ser/</guid>
      <description>サクッとローカルサーバを立てるためのTipsを紹介します.
下記コマンドは, Pythonが入っていれば, 問題なく動きます.
$ python -m CGIHTTPServer Serving HTTP on 0.0.0.0 port 8000 ...  僕は, 上記コマンドをaliasに登録しています.
alias ser=&#39;python -m CGIHTTPServer&#39;  これで, serでサーバが立つようになりました.
ちなみに, Portを指定することも出来ます.
$ ser Serving HTTP on 0.0.0.0 port 8000 ... $ ser 8001 Serving HTTP on 0.0.0.0 port 8001 ...  簡単にローカルサーバを立てることが出来るようになりました.</description>
    </item>
    
    <item>
      <title>CSS: Clearfixについて</title>
      <link>https://satoshun.github.io/2015/02/css-clearfix/</link>
      <pubDate>Sun, 22 Feb 2015 02:32:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/css-clearfix/</guid>
      <description>CSSには「clearfix」と呼ばれるテクニックがあります.
この記事では, なぜclearfixを使うのか, clearfixとは何なのかについて説明します.
floatの問題点 clearfixを説明する前に, floatプロパティの問題点について説明します.
まず例をあげます.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;  上記HTMLは, imgが右に寄り, その左側にtest1, test2と表示されます. floatは, 指定したエレメント以降のエレメントを反対側に回りこませることが出来ます.
回りこみを止めたいときは, clear: both;プロパティを指定します.
&amp;lt;div&amp;gt; &amp;lt;img class=&amp;quot;test&amp;quot; src=&amp;quot;hoge.png&amp;quot; style=&amp;quot;float: right&amp;quot; /&amp;gt; &amp;lt;p&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- clear:bothがないと, このdivも左側に回りこむ --&amp;gt; &amp;lt;div style=&amp;quot;clear:both;&amp;quot;&amp;gt; hogehoge &amp;lt;/div&amp;gt;  clear:both;の記述を忘れると, 後続の意図しないエレメントにも影響を及ぼしてしまうので, 忘れずに指定しなければいけません.
とは言っても, floatingの解除は忘れてしまいがちです. そこでclearfixと呼ばれるテクニックを使います.
clearfixとは clearfixとは, after擬似要素を使いfloatを解除するテクニックです.
具体的には以下のように記述します.
.clearfix:after { content: &amp;quot;&amp;quot;; clear: both; display: block; }  clear: both;をしてくれる要素をafter擬似要素で挿入しているだけです. これを, 親エレメントにつけておけば, floatを解除してくれます.</description>
    </item>
    
    <item>
      <title>デザインパターン: Null Object</title>
      <link>https://satoshun.github.io/2015/02/despatt-null_object/</link>
      <pubDate>Sun, 22 Feb 2015 02:22:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/despatt-null_object/</guid>
      <description>Null Objectパターンは, オブジェクト自身にNullかどうかの判定をしてもらうデザインパターンです.
このパターンのメリットは, if (obj == null)のような面倒臭い記述を除去出来るところです. また, ポリモーフィズムにより, nullの時の処理をObjectに委譲することが出来ます. (nullの時の処理を, Objectに持たせることが出来るパターン)
例 例があった方が分かり易いので, 簡単なサンプルプログラムです.
まずは, Null Objectを使わない場合になります.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.format(self.id)) student = Student.get_student(1) if student is not None: student.show() else: print(&#39;not student&#39;)  次にNull objectパターンを使い, if student is not None: を除去します.
class Student(object): def __init__(self, id): self.id = id @staticmethod def get_student(id): if id &amp;lt;= 10: return Student(id) return NullStudent(id) def show(self): print(&#39;id:{}&#39;.</description>
    </item>
    
    <item>
      <title>AnsibleでGhostアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-deploy_ghost/</guid>
      <description>VPSにGhostを, Ansibleでデプロイしている話.
サーバー側で使っているソフトウェアは, supervisor, nodeです.
GitHubでソース管理 CSS, HTMLを少し弄りたいので, Ghostをforkし, それを編集してデプロイしています.(https://github.com/satoshun/ghost)
このリポジトリを, デプロイしていきます.
デプロイ時の手順 サーバで以下のタスクを行います.
 Gitリポジトリを最新の状態にする(git pull origin master) npm moduleの更新(npm install) gruntの実行(grunt init &amp;amp;&amp;amp; grunt prod) ghostプロセスの再起動(supervisorctl restart ghost)  Playbookは以下になります.
--- - hosts: all user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_source.yml - include: update_package.yml - include: restart.yml  各タスクについて説明していきます.
Git pullする Gitモジュールがあるので, それを使います.
- name: Update Git repository git: repo=&amp;lt;git url&amp;gt; dest=&amp;lt;path to project&amp;gt;  npm moduleの更新 npmモジュールがあるので, それを使います.</description>
    </item>
    
    <item>
      <title>Golang: nil pointer receiverの話</title>
      <link>https://satoshun.github.io/2015/02/go-nil_receiver/</link>
      <pubDate>Sun, 22 Feb 2015 02:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/go-nil_receiver/</guid>
      <description>nil pointer receiverについてお話しようと思います. 具体例をあげたほうが分かりやすいので, コードを元に説明していきます.
gist: https://gist.github.com/satoshun/3dc1302dbc163c9a9245
にソースコードがあります.
nil pointer receiver nilについて. 下のコードを見てください.
package main import &amp;quot;fmt&amp;quot; type A struct { } func (a *A) b() { fmt.Println(1000) } func main() { var a *A = nil a.b() }  どう考えても, runtime error: nil pointer access 的なものが出るだろうと思っていました.
sato$ go run main.go 1000  ちゃんと実行できました. Goではnilにも型情報があるので, nilの場合でもPointer receiverの場合は実行できるのです! この機能を使えば, Pointer receiverの中でnilの場合に処理を変えることが可能です. 覚えておくと便利だと思います.
ちなみに, Value receiverの場合はエラーが出ます.
package main import &amp;quot;fmt&amp;quot; type A struct { } // b is value receiver func (a A) b() { fmt.</description>
    </item>
    
    <item>
      <title>AnsibleでGoアプリをデプロイ</title>
      <link>https://satoshun.github.io/2015/02/ansible-go_deploy/</link>
      <pubDate>Sun, 22 Feb 2015 01:08:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/ansible-go_deploy/</guid>
      <description>ローカルでバイナリを作成し, デプロイするような, Ansible Playbookを書きました. Supervisorでプロセスの管理を行っています.
下の手順でデプロイを行っています.
 Macでコンパイルして, Linux-amd64用のバイナリ生成(注意1) バイナリをサーバにデプロイ(コピー) アプリのリスタート(supervisorで再起動)  実際のPlaybookは以下のようになります.
deploy.yml
--- - hosts: local connection: local tasks: - include: build.yml - hosts: app user: &amp;quot;{{ user }}&amp;quot; tasks: - include: update_binary.yml - include: restart.yml  各タスクについて, 説明してきます.
Linux-amd64用のバイナリ生成 Goはデフォルトで, クロスコンパイル出来る機能を持っているので, その機能を使います.
やり方はいろいろあると思うのですが, Makefileを作成して, それをAnsibleから叩くようにして実装しました. Makefileを作る必要ないと思います.
Makefile
get: go get -v build-amd64: get GOOS=linux GOARCH=amd64 go build .  build.yml
--- - name: build src command: make build-amd64 chdir={{ local_home }}  local_homeは変数で, Makefileがあるディレクトリを定義しています.</description>
    </item>
    
    <item>
      <title>様々な言語のフィボナッチ関数</title>
      <link>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</link>
      <pubDate>Sun, 22 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/02/algorithm-multi_fibonacci/</guid>
      <description>Java, JavaScript, Go, Python, Bashでfibonacciを書いてみました.
極力, その言語特有の機能を使って実装するようにしました.
Go type fibonacci intで, int型にfibonacci用の関数を生やしました. せっかくなので, goroutineも使ってみました.
package main import &amp;quot;fmt&amp;quot; type fibonacci int func (self fibonacci) value() chan int { ch := make(chan int, 1) a, b := 0, 1 index := 0 go func() { defer close(ch) for { if int(self) &amp;lt; index { break } a, b = b, a+b index++ ch &amp;lt;- a } }() return ch } func main() { var i fibonacci i = 10 for v := range i.</description>
    </item>
    
  </channel>
</rss>