<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on stsnブログ</title>
    <link>https://satoshun.github.io/tags/kotlin/</link>
    <description>Recent content in Kotlin on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Sun, 24 Mar 2019 02:36:27 +0000</lastBuildDate>
    
	<atom:link href="https://satoshun.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OkHttp: Java to KotlinのPRを見て勉強する</title>
      <link>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</link>
      <pubDate>Sun, 24 Mar 2019 02:36:27 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/okhttp-convert-to-kotlin/</guid>
      <description>OkHttpがKotlin化をするというISSUEが立てられました。 Upgrade OkHttp 3 to Kotlin and call it OkHttp 4
これの是非についてはさておき。現状、いくつかのJavaコードがKotlinへと置き換わっているので、それらのレビューで気になったこと、知らなかったこと、忘れがちなことを勉強がてらまとめたいと思います。
checkNotNullを使うかどうか could also be code no preference myself
Kotlinの標準ライブラリに、checkNotNullがあります。 これは、値がnullならIllegalStateException例外を投げるものです。
以下のコードは同じ意味を持ちます。
val state = someState ?: throw IllegalStateException(&amp;quot;State must be set beforehand&amp;quot;) val state = checkNotNull(someState) { &amp;quot;State must be set beforehand&amp;quot; }  ただ、no preference myselfと言っている通り、使うかどうかはプロジェクトで分かれそうです。 事前に使うかどうかを、決めておくと揉めなく良さそうだと思いました。
命名はto***が慣用的 idiomatic naming would be toUrl on the Kotlin side
OkHttpでは、HttpUrlをURLに変換するためのメソッドとしてfun url(): URLが定義されています。しかし、fun toUrl(): URLのほうがKotlinっぽいよと指摘がありました。
確かに、言われてみるとAtoBクラス変換のメソッド名は、to***が多い気がします。ただし、今回は下位互換を保つために、一旦この修正は入りませんでした。
constを使う discussion link</description>
    </item>
    
    <item>
      <title>Kotlin: コンストラクタ呼び出しっぽく関数やcompanion objectを使う</title>
      <link>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</link>
      <pubDate>Tue, 19 Mar 2019 12:31:05 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/kotlin-invoke-operator/</guid>
      <description> KotlinではJavaと異なり、コンストラクタ呼び出しの時にnewキーワードが必要ありません。
class A ... val a = A()  よって、次のように関数をコンストラクタのように使うことが出来ます。
// Coroutine Jobの定義 @Suppress(&amp;quot;FunctionName&amp;quot;) public fun Job(parent: Job? = null): Job = JobImpl(parent) ... val job = Job()  また、次のようにcompanion object + operator invokeを使うことも出来ます。
// ref: https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter class CoroutineCallAdapterFactory private constructor() : CallAdapter.Factory() { companion object { @JvmStatic @JvmName(&amp;quot;create&amp;quot;) operator fun invoke() = CoroutineCallAdapterFactory() } } ... val factory = CoroutineCallAdapterFactory()  まとめ  JobImplのような実装クラスを隠したいときに便利  </description>
    </item>
    
    <item>
      <title>Kotlin: CoroutineでRxJavaのzipっぽいものを表現する</title>
      <link>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</link>
      <pubDate>Sun, 17 Mar 2019 05:17:23 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/coroutine-catalog-zip/</guid>
      <description>Coroutineで非同期処理を並列に処理したいとします。例外を考慮しないなら単純にasyncで包めば良いです。
launch { val task1 = async { MainService.task1() } val task2 = async { MainService.task2() } println(&amp;quot;${task1.await()}\n${task2.await()}&amp;quot;) }  asyncで包むことで、並列に処理をすることができます。
次に、各非同期処理が例外を吐く場合を考えてみます。その場合は、呼び出し元でrunCatchingを使います。
launch { val task1 = async { runCatching { MainService.task1() } } val task2 = async { runCatching { MainService.task2() } } val result1 = task1.await() val result2 = task2.await() println(&amp;quot;$result1\n&amp;quot; + &amp;quot;$result2\n&amp;quot;) }  runCatchingを使うことで、呼び出し先で例外が起こったとしても、処理を継続することが出来ます。
また、次のように書くことは出来ません。
launch { val task1 = async { MainService.task1() } val task2 = async { MainService.</description>
    </item>
    
    <item>
      <title>Android: JetpackのCoroutine Supportについて</title>
      <link>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</link>
      <pubDate>Sun, 10 Mar 2019 10:14:21 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/03/jetpack-coroutine-support/</guid>
      <description>Jetpackのいくつかのライブラリでは、Kotlin Coroutineのサポートが入っていますが、 どのライブラリで対応が進んでいるか気になったので、軽くまとめます。使い方については言及しません。
以下、2019年3月10日 2019年3月11日の調査結果になります。 また、これらは、supportライブラリのリポジトリから取ってきたので、現在リリースされているかどうかは不明です。
Lifecycle
// Lifecycleに従うCoroutineScopeの生成 val Lifecycle.coroutineScope: CoroutineScope  LifecycleOwner
// LifecycleOwnerに従うCoroutineScopeの生成 val LifecycleOwner.lifecycleScope: CoroutineScope  ViewModel
// ViewModelに従うCoroutineScopeの生成 val ViewModel.viewModelScope: CoroutineScope  WorkManager
abstract class CoroutineWorker( appContext: Context, params: WorkerParameters ) : ListenableWorker(appContext, params) { // suspendメソッドで定義された abstract suspend fun doWork(): Result }  Room
// Dao内でsuspendメソッドが使える @Dao interface HogesDao { @Insert suspend fun add(hoge: Hoge) @Query(&amp;quot;SELECT * FROM hoge WHERE id = :id&amp;quot;) suspend fun get(id: String): Hoge .</description>
    </item>
    
    <item>
      <title>R8/Proguard: Kotlinのlambda最適化について</title>
      <link>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</link>
      <pubDate>Sun, 20 Jan 2019 06:56:16 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-kotlin-lambda/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのlambda式の最適化について紹介します。
Kotlin lambda Kotlinでは関数型がファーストクラスです。とても便利なのですが、ラムダを使うたびに内部的にはクラスを1つ定義するため、クラス数、メソッド数がどんどん増えていきます。
例えば、次のコードを最適化なしでコンパイルしてみます。
fun main() { lambdaTest1 { println(&amp;quot;Kotlin lambda1&amp;quot;) } lambdaTest1 { println(&amp;quot;Kotlin lambda2&amp;quot;) } lambdaTest1 { println(&amp;quot;Kotlin lambda3&amp;quot;) } ... } private fun lambdaTest1(body: () -&amp;gt; Unit) { ... body() ... }  // コンパイル後 public static final void main() { LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$1.INSTANCE); LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$2.INSTANCE); LambdaTestKt.lambdaTest1((Function0) LambdaTestKt$main$3.INSTANCE); ... } final class LambdaTestKt$main$1 extends Lambda implements Function0&amp;lt;Unit&amp;gt; { public static final LambdaTestKt$main$1 INSTANCE = new LambdaTestKt$main$1(); LambdaTestKt$main$1() { super(0); } public final void invoke() { System.</description>
    </item>
    
    <item>
      <title>R8/Proguard: KotlinのCompanion objectとobjectについて</title>
      <link>https://satoshun.github.io/2019/01/r8-companion-object/</link>
      <pubDate>Sun, 20 Jan 2019 04:23:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/r8-companion-object/</guid>
      <description>コードの最適化の話です。この記事ではKotlinのCompanion objectとobjectについて紹介します。
この記事は、R8 Optimization: Staticizationにとても影響を受けています。
Companion object 例えば、次のコードがあるとします。
class CompanionTest { companion object { fun show(i: Int) { ... } } }  これを最適化なしで変換すると次のようになります。
public final class CompanionTest { public static final Companion Companion = new Companion(); public static final class Companion { private Companion() { } public final void show(int i) { ... } } }  Companionインスタンスが生成されているのが分かります。ただ、このCompanion objectはインスタンス生成する必要がありません。なぜなら、インターフェースの実装などをしていないからです。
そこでR8による最適化を行うと次のようになります。
public abstract class CompanionTest { public static final void show(int i) { .</description>
    </item>
    
    <item>
      <title>Coroutine &#43; AutoDisposeを作ってみた</title>
      <link>https://satoshun.github.io/2018/12/coroutine_autodispose/</link>
      <pubDate>Sun, 23 Dec 2018 09:14:43 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_autodispose/</guid>
      <description>Coroutine + AutoDisposeの実装について考えてみました。結論から言うと、ContinuationInterceptorを使えば上手くいきそうです。
ContinuationInterceptorとは? ContinuationInterceptorは次のようなインターフェースです。
/** * Marks coroutine context element that intercepts coroutine continuations. * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and * intercepts all coroutine continuations with [interceptContinuation] invocations. */ @SinceKotlin(&amp;quot;1.3&amp;quot;) public interface ContinuationInterceptor : CoroutineContext.Element { public fun &amp;lt;T&amp;gt; interceptContinuation(continuation: Continuation&amp;lt;T&amp;gt;): Continuation&amp;lt;T&amp;gt; public fun releaseInterceptedContinuation(continuation: Continuation&amp;lt;*&amp;gt;) ... }  interceptContinuationからContinuationを受け取ることができ、Continuationは自身のCoroutineContextを持っているので、そこからJobを取得することが出来ます。それを利用することでAndroid Lifecycleと協調して動くContinuationInterceptorを実装することが出来ます。
class LifecycleContinuationInterceptor( private val lifecycle: Lifecycle ) : ContinuationInterceptor { override val key: CoroutineContext.</description>
    </item>
    
    <item>
      <title>Kotlin: Resultの簡単なまとめ</title>
      <link>https://satoshun.github.io/2018/12/result/</link>
      <pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/result/</guid>
      <description>Result KEEP
Resultが1.3からstdlibに入ったので紹介をしたいと思います。
ResultはSuccess T | Failure Throwableの2状態のいずれかを表現出来ます。成功状態のときはSuccessを、失敗状態のときはFailureを内包します。
基本的な使い方 使い方を見ていきます。まず、Resultインスタンスの生成は、success、failureメソッドを通して行います。
val i: Result&amp;lt;Int&amp;gt; = Result.success(10) val t: Result&amp;lt;Int&amp;gt; = Result.failure(IOException())  また、runCatching関数を使うことで、failする可能性があるメソッドをResult型に丸めることも出来ます。runCathinngのほうがよく使うと思います。
val a = runCatching { doSomeThing() }  Resultに対する操作は以下のようにします。
// successに対して操作 val i = Result.success(10) i.getOrNull() // 10 i.isSuccess // true i.exceptionOrNull() // null i.map { 10 * 10 }.getOrNull() // 100 i.onSuccess { println(&amp;quot;success&amp;quot;) }.onFailure { println(&amp;quot;failure&amp;quot;) } i.recover { 1111 }.getOrNull() // 10 // failureに対して操作 val t = Result.</description>
    </item>
    
    <item>
      <title>Kotlin Coroutineを導入したらどれだけビルドタイムが増えそうか検証した</title>
      <link>https://satoshun.github.io/2018/12/coroutine_build_perf/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/coroutine_build_perf/</guid>
      <description>注意: 計測方法は実環境に全く即していないので意味がない可能性が高いです。
環境  AGP3.4.0-alpha06 Kotlin 1.3.10 Kotlinx.coroutine 1.0.1 Gradle 5.0  比較対象  kotlinx.coroutineを使ったサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中でcoroutine builderやsuspend関数をコールしている 300 * 7の2100箇所がCoroutine関連のコードになります  kotlinx.coroutineを使わないサンプル  クラス数 300 各クラスは7つのメソッドを持ち、その中で適当なメソッド（Handler().post {}）をコールしている  サンプルコード  計測コマンド Build Scanを使って計測します。その際。build-cacheはoffにします。
./gradlew clean ./gradlew build --no-build-cache --scan  両サンプルのクラス数、メソッド数を合わせただけなので、全く正当な比較でないことを留意ください。 また試行回数は10回程度で、最終結果のみを以下に掲載します。
kotlinx.coroutineを使う Time spent executing tasks 1m 16.034s All tasks	207	2m 42.833s Tasks avoided	12 (09.7%)	0.062s From cache	0 (00.0%)	0.000s Up-to-date	12 (09.</description>
    </item>
    
    <item>
      <title>Kotlin: Contracts &#43; 拡張関数でより便利に</title>
      <link>https://satoshun.github.io/2018/11/more_convenient_contracts/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/more_convenient_contracts/</guid>
      <description>Kotlin 1.3.0からContractsが実装されました。 Contractsを使うことで、関数がどのような振る舞いをするか、どういう効果をもたらすかを定義（契約）することが出来ます。
例えば、isNullOrEmptyメソッドがfalse返すなら、 Contractsによりnullでないことが保証されます。
val a: String? = ... if (!a.isNullOrEmpty()) { println(a.length) // !!が必要ない }  Contractsがない時代だと呼び出し元でisNullOrEmptyがどんな振る舞いをするかを知るすべがなかったので、 !!をつける必要があったのですが、Contractsによりnullでないことが保証できるので、!!を省略できます。
isNullOrEmptyの実装は次のようになります。
@kotlin.internal.InlineOnly public inline fun CharSequence?.isNullOrEmpty(): Boolean { contract { returns(false) implies (this@isNullOrEmpty != null) } return this == null || this.length == 0 }  contractはDSL（関数）として定義されています。 これを呼び出し、そのブロックの中でこの関数が満たす振る舞いを定義する事ができます。
isNullOrEmptyの場合はreturns(false) implies (this@isNullOrEmpty != null)が契約として定義されています。
これは、「returns(false): falseを返すなら (this@isNullOrEmpty != null): 自分自身がnullじゃない」という意味になります。 なので呼び出し元ではfalseが返ってきたら、nullではないことが保証されるので、smartcastにより!!をつける必要がなくなるわけです。
なので、例えばT.isEmpty(t: T?): Booleanのようなメソッドがあり、ついでにnullチェックもこの関数の中でやっているようなときは、 contractを定義することでより使いやすい関数にすることが出来ます。
他の例を見てみます。スコープ関数applyの実装は次になります。
@kotlin.internal.InlineOnly public inline fun &amp;lt;T&amp;gt; T.</description>
    </item>
    
    <item>
      <title>KotlinのNon-Null型にnullを代入する方法</title>
      <link>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/kotlin-nullable-generic/</guid>
      <description>Kotlinではnullを扱いやすくするためにNullable、Non-Nullを型で制限することが出来ます。 KotlinのNon-Null型に対してnullを代入しようとすると、代入するタイミングで例外を吐きます。 JavaとKotlinを一緒に使っていると、この例外に遭遇することがあると思います。
具体的には以下の挙動をします。
public class Hoge { // nullを返すメソッド static String getName() { return null; } }  val d: String = Hoge.getName() // ここで例外が投げられる println(d.length) // これは実行されない  このコードは、val d: String = Hoge.getName()でIllegalStateExceptionを投げます。 Non-Null型にnullを代入しようとしているからです。
次に、代入するタイミングで例外を投げなくする方法を紹介します。
具体的には以下のコードで達成できます。
fun &amp;lt;T&amp;gt; castNull(): T = null as T val d: String = castNull() // ここでは例外が投げられない println(d.length) // ここで例外が投げられる  なぜこのような挙動になるのかを説明します。まず castNull()メソッドに定義されたジェネリック型TはAny?をupperに持ちます。 Kotlinはジェネリックを使い、かつNullable型をupperに持つとき、nullかどうかのチェックをしません。これはバイトコードを見れば分かります。
GETSTATIC sample/SampleTestsJVMKt.a : Ljava/lang/String; CHECKCAST java/lang/Object  CHECKCASTしかしておらず、nullかどうかのチェックをしていません。 なので、val d: String = castNull()ではnullチェックがされないため例外が投げられず、実際にメソッドをコールするprintln(d.</description>
    </item>
    
    <item>
      <title>拡張関数 &#43; ジェネリック型でよりタイプセーフを得る</title>
      <link>https://satoshun.github.io/2018/11/extension-typesafe/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/extension-typesafe/</guid>
      <description>Kotlinの拡張関数の話です。
以下のクラスがあったとします。
class A&amp;lt;T&amp;gt;(val value: T) { fun isNull(): Boolean { return value != null } } fun main() { val a1: A&amp;lt;Int&amp;gt; = ... a1.isNull() }  このとき、a1.isNull()の結果は自明です。なぜならA&amp;lt;Int&amp;gt;で宣言している時点でnonNullが確定しているためです。
fun main() { val a2: A&amp;lt;Int?&amp;gt; = ... a2.isNull() }  このとき、a2.isNull()の結果は自明ではありません。 なぜならA&amp;lt;Int?&amp;gt;でジェネリック型を宣言しているので、nullableな値が入ってくる可能性があるためです。
この2つの例から、a1.isNull()はそもそもnonNullなのでisNull()メソッドをコールできないほうが良いのではないか？という考えが浮かびます。
Kotlinの拡張関数を使うことで達成できます。
class A&amp;lt;T&amp;gt;(val value: T) // nullableのときにコールできるようにする fun &amp;lt;T : Any&amp;gt; A&amp;lt;T?&amp;gt;.isNull(): Boolean { return value != null } fun main() { val a1: A&amp;lt;Int&amp;gt; = .</description>
    </item>
    
    <item>
      <title>Kotlinで3つの関数のパラメータを省略する</title>
      <link>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/10/kotlin-decrease-function_params/</guid>
      <description>Kotlinでは拡張関数が定義されており、拡張関数を使うことで1つ関数のパラメータを省略できます。
fun hoge(a: String) { println(a) } -&amp;gt; fun String.hoge() { println(this) }  次に、インターフェース（クラス）内で拡張関数を定義することで、さらに1つの関数のパラメータを省略できます。
interface User fun hoge(a: String, b: User) { println(a) println(b) } -&amp;gt; interface User { fun String.hoge() { println(this) println(this@User) } }  さらに、reified type parameterを使うことで、関数のパラメータを省略できます。
fun &amp;lt;T&amp;gt; hoge(a: String, b: User, c: Class&amp;lt;T&amp;gt;) { println(a) println(b) println(c) } -&amp;gt; class User { inline fun &amp;lt;reified T&amp;gt; String.hoge() { println(this) println(this@User) println(T::class) } }  interfaceだと、inline関数が使えないのでクラスで定義してあります。</description>
    </item>
    
    <item>
      <title>Inline classesとGsonでprimitive型をクラスで受けとる</title>
      <link>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-gson-inlineclasses/</guid>
      <description>（この記事は1.3-M2を使っています。）
Kotlin 1.3でInline classesが入ります。これはパフォーマンスに影響を与えずに、値のラッパークラスを作成することが出来ます。
例えば、次のように書くことが出来ます。
inline class UserId(val id: String) { val url get() = &amp;quot;http://$id&amp;quot; } val userId = UserId(&amp;quot;user-dayo&amp;quot;) println(userId.url)  このコードは一見、UserIdインスタンスが生成されそうです。 しかし、コンパイルされたコードではUserIdインスタンスは生成されません。
public static final class UserId$Erased { ... @NotNull public static final String getUrl(String $this) { return &amp;quot;http://&amp;quot; + $this; } ... } String userId = &amp;quot;user-dayo&amp;quot;; String var1 = UserId$Erased.getUrl(userId); System.out.println(var1);  UserIdのインスタンスを作らずに、Stringをそのまま使っていることが分かります。そして自動生成されたUserId$Erasedクラスにあるstaticメソッドを実行しています。Inline classesでは、インスタンスを生成せずにstaticメソッドをコールすることで、インスタンス生成のコストを抑えています。
ここからが本題です。 Inline classesがAndroid開発のどこで役立つのかを考えたときに、 Gsonなどのライブラリによってdeserialize/serializeされるクラスで有効使えると思いました。
例えば、次のコードがあったとします。
data class Response( @SerializedName(&amp;quot;user_id&amp;quot;) val userId: String, @SerializedName(&amp;quot;friend_id&amp;quot;) val friendId: String )  これはuserIdとfriendIdをStringで受け取っており、このStringが何のStringかの情報が欠落しています。型による分類が出来てない状態です。</description>
    </item>
    
    <item>
      <title>Kotlin: Inline Functionだけではメソッドカウントは減らない</title>
      <link>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</link>
      <pubDate>Thu, 02 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/inline_function_decrease_method_count/</guid>
      <description>結論  R8/Proguardをちゃんと使う  背景 Inline Functionを使うと、関数がインライン化されるので、自動的にメソッド数が1減ると思っていました。けど、そんなことはなかったという話です。
実際に動かして確認してみます。下記の関数を追加し、Build APK → Analyze APKでclasses.dexのメソッドカウントを調べてみます。
まずは、R8無しで調べてみます。
fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  当然メソッドカウントが1増えています。
次に、inlineを付けてみます。
inline fun hoge() { println(&amp;quot;hogehoge&amp;quot;) }  こちらもメソッドカウントが1増えました。 show Kotlin Bytecode → Decompileを使い、decompileされたJavaファイルを見ると、inline hogeメソッドに対応したメソッドが生成されていることが分かりました。
@Metadata( mv = {1, 1, 10}, bv = {1, 0, 2}, k = 2, d1 = {&amp;quot;\u0000\b\n\u0000\n\u0002\u0010\u0002\n\u0000\u001a\t\u0010\u0000\u001a\u00020\u0001H\u0086\b¨\u0006\u0002&amp;quot;}, d2 = {&amp;quot;hoge&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;production sources for module app&amp;quot;} ) public final class MainActivityKt { public static final void hoge() { String var1 = &amp;quot;hogehoge&amp;quot;; System.</description>
    </item>
    
    <item>
      <title>Kotlin: typealiasを使ってめんどうなアノテーションを省略する</title>
      <link>https://satoshun.github.io/2018/07/typealias_omit_annotation/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/07/typealias_omit_annotation/</guid>
      <description>Kotlinではtypealiasと呼ばれる、既存のタイプに対して別名をつける機能があります。 https://kotlinlang.org/docs/reference/type-aliases.html
典型的な使い方として、下のような複雑な型に名前をつけると可読性が高くなります。
typealias MyHandler = (Int, String, Any) -&amp;gt; Unit  さらにtypealiasは、アノテーションをつけることも出来ます。
typealias NonWildcardList&amp;lt;T&amp;gt; = List&amp;lt;@JvmSuppressWildcards T&amp;gt;  JvmSuppressWildcardsはDagger(参考リンク)やretrofit(参考リンク)を使っていると、使わざるをえないケースがあるので、typealiasで定義していおけば可読性高く、楽することが出来ます。</description>
    </item>
    
    <item>
      <title>CoroutineBindingライブラリを作りました</title>
      <link>https://satoshun.github.io/2018/05/coroutinebinding-intro/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/05/coroutinebinding-intro/</guid>
      <description> CoroutineBindingライブラリを作ったのでその紹介です。 https://github.com/satoshun/CoroutineBinding
Android開発でCoroutineの流れが来ていると思っていて、RxBindingのような感じで、 CoroutineフレンドリーにViewのイベントを受け取れたら便利そうだなと思い作りました。
使い方 例えばclickのイベントを受け取りたいとします。 CoroutineBindingでは以下のように書くことが出来ます。
val root = findViewById&amp;lt;ViewGroup&amp;gt;(R.id.root) launch(UI) { for (click in root.clicks()) { Log.d(&amp;quot;clicked&amp;quot;, click.toString()) } }  RxBindingのように使うことが出来ます! 他のAPIに関してもRxBindingに準拠しているため、RxBindingを使ったことがある人は自然に使えるようになっています。
まとめ  Coroutineを使っている人なら便利に使えると思うので、ぜひ使って下さい! https://github.com/satoshun/CoroutineBinding 何かあればissueや、PRを貰えると嬉しいです  </description>
    </item>
    
    <item>
      <title>Kotlin: ローカルで明示的に型を宣言することについて</title>
      <link>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</link>
      <pubDate>Mon, 16 Apr 2018 22:50:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/04/about_writing_type_in_kotlin/</guid>
      <description> ポエムです。
結論 基本的にローカルで明示的に型を宣言するのは好ましくない
問題 Kotlinではval(var)で変数定義することができ、型宣言を省略することが出来ます。
val userName = dataSource.getUserName()  型宣言するのと、省略するのどちらが良いのか考えると、多くの場合、型宣言をしないほうが優れていると思います。なぜかというと、型宣言が必要ということは、型宣言をしないと人間が理解できないほど複雑なコードを書いていることを意味するからです。適切なメソッド、適切なクラスが欠けている可能性があります。
Kotlinにおいて型宣言を書くことはコメントを書くことに等しいと思います。多くの場合は冗長です。
まとめ  ローカルで型宣言が欲しくなるコードがあったら、それは複雑すぎるコードの匂いがする  </description>
    </item>
    
    <item>
      <title>Kotlin: 拡張関数からprotectedメソッドにアクセスする</title>
      <link>https://satoshun.github.io/2018/01/extension-function-with-protected/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/01/extension-function-with-protected/</guid>
      <description> LiveDataのonActiveメソッドで説明します。onActiveメソッドは以下で定義されています。
package android.arch.lifecycle; public abstract class LiveData&amp;lt;T&amp;gt; { protected void onActive() { } }  onActiveはprotectedで定義されています。同一パッケージ内で拡張関数を定義することで、onActiveメソッドに拡張関数内からアクセスする事ができます。
package android.arch.lifecycle fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // LiveDataクラスと同一のパッケージで定義することで、protectedメソッドにアクセスできる }  同一のパッケージで定義していない場合はprotectedメソッドにアクセスすることは出来ず、コンパイルエラーになります。
package android.arch fun &amp;lt;T&amp;gt; LiveData&amp;lt;T&amp;gt;.accessOnActive() { onActive() // コンパイルエラー &amp;quot;Cannot access &#39;onActive&#39;: it is protected in &#39;LiveData&#39;&amp;quot; }  なぜかこのような挙動になるか? protectedメソッドは同一パッケージ内であればアクセスできるので、拡張関数を同一パッケージ内で定義することでprotectedメソッドにアクセスできるようになります。Javaでも同様のルールです。
まとめ protectedなメソッドに拡張関数内からアクセスするのは行儀的には良くないと思うので、奥の手段として使うのが良さそう
参考  https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a  </description>
    </item>
    
  </channel>
</rss>