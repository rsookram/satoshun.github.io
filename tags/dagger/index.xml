<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dagger on stsnブログ</title>
    <link>https://satoshun.github.io/tags/dagger/</link>
    <description>Recent content in Dagger on stsnブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Sato Shun</copyright>
    <lastBuildDate>Wed, 16 Jan 2019 12:10:36 +0000</lastBuildDate>
    
	<atom:link href="https://satoshun.github.io/tags/dagger/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dynamic Feature ModuleでDagger Androidを使う</title>
      <link>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</link>
      <pubDate>Wed, 16 Jan 2019 12:10:36 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2019/01/dynamic-feature-and-dagger-android/</guid>
      <description>Dependency injection in a multi module projectを見て、Dynamic FeatureをDagger Androidで実現するにはどうするかを考えてみました。
結論からいうと、いくつかのbaseクラスを定義することで対応できそうです。
また、この記事ではDynamic Feature Module、Dagger Androidをある程度知っている前提で進めていきます。
検証に用いたコードはsatoshun-android-example/DynamicFeatureDaggerExampleにあります😊
前提知識 通常のDagger AndroidはApplicationクラスでComponentを保持して、そこからSubcomponentを派生させる形になります。 ここでのポイントは、Applficationでトップに位置するComponentを保持/作成するという点です。これはappモジュールが全てのFeatureモジュールを知っていることを意味します。
この前提をもとに、Dynamic Featureを考えます。Dynamic FeatureではApplicationでトップに位置するComponentを保持/作成することが出来ません。なぜなら、appモジュールは各Featureモジュールのことを知れないためです。Dynamic Moduleでは通常のモジュール構成と違い、appとFeature Module間の依存関係が逆転します。結果、Applicationでトップに位置するComponentを保持/作成することが出来ません。
そこでDynamic Featureでは、appモジュールでトップに位置するComponentを保持するのはやめて、各Feature Module内でそれぞれのComponentを保持するのが良いことが分かります。
ここまでが前提知識で、次にDynamic Feature + Dagger Androidの実装について説明します。
実装 Feature Subモジュールがあり、このSubモジュールのエントリポイント（トップに位置するクラス）としてSubActivityが定義されているとします。 実装の方針としては、このSubActivityをDaggerApplicationのように振る舞わさせることを目指します。なぜなら、このFeatureモジュールのトップに位置するクラスがSubActivityなので、これをDaggerApplicationのように扱うことができれば、Dagger Androidの世界に上手く落とし込むことが出来ると考えたからです。
では、実装を始めます。
最初に、SubActivityをDaggerApplicationのように振る舞わさせるためにModuleRootActivityクラスを定義します。 それに合わせて、いくつかの付随したクラスも定義しておきます。これがbaseクラス群になります。
abstract class ModuleRootActivity : AppCompatActivity(), HasModuleInjector { @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&amp;lt;Fragment&amp;gt; private lateinit var injector: ModuleActivityInjector override fun onCreate(savedInstanceState: Bundle?) { injector = moduleComponent.moduleInjector injector.activity.inject(this) super.onCreate(savedInstanceState) } protected abstract val moduleComponent: ModuleActivityComponent override fun supportFragmentInjector(): AndroidInjector&amp;lt;Fragment&amp;gt; = fragmentInjector } class ModuleActivityInjector @Inject constructor( internal val activity: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; ) interface ModuleActivityComponent { val moduleInjector: ModuleActivityInjector } interface HasModuleInjector : HasSupportFragmentInjector abstract class ModuleChildFragment : Fragment() { override fun onAttach(context: Context) { AndroidSupportInjection.</description>
    </item>
    
    <item>
      <title>Dagger &#43; ViewModelの基本編 &#43; 実例編</title>
      <link>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</link>
      <pubDate>Wed, 19 Dec 2018 09:59:20 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/dagger_with_viewmodel/</guid>
      <description>この記事はDaggerとJetpackのViewModelをある程度知っている前提で進んでいきます😃
基本編 一緒にDagger + ViewModelを使うのはツラミがあります。それは、ViewModelのインスタンス生成はViewModelProviderを介して行う必要があるためです。
例えば、次のコードは間違っています。
class MainViewModel @Inject constructor(...): ViewModel() class MainActivity { @Inject lateinit var viewModel: MainViewModel ... }  この書き方だとMainViewModelはDagger内で自動的にインスタンス生成されてしまうので、ViewModelProviderを介してくれません。よって次のように書く必要があります。
class MainViewModel(...): ViewModel() @Module class MainActivityModule { @Provides fun provideMainViewModel(...) : MainViewModel { // ViewModelProviderを使ってインスタンスを生成する return ViewModelProviders.of(...).get(MainViewModel::class.java) } } class MainActivity { @Inject lateinit var viewModel: MainViewModel ... }  @Providesを使いインスタンス生成の方法を明示的に記述します。これで、ViewModelProviderを介してMainViewModelインスタンスを生成をすることが出来ます。
また、ViewModelを直接注入せずに、ViewModelProvider.Factoryを注入し、ViewModelのインスタンス生成はActivity（or Fragment）に任せる方法があります。 このパターンのときは、activity-ktx（or fragment-ktx）に追加された拡張関数と組み合わせるといい感じに書けます。
class MainViewModel(...): ViewModel() or class MainViewModel @Inject constructor(...): ViewModel() @Module class MainActivityModule { @Provides fun provideViewModelFactory(.</description>
    </item>
    
    <item>
      <title>Gradle: Dagger2でapiとimplementationどちらを使うか議論されている</title>
      <link>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</link>
      <pubDate>Sat, 08 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/12/gradle-api_vs_implementation/</guid>
      <description>注意 この記事はapiとimplementationの説明をする類の記事ではありません。
GradleでcompileがDeprecatedになり、implementationまたはapiを使うことが推奨されています。 それに合わせて多くのライブラリのREADMEのcompileがimplementationまたはapiに置き換わりました。
Dagger2でもcompileをimplementationに置き換えるPRが出されました。https://github.com/google/dagger/pull/1130
内容が興味深かったのでまとめてみようと思います。
まず最初のPRは次の差分になっていました。compileをimplementationに置き換えています。
// Add Dagger dependencies dependencies { - compile &#39;com.google.dagger:dagger:2.x&#39; + implementation &#39;com.google.dagger:dagger:2.x&#39; annotationProcessor &#39;com.google.dagger:dagger-compiler:2.x&#39; } - compile &#39;com.google.dagger:dagger-android:2.x&#39; - compile &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries + implementation &#39;com.google.dagger:dagger-android:2.x&#39; + implementation &#39;com.google.dagger:dagger-android-support:2.x&#39; // if you use the support libraries  ここでjakeさんが
 I think this one is somewhat debatable, but you&amp;rsquo;re likely to mark it as implementation in every module that contains the compiler so it&amp;rsquo;s probably a non-problem.</description>
    </item>
    
    <item>
      <title>Activity、Fragment、Viewにコンストラクタインジェクションする</title>
      <link>https://satoshun.github.io/2018/11/android_all_inject_ctor/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/11/android_all_inject_ctor/</guid>
      <description>Daggerライブラリを使い、Androidフレームワークが提供するActivityなどのクラスにコンストラクタインジェクションしたい、 そんな夢をみたAndroidエンジニアは数多くいると思います。
この記事ではそんな夢を叶える方法を紹介します。
サンプルコードはここにあります。
FragmentFactory Fragmentに依存関係を注入する時、普通にやると以下のコードになると思います。
class MainFragment : Fragment() { @Inject lateinit var userHandler: UserHandler ... }  これをコンストラクタインジェクションにしたい。
class MainFragment @Inject constructor( private val userHandler: UserHandler ) : Fragment() { ... }  androidx.fragment:fragment:1.1.0-alpha01から、FragmentFactoryが追加されました!! これを使うことでコンストラクタインジェクションが可能になります。
MainFragmentインスタンスを生成するFragmentFactoryを作成します。
class MainFragmentFactory @Inject constructor( private val fragment: Provider&amp;lt;MainFragment&amp;gt; ) : FragmentFactory() { override fun instantiate( classLoader: ClassLoader, className: String, args: Bundle? ): Fragment { if (className == MainFragment::class.java.name) { return fragment.get() } return super.</description>
    </item>
    
    <item>
      <title>Daggerでprivate valで依存関係を取得したかった</title>
      <link>https://satoshun.github.io/2018/09/android-dagger-simple-example/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/09/android-dagger-simple-example/</guid>
      <description>みなさんこんにちは
今回はDaggerの話をします。Dagger + Kotlinの1つ気になる点として@Inject lateinit var になってしまうところがあると思います。
class HogeActivity { @Inject lateinit var hoge: Hoge }  これをなんとか出来ないかなと思って考えてみました。
結論から言うと最終形はこのようになります。
class HogeActivity { private val hoge: Hoge by inject() }  private valになりました。これをどのように実現したかについて説明してきます。ちなみにですが、これはプロダクションに耐えれるようなコードではありません。ご了承ください。
今回はIntoMapを使って実装することにしました。
IntoMapとはその名の通りMapにバインドするためのアノテーションです。 詳しくはドキュメントを見てください。
サンプルコードで説明していきます。
まずはIntoMapを使い、MapへのバインドをModuleに定義していきます。
@Module interface HogeModule { @Binds @IntoMap @ClassKey(Hoge1::class) fun bindHoge1(hoge: Hoge1): Any @Binds @IntoMap @ClassKey(Hoge2::class) fun bindHoge2(hoge: Hoge2): Any } class Hoge1 @Inject constructor() class Hoge2 @Inject constructor() @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) @MapKey annotation class ClassKey(val value: KClass&amp;lt;out Any&amp;gt;)  Mapには当然、valueに対応するkeyが必要になります。DaggerではMapKeyを使うことで、valueとkeyを紐づけることが出来ます。</description>
    </item>
    
    <item>
      <title>Android: Dagger 2.17のfastInitを試してみた</title>
      <link>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/08/android-dagger__fastinit_mode/</guid>
      <description>Dagge 2.17でfastInitオプションが追加されました。 https://google.github.io/dagger/compiler-options
これは、startup timeを改善するための機能です。どれくらい差があるかを担当アプリで実際に調べてみました。
確認に使用した端末はAndroid8系のGalaxyと、Android7系のXperiaの計2台になります。
確認に使用したシェルスクリプト adb shellコマンドから起動時間を調べるコマンドです。計11回startup timeを確認する事ができます。
for i in {0..10} do adb shell am start -S -W jp.hoge/.ui.main.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN &amp;gt;&amp;gt; hoge.txt sleep 10 done  下記を参考にしました。
 https://developer.android.com/topic/performance/vitals/launch-time  fastInit有効の場合 下記をbuild.gradleに追加します。
kapt { javacOptions { option(&amp;quot;-Adagger.fastInit=enabled&amp;quot;) } }  結果:
平均: 1609ms  fastInit無効の場合 結果:
平均: 1607ms  まとめ ほぼ変わらない数字が出てきてしまいました。悲しい。 Dagger生成コードを見る限りだと、最初のComponentのcreateのタイミングでComponentが持っているフィールドの初期化が行われていなかったので、早くなりそうだなと思ったんですが、実際にはほぼ変わりませんでした。
芳しくない結果になった推測として
 担当アプリのDaggerの書き方が正しくないからこの結果になった?  要調査、しかし一般的なAndroid-Daggerを使った書き方をしているので正しいはず  確認に使用したコマンドが良くないのかも?  なにか分かったら追記します、もしくは間違っている点があればご指摘いただければ幸いです😊</description>
    </item>
    
    <item>
      <title>Dagger-AndroidでUserScopeのようなカスタムのScopeを使い、特定のActivity間のみで同一インスタンスを使う方法</title>
      <link>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</link>
      <pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2018/06/dagger-android-with_custom_scope/</guid>
      <description>Daggerを使い、複数のインスタンス間で同一のインスタンスを使う時は、スコープを使うことで実現できます。 Androidでは、すべてのActivityで共通のインスタンスを使うには SingletonスコープとAppComponentを組み合わせて使う方法がよく知られています。 しかし、特定のActivity間でのみ共通のインスタンスを使いたい場合にはこの方法は使えません。SingletonだとすべてのActivity間で共通のインスタンスが使えてしまいます。
この記事では、Dagger-Androidを使ったサンプルコードをベースに、「特定のActivity間のみで同一インスタンスを使う方法」を説明します。 また、基本的なDaggerの使い方は知っている前提で説明していきます。
サンプルコードはこちらになります。 コードを見ると理解がより深まると思うので、ぜひご覧になってください😊
では説明していきます。今回のサンプルコードの目指すところは
 UserScopeを定義し、MainActivity、UserScopedActivityで同一のUserManagerインスタンスを使用する  とします。
まず最初にUserScopeを定義します。
@Scope @MustBeDocumented @Retention(AnnotationRetention.RUNTIME) annotation class UserScope  次にUserSubcomponentを作ります。
@UserScope @Subcomponent interface UserSubcomponent { @Subcomponent.Builder interface Builder { fun build(): UserSubcomponent } val activityInjector: DispatchingAndroidInjector&amp;lt;Activity&amp;gt; }  ここでは、UserSubcomponentにUserScopeスコープを持たせています。 このように書くことで、SubcomponentとScopeを結びつけることが出来ます。
次にAppComponentを作ります。
@Singleton @Component( modules = [ AndroidSupportInjectionModule::class ] ) interface AppComponent : AndroidInjector&amp;lt;App&amp;gt; { @Component.Builder interface Builder { @BindsInstance fun application(application: App): Builder fun build(): AppComponent } override fun inject(app: App) // AppComponentとUserSubcomponentを結びつける val userComponentBuilder: UserSubcomponent.</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. u2020から読み解く編 Part2</title>
      <link>https://satoshun.github.io/2015/05/dagger2_2/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2_2/</guid>
      <description>概要 この記事では, JakeWhartonさんのu2020から, AndroidでDagger2を使うときの実践的な方法を紹介します. u2020はDagger1を使っていますが, Dagger2においても同様に使えるテクニックなので, u2020をベースにして説明します.
DI, Dagger2の基本について知りたい方は, Part1を見て下さい.
目次
 debugとproductionでModuleを切り替える Debug専用のViewを作る Mockモードの定義 -　まとめ  debugとproductionでModuleを切り替える gradleは, productFlavorsを設定することで, ソースコード, ビルド設定を切り替えることが出来ます. u2020では, production, internalのflavorがあります. そして, u2020はflavorの種類によって, DIする対象を切り替えています. production用のComponentとdebug用のComponentを作成することでそれを実現しています. 具体的には,
 /src/production/java/com/jakewharton/u2020/Modules.java /src/internalDebug/java/com/jakewharton/u2020/Modules.java /src/internalRelease/java/com/jakewharton/u2020/Modules.javaに  それぞれModuleを定義し, それをApplicationクラスから読み込むようにしています. これで, flavorごとにinjectするインスタンスを切り替えることが出来ます.
こうすると何が嬉しいんでしょうか? 例えば以下のことが可能になります.
 Debugのみログを有効にしたい APIのエンドポイントを変えたい debug専用のViewを出したい Test用のインスタンスをinjectしたい etc, etc&amp;hellip;  以下では, より細かく説明していきます.
Debug専用のViewを作る u2020では, Debug専用のView DebugAppContainerがあります. Debug専用のView はこんな感じです. Debugビルドの時は, このContainerをinjectしています.
DebugAppContainerは簡単にいえば, DrawerLayoutを1つ実装し, その中に「データをモックに変更する」, 「social機能を有効にする」などを設定出来るViewをおいています.
Mockモードの定義 u2020ではMockモードがあり, Mockデータを表示機能があります.
public final class DebugDataModule { .</description>
    </item>
    
    <item>
      <title>Android: Dagger2でDIをする. 基本編 Part1</title>
      <link>https://satoshun.github.io/2015/05/dagger2/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://satoshun.github.io/2015/05/dagger2/</guid>
      <description>概要 この記事では, 最初にDIとは何かについて説明します. DIを理解した後にDagger2の基本的な使い方を紹介します. Dagger2はDI(Dependency Injection)をするライブラリです.
DIとは? DIとはDependency Injectionの略で, 訳すと「依存性の注入」です. ここでいう依存とは クラス同士の依存関係のことを表します. クラス同士の依存関係は, 委譲パターンの時に現れます.
例えば, 以下のコードがあったとします.
class Blogger { public Blogger() { } public void post(String title) { // 何かメインの処理 // ... // fileにlogを取る FileLogger logger = new FileLogger(title); logger.logging(); } } class FileLogger implements Logger { @Override public void logging(String... messages) { // fileにmessagesを書き出す File file = new File(&amp;quot;hoge.txt&amp;quot;); ... } } interface Logger { void logging(String messgae); }  クラスBloggerはクラスFileLoggerに依存している.</description>
    </item>
    
  </channel>
</rss>