+++
date = "2015-03-14T00:00:00Z"
title = "本: 達人に学ぶDB設計 徹底指南書"
tags = ["book", "web", "api"]
blogimport = true
type = "post"
draft = true
+++

表, 関係の違い

テーブル?

バックアップ
- フルバックアップ
- 差分バックアップ
- 増分バックアップ
- レプリケーション


# 論理設計とパフォーマンス

正規化のメリット

- データ更新が1つのレコードで済むので, データ整合性が保たれる
- データの重複がない

デメリット

- SQL JOINが増えてしまい, パフォーマンスに影響が出ることがある.

基本, 非正規化を選ぶことはない. JOINが増えすぎてパフォーマンスに影響が出た時だけ.


# パフォーマンス

インデックス
- B-tree: 深さが `log n`になる.
- アプリケーション, データ透過的. 意識, 変更する必要がない

インデックス設計
- カーディナリティの高い列に作成. また値に偏りがない.
- WHERE, JOIN条件に使用されている列に作成
- LIKE述語は前方一致のみインデックスが適用される


# バッドノウハウ

ダブルミーニング
- カラムの表している意味がレコードごとに違う => カラムは変数ではない

単一参照モデル
- 1つのテーブルに, 区別カラム的なのを持たせて, いろいろなテーブルを挿入する

ダブルマスタ
- システムの統合で, 同じ用な意味を持つテーブルが複数ある状態

# グレーノウハウ

代理キー
- 主キーになるような一意キーがない => 代理キーを使うしか無い
- 基本, 自然キー以外を主キーに使うのはナンセンス
  - 履歴などを保持したい場合は, タイムスタンプ列を導入して解決, またインターバル(開始, 終了年度)を持たせる

列持ちテーブル
- 子1, 子2, 子3 のように列を保持
- 行持ちテーブルを使ったほうが良い(user_id, index, 子)

集計キー
- 地方コードを列として追加 => テーブルのサイズが大きくなり, パフォーマンスが悪化する恐れあり
- (県コード,地方コード)のrelationを表したテーブルを作成する. しかし結合が必要. viewを使う, case when + group byを使う方法も悪くない

多段ビュー
- Viewは物理的なデータを保持しているわけではない. 多段だとパフォーマンスに影響が出る


# データクレンジング

名寄せ
- 名前, 住所等フリーフォーマットで書かれたデータを, 1つにまとめる
