<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>stsnブログ</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://satoshun.github.io/tags/book/</link>
    <language>ja</language>
    <author>Sato Shun</author>
    <copyright>2015 Sato Shun</copyright>
    <updated>Wed, 18 Mar 2015 00:00:00 UTC</updated>
    
    
    <item>
      <title>読んだ: 達人に学ぶDB設計 徹底指南書</title>
      <link>https://satoshun.github.io/2015/03/master_of_database/</link>
      <pubDate>Wed, 18 Mar 2015 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2015/03/master_of_database/</guid>
      <description>

&lt;p&gt;この記事には僕の主観, 解釈が入っています. 本のまとめというよりかは, 感想的なものです.&lt;/p&gt;

&lt;h2 id=&#34;データベースを制する者はシステムを制す&#34;&gt;データベースを制する者はシステムを制す&lt;/h2&gt;

&lt;p&gt;システムを構築する時に, 要件定義をし, どのようにデータが必要, 保持するかを決定することはとても大切です. 拡張性が高く, 正しいデータ設計をすると, 要件修正があった時にも, 大きな変更をすることはありません. データ中心のアプローチは現在の主流です.&lt;/p&gt;

&lt;p&gt;view(外部スキーマ)とmodel(論理スキーマ)を分離しておくことも大切です.  論理スキーマを正規化などの技術を使い, リレーショナル・データベースの基本に沿った設計をすることで, 外部スキーマで柔軟に組み合わせて使用することが出来ます.&lt;/p&gt;

&lt;h2 id=&#34;論理設計と物理設計&#34;&gt;論理設計と物理設計&lt;/h2&gt;

&lt;p&gt;論理設計は物理設計に先立って行われる必要があり, 論理設計は物理設計とは独立して設計することが出来ます.&lt;/p&gt;

&lt;p&gt;論理設計では, エンティティ抽出が行われます. エンティティは要件定義に基づいて行われます. 例えば, 要件「ユーザがブログを投稿できる」があったとしたら，ユーザとブログがエンティティとして抽出できます. そして, 各エンティティがどのような属性(列)を持っているかを定義して, どのような関係(1対多になっているかなど)になっているかをER図などで示します.&lt;/p&gt;

&lt;p&gt;物理設計では, パフォーマンス, キャパシティの2つの要素が仕様を満たすようにすることが大切です. キャパシティは, データファイル, インデックスファイル, システムファイル, 一時ファイル, ログファイル(トランザクション履歴的なもの)の5つのファイルがあり, それぞれのファイルがどれくらいのサイズになるかを見積もります. パフォーマンスは, TPS(Transaction Per Second)のスループットがどれくらい出れば良いかを設定し, CPU, メインメモリを見積もります.&lt;/p&gt;

&lt;p&gt;冗長設計(RAID, レプリケーション), バックアップ設計(フル, 差分, 増分バックアップ)をし, 不測の事態でもデータがなくならないようにすることも大切です.&lt;/p&gt;

&lt;h2 id=&#34;論理設計と正規化-なぜテーブルは分割する必要があるのか&#34;&gt;論理設計と正規化 ～なぜテーブルは分割する必要があるのか？&lt;/h2&gt;

&lt;p&gt;正規化は, テーブルをどのように定義すればいいかのプラクティスです. 正規化をすることでデータの重複を防ぎ, データサイズを小さくし, データ不整合を防ぐことが出来ます. 正規化はRDSにおける, リファクタリングのような感じです.&lt;/p&gt;

&lt;p&gt;正規化には, 第5まであります. テーブルを分割することで, データの重複を除去していきます. 詳しくは&lt;a href=&#34;http://www.techscore.com/tech/sql/SQL16/16_02.html/&#34;&gt;こちら&lt;/a&gt;が分かりやすいです.&lt;/p&gt;

&lt;p&gt;まとめると, 正規化メリットは
- データの重複を防ぐ
- データサイズを小さく保つことが出来る
- 正規化のノウハウは広く共有されているので, 他の人にも分かりやすいテーブル設計になりやすい&lt;/p&gt;

&lt;h2 id=&#34;er図-複数のテーブルの関係を表現する&#34;&gt;ER図 ～複数のテーブルの関係を表現する&lt;/h2&gt;

&lt;p&gt;正規化をすると, 必然的にテーブルが増加していきます. その結果, テーブル同士の依存関係が複雑になり管理が困難になります. ER(Entity Relationship)図で図示することで, 理解を助ける事ができます. Entityにはテーブルの属性, プライマリーキーなどを記述し, Entityの関係(Relationship)を線のようなものでつないでいきます. 詳しくは&lt;a href=&#34;http://itref.fc2web.com/technology/entity_relationship_diagram.html&#34;&gt;こちら&lt;/a&gt;が分かりやすいです.&lt;/p&gt;

&lt;p&gt;ER図を作成するメリットは, DB管理者以外の, アプリケーションエンジニアやマネージャーなどにも理解しやすいことだと思います. (メモ: Google Spread SheetでDB設計を書くと, 自動でER図に変換してくれたりすると嬉しい)&lt;/p&gt;

&lt;h2 id=&#34;論理設計とパフォーマンス-正規化の欠点と非正規化&#34;&gt;論理設計とパフォーマンス ～正規化の欠点と非正規化&lt;/h2&gt;

&lt;p&gt;正規化をすると, データ整合性が保ちやすくなります. しかし, テーブルの数が増えるため, 必要なデータを取得するときに, &lt;code&gt;join&lt;/code&gt;を多用することになります. joinはコストが高いオペレーションなので, パフォーマンスに影響が出る可能性があります. 正規化は往々にして &lt;strong&gt;検索のコストを上げる&lt;/strong&gt; ことになります.&lt;/p&gt;

&lt;p&gt;なので, パフォーマンスがシビアに要求される箇所は, 非正規化を行い解決します. 非正規化には, 「集約データを属性に持たせる」 or 「単純に正規化と逆のことをやる」. の2種類があります. 「集約データを属性に持たせる」とは, 例えば, ショッピングサイトでお買い物をしたとすると, オーダーテーブル, オーダーと注文した商品を関係づけるテーブル, 商品テーブルの3つのテーブルが必要だとします.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;オーダーテーブル
- オーダーID, ユーザID, 注文時間

オーダーと注文した商品を関係づけるテーブル
- オーダーID, 商品ID, 個数

商品テーブル
- 商品ID, 名前, 値段
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで, 注文したオーダーの値段が知りたいとき, オーダーと注文した商品を関係づけるテーブルと商品テーブルをjoinする必要が有ります. これは非常にコストが掛かりパフォーマンスに影響が出そうです. そこで, オーダーテーブルに合計金額を保存することにします. そうすれば, あるオーダーの値段が単純なSQLで取得することが出来ます. 多少冗長でも, よく使うであろうデータを持たせておくことで, パフォーマンスを改善できます. その代わり, 「データサイズが増える」. 「データ不整合になりやすい」. といったデメリットがあります.&lt;/p&gt;

&lt;h2 id=&#34;データベースとパフォーマンス&#34;&gt;データベースとパフォーマンス&lt;/h2&gt;

&lt;p&gt;パフォーマンスを上げるためには, インデックスの設計をする必要があります. インデックスには, 「アプリケーションコードを修正する必要がない」. 「データに何も影響を与えずにパフォーマンスを上げることが出来る」といったメリットがあります. しかし, 「インデックスファイル分, ストレージを余計に必要とする」.「データ更新時にインデックスを再構築するため, データ更新の速度が遅くなる」といったデメリットがあります.&lt;/p&gt;

&lt;p&gt;インデックスを作る列には下記の点に留意する必要が有ります.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カーディナリティの高い列に作成. また値に偏りがない.&lt;/li&gt;
&lt;li&gt;WHERE, JOIN条件に使用されている列に作成&lt;/li&gt;
&lt;li&gt;LIKE述語は前方一致のみインデックスが適用される(LIKE &amp;lsquo;abc%&amp;rsquo; はインデックスが効くが, LIKE &amp;lsquo;%abc&amp;rsquo; はインデックスが効かない)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;論理設計のバッドノウハウ&#34;&gt;論理設計のバッドノウハウ&lt;/h2&gt;

&lt;p&gt;箇条書きで説明します.&lt;/p&gt;

&lt;p&gt;ダブルミーニング
- カラムの表している意味が行(列)ごとに違う. 例えば, 体重かと思ったら, BMI値が入っている人もいるなど
    - 無駄に混乱を生むので使わないほうが良い&lt;/p&gt;

&lt;p&gt;単一参照モデル
- 1つのテーブルに区別カラムを持たせ, いろいろな種類のデータを挿入する
    - アプリケーション側で, 区別カラムを特定する必要があり, それを忘れるとバグが混入する. 無駄に混乱を生むので使わないほうが良い&lt;/p&gt;

&lt;p&gt;ダブルマスタ
- システムの統合で, 同じ用な意味を持つテーブルが複数ある状態
    - システムのクレンジングをする必要がある&lt;/p&gt;

&lt;h2 id=&#34;論理設計のグレーノウハウ&#34;&gt;論理設計のグレーノウハウ&lt;/h2&gt;

&lt;p&gt;代理キーは極力使わないようにする. 代理キーではなくて, タイムスタンプや, 日付, インターバル(開始, 終了年度)といったものを組み合わせると, 代理キーの作成を防ぐことが出来る.
- 基本, 自然キー以外を主キーに使うのはナンセンス
- 履歴などを保持したい場合は, インターバルやタイムスタンプ列を導入して解決出来ることがある&lt;/p&gt;

&lt;p&gt;列持ちテーブルではなくて, 行持ちテーブルを使う.
- 列持ちテーブル: id, name, 子1, 子2, 子3 のように列を保持
- 行持ちテーブル: id, nameというテーブルと, ID, 子(行持ち)というテーブルの2つで保持する&lt;/p&gt;

&lt;p&gt;集計キー
- 地方コードを列として追加 =&amp;gt; テーブルのサイズが大きくなり, パフォーマンスが悪化する恐れあり
- (県コード,地方コード)のrelationを表したテーブルを作成する. しかし結合が必要. Viewを使う, case when + group byを使う方法もある&lt;/p&gt;

&lt;h2 id=&#34;感想-メモ&#34;&gt;感想, メモ&lt;/h2&gt;

&lt;p&gt;広くデータベースのことが説明されている名著でした. 次は, MySQLとか, Postgreなどの具体的なDBの本を読もうと思います.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>読んだ: Web API: The Good Parts</title>
      <link>https://satoshun.github.io/2015/03/webapi_the_good_parts/</link>
      <pubDate>Sun, 15 Mar 2015 00:00:00 UTC</pubDate>
      <author>Sato Shun</author>
      <guid>https://satoshun.github.io/2015/03/webapi_the_good_parts/</guid>
      <description>

&lt;p&gt;この記事には, 僕の主観, 解釈が入っています. 本のまとめというよりかは感想的なものです.&lt;/p&gt;

&lt;h2 id=&#34;web-apiとは何か&#34;&gt;Web APIとは何か&lt;/h2&gt;

&lt;p&gt;使いやすく, 理解しやすく, 拡張性が高く設計する必要があります.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使いやすく: クライアントが苦労しない, 素直な実装が出来る&lt;/li&gt;
&lt;li&gt;理解しやすく: 「エンドポイントが明確」, 「Twitterなどの他のWeb APIを参考にし, 慣習に従っている」.&lt;/li&gt;
&lt;li&gt;拡張性が高く: インターフェースの変更はクライアントに影響するため, バージョニングなどを使うなど, クライアントに影響を与えにくい設計になっている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般に公開するLSUD(Large Set of Unknown Developers)と, 自社内のサービスで使う, SSKD(Small Set of Unknown Developers)のどちらの用途で使うかで大きく2つに分けることが出来ます. SSKDの場合は, クライアントのコントロールがしやすいので, 世間の常識から外れた設計をしても大きな問題にはなりませんが, &lt;strong&gt;理解のしやすさ&lt;/strong&gt; がなくなってしまうので, SSKDでもちゃんとした設計をする必要があります.&lt;/p&gt;

&lt;h2 id=&#34;エンドポイントの設計とリクエストの形式&#34;&gt;エンドポイントの設計とリクエストの形式&lt;/h2&gt;

&lt;p&gt;HTTPにおける, エンドポイントはURIになります. URIは&lt;strong&gt;リソースを示します&lt;/strong&gt;. 例えば, &lt;a href=&#34;http://localhost/users&#34;&gt;http://localhost/users&lt;/a&gt; なら, ホストlocalhostのユーザ一覧を指し示しています. さらに, ユーザIDが2のユーザを取得したいときは, &lt;a href=&#34;http://localhost/users/2&#34;&gt;http://localhost/users/2&lt;/a&gt; とすれば直感的です. さらにさらに, ユーザIDが2のユーザの投稿一覧を取得したいときは, &lt;a href=&#34;http://localhost/users/2/posts&#34;&gt;http://localhost/users/2/posts&lt;/a&gt; とすれば, 直感的です.&lt;/p&gt;

&lt;p&gt;ここで, 上記の例ではデータを*取得*することにだけ, 注目していましたが, データを消去したい, 更新したいなどの機能も当然必要です. HTTPでは, *method*を指定することで, それらの機能使い分けることが出来ます. よく使うmethodには, データを取得するGET, データを登録するPOST, データを更新するPUT, データを消去するDELETEがあります. 例えば, DELETE &lt;a href=&#34;http://localhost/users/2&#34;&gt;http://localhost/users/2&lt;/a&gt; とすれば, ユーザIDが2のユーザを削除することが期待でき, PUT &lt;a href=&#34;http://localhost/users/2&#34;&gt;http://localhost/users/2&lt;/a&gt; とすれば, ユーザIDが2のユーザの情報を更新することが期待されます. また, PUTと似たmethodにBATCHというものがあり, PUTは全データの上書き, BATCHは一部データの上書きという違いがあります. 例えるなら, PUTは, MongoDBの$setを使わないupdateみたいな振る舞いが, BATCHはSQLのUPDATEのように, 指定フィールドのみの更新が期待されます. URI+methodは, URIが示しているリソースに対して, methodの処理をする. とルールを統一することで理解しやすいエンドポイントを作成することが可能になります.&lt;/p&gt;

&lt;h2 id=&#34;レスポンスデータの設計&#34;&gt;レスポンスデータの設計&lt;/h2&gt;

&lt;p&gt;一般的にWEBブラウザに対して返すレスポンスデータはHTMLですが, APIに対してはJSON, XMLが主流です(他にも多々あります). 大きなブレイクするーが無い限りは, JSONに対応しておけば問題無いと思います.
具体的なレスポンスデータの中身なのですが, 出来る限りシンプルにかつ, クライアントが求めているであろうデータを返すようにします. バックグラウンド側(DBの設計など)を, レスポンスデータに反映させるのではなくて, あくまでクライアントが使いやすい形に整形してあげます. 例えば, GET &lt;a href=&#34;http://localhost/users/2&#34;&gt;http://localhost/users/2&lt;/a&gt; は, ユーザIDが2のユーザ情報を取得することが期待されますが, このサービスが, ブログシステムだとすると, このユーザが投稿したブログのリストも一緒に返してあげれば使いやすいのではないかと推測できます(あくまで例です).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;id&amp;quot;: 2,
    &amp;quot;username&amp;quot;: &amp;quot;hoge&amp;quot;,
    &amp;quot;blogs&amp;quot;: [
        {
            &amp;quot;id&amp;quot;: 1,
            &amp;quot;title&amp;quot;: &amp;quot;ぷりぷりー&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし, データが大きくなると負荷が大きくなってしまうのでやりすぎには注意が必要です. また, データ構造は出来る限りシンプルにしたほうが望ましいと思います. 上記のJSONの例で言うと, 下のような設計にすることも考えられます.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;user&amp;quot;: {
        &amp;quot;id&amp;quot;: 2,
        &amp;quot;username&amp;quot;: &amp;quot;hoge&amp;quot;,
        &amp;quot;blogs&amp;quot;: [
            {
                &amp;quot;id&amp;quot;: 1,
                &amp;quot;title&amp;quot;: &amp;quot;ぷりぷりー&amp;quot;
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key: userでユーザ固有の情報を囲いました. このようにしたほうが, userの情報ということを示せるので良いように見えます. しかし, GET &lt;a href=&#34;http://localhost/users/2&#34;&gt;http://localhost/users/2&lt;/a&gt; にアクセスしている時点で, userデータを取得しようとしていることは明白なので, 今回の場合は少し冗長なように見えます.&lt;/p&gt;

&lt;h2 id=&#34;httpの仕様を最大限利用する&#34;&gt;HTTPの仕様を最大限利用する&lt;/h2&gt;

&lt;p&gt;ステータスコードを正しく使うことが重要です. ステータスコードは正常系の2xx系, リダイレクト系の3xx系, クライアント側に起因するエラーの4xx系, サーバ側に起因するエラーの5xx系に分けることが出来ます. 正しく処理されていないのに, 2xx系を返してしまうとクライアントに誤解を与えてしまうので, 正しいステータスコードを返す必要があります.&lt;/p&gt;

&lt;p&gt;Cacheの機能を上手に使うと, クライアントは無駄な通信を減らすことができ, ユーザに良い体験をさせることが出来ます. また, リクエストの数が少なくなるため, サーバの負荷を下げることが出来ます. しかし, Cacheの時間を長く設定してしまうと, データのリアルタイム性がなくなってしまうので, エンドポイントの性質に応じて指定する必要があります.&lt;/p&gt;

&lt;h2 id=&#34;設計変更をしやすいweb-apiを作る&#34;&gt;設計変更をしやすいWeb APIを作る&lt;/h2&gt;

&lt;p&gt;一度作成したエンドポイントのレスポンスデータや, リクエストに必要なクエリを変更すると, クライアントに影響が出てしまいます. SSKDだとしてもiOS, Androidクライアントのアップデートは全員がやってくれないので, 古いバージョンのアプリで動作しなくなる可能性があります. なので, 一度作成したエンドポイントのインターフェースを修正することは容易には出来ません. しかし, APIの再設計をしなければいけないタイミングが来たとしたら, バージョニングすることで解決出来ます. 具体的には &lt;a href=&#34;http://localhost/v2/users&#34;&gt;http://localhost/v2/users&lt;/a&gt; のようにv2とバージョンを指定するようにします. 新しいクライアントアプリからは新しいバージョンを指定することで, フウリクライアントへの影響を抑えてAPIを再設計することが出来ます. しかし, 当然古いバージョンのAPIも運用する必要があり, 運用コストを考えると, 小規模なサービスではバージョニングは出来ないものと思ったほうが良いと思います.&lt;/p&gt;

&lt;h2 id=&#34;堅牢なweb-apiを作る&#34;&gt;堅牢なWeb.APIを作る&lt;/h2&gt;

&lt;p&gt;最後にセキュリティの話です. 有名なものに, XSSとXSRFがあります. XSSは攻撃者が何かしらの方法でJavaScriptのコードを登録し, そのJavaScriptをユーザに実行させることで攻撃します. XSSは, *&amp;lt;*などの文字をエスケープすることで防げます. XSRFは, 他サイトから不正なパラメータを設定し, POSTにより不正な値を登録させようとする攻撃です. これは, POSTするパラメータの中にToken(CSRFトークンみたいなもの)を持たせることで防ぐことが出来ます.&lt;/p&gt;

&lt;p&gt;AndroidやiOSといったモバイルアプリからのアクセスに限っているのなら, ブラウザからはアクセス出来ないようにするのも効果的です. APIアクセスの時は, 特別なHeaderを付与することで特定の端末からのアクセスのみ許可することが出来ます. 手軽にやるなら, User-Agentによって切り替えるの良いと思います.&lt;/p&gt;

&lt;p&gt;Cookieは, HTTPSの時にしか送れないようにする(Secure), JavaScriptからは読み込めないようにする(HttpOnly)することで, セキュアになります.
あとは, 正しいHeaderを付与するのが大切です. JSONを返しているなら application/json をメディアタイプに設定する. Varyを設定し, キャッシュをコントロールする. などです.&lt;/p&gt;

&lt;h2 id=&#34;感想-まとめ&#34;&gt;感想, まとめ&lt;/h2&gt;

&lt;p&gt;TCP/IP プロトコル解説などと比較すると, プラティカルな内容でした. 本を読むときは, 具体的な実践本 =&amp;gt; 理論書 のように読んだほうが理解が捗る気がします.&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>